/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_10001000();
int __thiscall sub_10001010(void *this);
int sub_10001022();
int sub_10001038();
int sub_10001044();
int sub_10001050();
int sub_10001066();
void *sub_10001080();
int __cdecl sub_10001090(int a1, int a2, struct __crt_locale_pointers *a3, int a4);
int sub_100010C0(int a1, ...);
int __cdecl sub_100010F0(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList); // idb
int sub_10001130(char *Buffer, char *Format, ...);
_DWORD *__thiscall sub_10001150(_DWORD *this, int a2);
_DWORD *__thiscall sub_10001190(_DWORD *this, int a2);
char *__thiscall sub_100011D0(char *Block, char a2);
_DWORD *__thiscall sub_10001220(_DWORD *this);
void __noreturn sub_10001240(void); // weak
_DWORD *__thiscall sub_10001260(_DWORD *this, int a2);
_DWORD *__thiscall sub_100012A0(_DWORD *this, int a2);
void __noreturn sub_100012E0(void); // weak
_DWORD *__thiscall sub_100012F0(_DWORD *this, int a2);
bool __thiscall sub_10001350(void *this, int a2, _DWORD *a3);
bool __thiscall sub_10001390(_DWORD *this, _DWORD *a2, int a3);
// int __cdecl std::make_error_code(_DWORD, _DWORD); weak
_DWORD *__thiscall sub_100013E0(_DWORD *this, int a2, int a3, _DWORD *a4);
char *__thiscall sub_100015E0(char *Block, char a2);
_DWORD *__thiscall sub_10001610(_DWORD *this, int a2);
_DWORD *__thiscall sub_10001660(_DWORD *this, int a2);
const char *sub_100016B0();
_DWORD *__stdcall sub_100016C0(_DWORD *a1, int a2);
void *__thiscall sub_10001780(void *Block, char a2);
_DWORD *__thiscall sub_100017A0(_DWORD *this, void *Src, int *a3);
int __thiscall sub_10001870(_DWORD *this, char a2, char a3);
_DWORD *__thiscall sub_100018F0(_DWORD *this, int a2);
_DWORD *__thiscall sub_10001940(_DWORD *this);
void **__thiscall sub_10001950(void **Src, void **Srca);
void __thiscall sub_100019D0(_DWORD *this);
_DWORD *__thiscall sub_10001A20(_DWORD *this, void *Src);
_DWORD *__thiscall sub_10001A90(_DWORD *this, void *Src, size_t Size);
_DWORD *__thiscall sub_10001AF0(_DWORD *this, _DWORD *Src);
_BYTE *__fastcall sub_10001C30(_BYTE *a1, _DWORD *a2);
void *__thiscall sub_10001C50(_DWORD *this, void *Src, size_t Size);
void __fastcall sub_10001D30(int a1, int a2);
void **__thiscall sub_10001D90(void **Src, unsigned int a2, int a3, void *Srca, size_t a5);
_BYTE *__fastcall sub_10001EF0(_BYTE *a1, int a2, unsigned int a3);
int __thiscall sub_10002140(void *this, int a2, int a3, int a4);
int __thiscall sub_10002160(_BYTE **this);
_BYTE *__thiscall sub_100021C0(_BYTE *this, int a2);
int __thiscall sub_10002250(int *this);
_BYTE *__thiscall sub_10002290(_BYTE *this);
int __thiscall sub_100023A0(_BYTE *this);
int __cdecl sub_10002420(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList); // idb
int sub_10002460(char *Buffer, size_t BufferCount, char *Format, ...);
char *__fastcall sub_10002480(const char *ArgList);
char *__thiscall sub_100025E0(const char *this);
int Main();
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
_DWORD *__thiscall sub_10002840(_DWORD *this);
void __noreturn sub_10002860(void); // weak
_DWORD *__thiscall sub_10002880(_DWORD *this, int a2);
_DWORD *__thiscall sub_100028C0(_DWORD *Block, char a2);
void __thiscall sub_100028F0(std::_Lockit *this);
void __thiscall sub_100029F0(volatile signed __int32 *this);
void __thiscall sub_10002A20(_DWORD *this);
void __thiscall sub_10002A30(_DWORD *this);
int __cdecl sub_10002A50(_DWORD *a1, int a2);
int __thiscall sub_10002C20(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_10002C40(char *this, _BYTE *a2, _BYTE *a3);
int __thiscall sub_10002C70(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_10002C90(char *this, _BYTE *a2, _BYTE *a3);
int __stdcall sub_10002CD0(void *Src, int a2, void *a3); // idb
int __stdcall sub_10002D00(void *Src, int a2, int a3, void *a4); // idb
void *__thiscall sub_10002D20(void *Block, char a2);
struct std::ios_base *__thiscall sub_10002DA0(struct std::ios_base *Block, char a2);
_DWORD *__stdcall Direct3DCreate8(int a1);
_DWORD *__thiscall sub_10003140(_DWORD *this, int a2);
int __thiscall sub_10003160(FILE **this);
FILE **__thiscall sub_10003190(FILE **this, char *Buffer, __int64 Size);
_DWORD *__thiscall sub_100031F0(int this, _DWORD *a2, __int64 a3, __int64 a4, int a5, int a6, int a7);
_DWORD *__thiscall sub_100032C0(int this, _DWORD *a2, __int64 a3, int Origin, int a5);
int __thiscall sub_100033D0(char *this, char *Buffer, __int64 ElementCount);
__int64 __thiscall sub_100035A0(char *this, char *a2, __int64 a3);
int __thiscall sub_10003790(int this);
int __thiscall sub_10003A10(_DWORD **this);
int __thiscall sub_10003A50(int this, int a2);
int __thiscall sub_10003B10(int this, char *a2);
void __thiscall sub_10003C20(FILE **this);
void __thiscall sub_10003C30(FILE **this);
void __thiscall sub_10003C40(int this);
int sub_10003DA0();
void *__thiscall sub_10003DB0(void *this, int a2, int a3, int a4);
_DWORD *__stdcall sub_10003DC0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
_DWORD *__stdcall sub_10003DF0(_DWORD *a1, int a2, int a3, int a4, int a5);
unsigned __int64 __thiscall sub_10003E20(_DWORD **this, unsigned __int8 *Src, __int64 a3);
unsigned __int64 __thiscall sub_10003F00(_DWORD **this, char *a2, __int64 a3);
int __thiscall sub_10003FE0(_DWORD **this);
int sub_10004010();
__int64 sub_10004020();
int __stdcall sub_10004030(int a1);
int *__stdcall sub_10004040(int a1);
// _BYTE *__userpurge sub_100042E0@<eax>(_BYTE *a1@<ecx>, int a2@<ebp>, int a3);
void __thiscall sub_100044D0(struct std::ios_base *this);
void __thiscall sub_10004520(void **this);
_DWORD *__thiscall sub_10004570(_DWORD *this);
void *__thiscall sub_10004590(void *Block, char a2);
_DWORD *__thiscall sub_100045C0(_DWORD *Block, char a2);
char *__thiscall sub_10004610(struct std::ios_base *this, char a2);
char *__thiscall sub_100046B0(struct std::ios_base *this, char a2);
_DWORD *__thiscall sub_10004730(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, unsigned __int8 a6, const void *ArgList);
_DWORD *__thiscall sub_10004780(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7);
_DWORD *__thiscall sub_100049A0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7);
_DWORD *__thiscall sub_10004BC0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList, int a8);
_DWORD *__thiscall sub_10004C70(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList, int a8);
_DWORD *__thiscall sub_10004D20(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList);
_DWORD *__thiscall sub_10004DC0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList);
// _DWORD *__userpurge sub_10004E60@<eax>(int a1@<ecx>, int a2@<edi>, _DWORD *a3, int a4, _DWORD *a5, _DWORD *a6, int a7, unsigned __int8 a8);
int __thiscall sub_10005050(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
unsigned int __stdcall sub_10005080(int a1, int a2, int a3, unsigned int a4);
int __stdcall sub_100050A0(int a1, int a2, int a3, _DWORD *a4);
int __stdcall sub_100050C0(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7);
char sub_100050E0();
_DWORD *__thiscall sub_100050F0(_DWORD *this, int a2);
bool __thiscall sub_10005180(void *this);
int __thiscall sub_10005220(int this, FILE *Stream, char **Base);
_DWORD *__thiscall sub_10005310(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10005340(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_100053B0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_10005420(_DWORD *this, _DWORD *a2);
char __thiscall sub_10005490(_BYTE *this);
char __thiscall sub_100054A0(_BYTE *this);
_DWORD *__cdecl sub_100054B0(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 a5, int a6);
_DWORD *__cdecl sub_10005520(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6);
_DWORD *__cdecl sub_10005590(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, unsigned __int8 a6, _BYTE *Val, size_t Size);
_DWORD *__cdecl sub_10005970(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, unsigned __int8 a6, char *Str, unsigned int Control);
_BYTE *__cdecl sub_10005DA0(int a1, _BYTE *a2, char a3, __int16 a4);
void **__thiscall sub_10005E60(_DWORD *this, unsigned int a2, char Val);
void **__thiscall sub_10005EE0(void **Block, char a2);
_DWORD *__thiscall sub_10005F60(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_10005FF0(_DWORD *this, size_t Size, char a3);
void __noreturn sub_10006120(void); // weak
struct std::_Facet_base *__cdecl sub_10006130(int a1);
_BYTE *__fastcall sub_10006250(_BYTE *a1, const char *a2);
_BYTE *__cdecl sub_100064E0(_BYTE *a1);
struct std::_Facet_base *__cdecl sub_10006580(int a1);
struct std::_Facet_base *__cdecl sub_100066A0(int a1);
struct std::_Facet_base *__cdecl sub_100067C0(int a1);
void **__thiscall sub_100068E0(void **Src, int a2, int a3, char a4);
const void **__thiscall sub_10006A20(const void **Src, unsigned int a2, int a3, size_t Size, size_t a5, char Val);
void **__thiscall sub_10006BA0(void **Src, unsigned int a2, int a3, size_t a4, char Val);
int __cdecl sub_10006D10(_DWORD *a1, int a2);
int __cdecl sub_10006FB0(_DWORD *a1, int a2);
int __cdecl sub_10007160(_DWORD *a1, int a2);
_BYTE *__thiscall sub_10007310(_BYTE *this, unsigned __int8 a2);
void __thiscall sub_100074A0(void ***this);
char *__thiscall sub_100074F5(_DWORD *this, char a2);
char *__thiscall sub_100074FD(_DWORD *this, char a2);
int __stdcall sub_10007510(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __cdecl sub_100075A0(int a1);
int __stdcall sub_100075C0(_DWORD **Block);
int __cdecl sub_10007630(int a1);
int __stdcall sub_10007650(int a1);
int __stdcall sub_10007660(int a1, int a2, int a3, _DWORD *a4);
int __stdcall sub_10007740(int a1, int a2);
int __stdcall sub_10007760(int a1, unsigned int a2, unsigned int a3, _DWORD *a4);
int __cdecl sub_10007800(int a1);
int __cdecl sub_10007820(int a1);
int __stdcall sub_10007840(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __stdcall sub_10007890(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_100078C0(int a1);
int __stdcall sub_100078E0(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_10007980(int a1);
int __stdcall sub_100079A0(int a1, int a2, void *Block, int a4, void *a5, _DWORD *a6, _DWORD *a7);
// _BYTE *__userpurge sub_10007C40@<eax>(_BYTE *a1@<ecx>, int a2@<ebp>, int a3);
// _BYTE *__userpurge sub_10007E10@<eax>(_BYTE *a1@<ecx>, int a2@<ebp>, int a3);
void __thiscall sub_10007FE0(void **this);
void __thiscall sub_10008040(_DWORD *this);
int __thiscall sub_10008060(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_10008090(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
void __noreturn sub_100080C0(void); // weak
_DWORD *__thiscall sub_100080D0(const void **this, _BYTE *Src, _DWORD *a3);
void __noreturn sub_10008240(void); // weak
int __cdecl sub_10008250(va_list ArgList);
int sub_10008290(char *Format, ...);
void **__thiscall sub_100082B0(_DWORD *this, void **a2);
int __cdecl sub_10008400(int a1);
int __cdecl sub_10008420(int a1);
int __cdecl sub_10008440(int a1);
int __cdecl sub_10008450(int a1);
_DWORD *__fastcall sub_10008460(_DWORD *a1, int a2);
_DWORD *__fastcall sub_100084E0(_DWORD *a1, unsigned int a2);
char *__cdecl sub_10008530(float a1);
_DWORD *__thiscall sub_100085E0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10008610(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10008640(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10008670(_DWORD *Block, char a2);
_DWORD *__thiscall sub_100086C0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10008740(_DWORD *Block, char a2);
int __fastcall sub_10008770(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __stdcall sub_10008850(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __cdecl sub_100088E0(int a1);
int __stdcall sub_10008900(_DWORD **a1);
int __cdecl sub_100089E0(int a1);
int __cdecl sub_10008A00(int a1);
int __stdcall sub_10008A20(int a1, int a2);
int __stdcall sub_10008A40(int a1, _DWORD *a2);
int __stdcall sub_10008A70(int a1, _DWORD *a2);
int __stdcall sub_10008B10(int a1, int a2);
int __cdecl sub_10008B30(int a1);
int __stdcall sub_10008B50(int a1, int a2, int a3, int a4);
int __cdecl sub_10008B80(int a1);
int __cdecl sub_10008BA0(int a1);
int __stdcall sub_10008BC0(_DWORD *Block, _DWORD *a2, _DWORD *a3);
int __stdcall sub_10008D90(_DWORD *a1, _DWORD *a2);
int __cdecl sub_10008EC0(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_10008EE0@<eax>(int a1@<esi>, int a2, int a3, void *Block, _DWORD *a5);
int __stdcall sub_10009020(int a1, int a2);
int __stdcall sub_10009040(int a1, int a2, int a3);
int __stdcall sub_10009060(int a1, int a2);
int __stdcall sub_10009080(int a1, int a2, int a3, int a4, int a5, int a6, void *Block, _DWORD *a8);
int __stdcall sub_100091B0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, void *Block, _DWORD *a9);
int __stdcall sub_10009290(_DWORD *a1, int a2, int a3, int a4, int a5, void *Block, _DWORD *a7);
int __stdcall sub_10009370(_DWORD *a1, int a2, int a3, int a4, void *Block, _DWORD *a6);
int __stdcall sub_10009450(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int __stdcall sub_10009530(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7);
int __stdcall sub_10009650(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __stdcall sub_10009770(int a1, void *Block, int a3, int a4, _DWORD *a5);
int __stdcall sub_100099A0(int a1, int a2, int *a3, unsigned int a4, int a5, int a6);
int __stdcall sub_10009CF0(int a1, _DWORD *a2, _DWORD *a3);
int __stdcall sub_10009D50(int a1, int a2);
int __stdcall sub_10009D80(int a1, int a2, int a3);
// int __userpurge sub_10009DE0@<eax>(int a1@<esi>, int a2, int **a3);
// int __userpurge sub_10009F20@<eax>(int a1@<esi>, int a2, int **a3);
_DWORD *__thiscall sub_1000A060(_DWORD *this);
int __stdcall sub_1000A110(int a1);
int __stdcall sub_1000A150(int a1);
int __stdcall sub_1000A220(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_1000A250(int a1);
int __cdecl sub_1000A270(int a1);
int __cdecl sub_1000A290(int a1);
int __stdcall sub_1000A2B0(int a1, int a2);
int __cdecl sub_1000A310(int a1);
int __cdecl sub_1000A330(int a1);
int __cdecl sub_1000A350(int a1);
int __cdecl sub_1000A370(int a1);
int __cdecl sub_1000A390(int a1);
int __cdecl sub_1000A3B0(int a1);
int __cdecl sub_1000A3D0(int a1);
int __stdcall sub_1000A3F0(int a1, unsigned int a2, _DWORD *a3);
int __stdcall sub_1000A430(int a1, unsigned int a2, _DWORD *a3);
int __stdcall sub_1000A470(int a1, int a2, float a3);
int __stdcall sub_1000A5F0(int a1, int a2, float *a3);
int __cdecl sub_1000A7A0(int a1);
int __stdcall sub_1000A7C0(int a1, int a2);
int __stdcall sub_1000A7F0(int a1, int a2);
int __stdcall sub_1000A810(int a1, int a2);
int __stdcall sub_1000A830(int a1, int a2);
int __stdcall sub_1000A850(int a1, int a2, int a3);
int __cdecl sub_1000A8E0(int a1);
int __cdecl sub_1000A900(int a1);
int __stdcall sub_1000A920(_DWORD *a1, void *a2, _DWORD *a3);
int __stdcall sub_1000AC60(int a1, int a2, _DWORD *a3);
int __cdecl sub_1000ACC0(int a1, int a2, int a3);
int __cdecl sub_1000AE20(int a1, int a2, int a3);
int __cdecl sub_1000AF80(int a1);
int __stdcall sub_1000AFA0(int a1, int a2, int a3, int a4);
int __stdcall sub_1000B040(int a1, int a2, int a3);
int __stdcall sub_1000B070(int a1, int a2, int a3);
int __stdcall sub_1000B0A0(int a1, int a2);
int __stdcall sub_1000B0D0(int a1, int a2);
int __cdecl sub_1000B100(int a1);
int __stdcall sub_1000B120(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1000B160(int a1);
int __cdecl sub_1000B180(int a1);
int __stdcall sub_1000B1A0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __userpurge sub_1000B1E0@<eax>(int a1@<esi>, int a2, int a3, unsigned int a4, unsigned int *a5, int a6);
int __stdcall sub_1000DE50(int a1, int a2);
int __stdcall sub_1000DEB0(int a1, _DWORD *a2);
int __stdcall sub_1000DEF0(_DWORD *a1, int a2);
int __cdecl sub_1000DF50(int a1);
int __cdecl sub_1000DF70(int a1);
int __stdcall sub_1000DF90(int a1, int a2, int a3, int a4);
int __stdcall sub_1000E050(int a1, int a2, int a3, int a4);
int __stdcall sub_1000E130(int a1, int a2, int a3, int a4);
int __stdcall sub_1000E170(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __stdcall sub_1000E2D0(int a1, int a2, unsigned int a3);
int __stdcall sub_1000E310(_DWORD *a1, int **a2, int **a3);
int __stdcall sub_1000E470(int a1, int a2, int a3);
_DWORD *__thiscall sub_100116E0(_DWORD *this);
void __thiscall sub_10011720(_DWORD *this);
int __cdecl sub_100117B0(int a1, int a2);
int __stdcall sub_100117D0(int a1, _DWORD *a2);
int __stdcall sub_10011800(_DWORD *a1, int a2);
int __cdecl sub_10011840(int a1);
int __cdecl sub_10011860(int a1);
int __stdcall sub_10011880(int a1, int a2, int a3, int a4);
int __cdecl sub_10011950(int a1);
int __cdecl sub_10011970(int a1);
int __cdecl sub_10011990(int a1);
char *__thiscall sub_100119B0(char *this);
_DWORD *__thiscall sub_10011A00(_DWORD *this, _DWORD *a2, int a3);
int __thiscall sub_10011A20(_DWORD *this, int a2);
int __thiscall sub_10011A40(_DWORD *this);
_DWORD *__thiscall sub_10011A60(_DWORD *this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_10011AD0(int *this, _DWORD *Src);
void __thiscall sub_10011BD0(int *this);
int __thiscall sub_10011C30(int this, const char *a2, int a3);
_BYTE *__thiscall sub_10011CA0(_BYTE *this, int a2);
char *__thiscall sub_10011E50(char *this, void (__cdecl *a2)(char *));
_DWORD *__thiscall sub_10011E70(_DWORD *this, _DWORD *a2, unsigned int a3, unsigned int a4);
int __thiscall sub_10011EF0(_DWORD *this, char *a2, unsigned int a3);
int __thiscall sub_10011F30(_DWORD *this, int a2, unsigned int a3);
char *__thiscall sub_10011F60(_DWORD *this, unsigned int a2);
const void **__thiscall sub_10011F80(const void **Src, size_t a2, int a3, char *a4);
const void **__thiscall sub_10011FB0(const void **this, size_t Size, char *a3);
void **__thiscall sub_10011FD0(void **Src, const char *Srca);
struct std::_Facet_base **__thiscall sub_10012060(struct std::_Facet_base **this);
int __thiscall sub_100121B0(int *this);
const void **__thiscall sub_10012200(const void **Src, size_t a2, int a3, char *Srca, size_t Size);
const void **__thiscall sub_10012380(const void **Src, size_t Size, char *Srca, size_t a4);
size_t *__thiscall sub_10012450(size_t *this, void *Src, size_t Size);
void __stdcall sub_10012580(_DWORD *Block, int a2);
_DWORD *__fastcall sub_100125C0(_DWORD *a1, char *Src, void **a3);
const void **__fastcall sub_10012620(const void **a1, char *a2, const void **Src);
_DWORD *__fastcall sub_100126A0(_DWORD *a1, _DWORD *Src);
void **__fastcall sub_100126F0(void **a1, void **a2, char *Src);
void **__fastcall sub_100127B0(void **a1, int a2, void **Src);
void **__fastcall sub_10012870(void **a1, void **a2, _DWORD *Src);
_DWORD *__fastcall sub_10012890(_DWORD *a1, char *a2);
int __fastcall sub_10012920(int a1, char *a2, int *a3, void *Src, int a5);
char __fastcall sub_10012A20(int *a1, int *a2);
int __thiscall sub_10012A50(int this, int *a2, int a3);
void **__fastcall sub_10012AC0(void **Src, char *a2, int *a3, char *a4, int a5);
void __thiscall sub_10012B50(int *this, int a2, int a3, int a4);
int __fastcall sub_10012CA0(int a1, unsigned int a2, unsigned int a3, char *a4, unsigned int a5);
void __fastcall sub_10012DA0(_DWORD *a1, _DWORD *a2);
const void **__thiscall sub_10012DD0(const void **Src, unsigned int a2, int a3, size_t Size, int a5, void *Srca, size_t a7);
const void **__thiscall sub_10012F50(const void **Src, unsigned int a2, int a3, size_t Size, void *Srca, size_t a6);
int __stdcall sub_10013120(int a1, int a2);
char *__thiscall sub_10013160(_Collvec *this, char *String1, char *a3, char *a4);
int __thiscall sub_100132D0(const _Collvec *this, char *a2, char *a3, char *a4, char *a5);
int __cdecl sub_10013310(_Collvec **a1, _DWORD *a2);
void **__thiscall sub_10013570(void **this, int a2, void **a3, _DWORD *Src);
_DWORD *__thiscall sub_100137A0(_DWORD *this, int a2, int a3, void *Src, size_t Size, void *a6, size_t a7);
_DWORD *__thiscall sub_100138B0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10013920(_DWORD *this, _BYTE *Src, _BYTE *a3, int a4);
char __fastcall sub_10013A70(int a1, char *a2, int a3, int *a4, unsigned int a5, int a6);
int __thiscall sub_10013DD0(int *this, int a2, _DWORD *Src);
_DWORD *__thiscall sub_10014000(_DWORD *this);
void __thiscall sub_10014220(_DWORD *this);
void __noreturn sub_100143B0(void); // weak
void __cdecl __noreturn sub_100143C0(int a1);
int __thiscall sub_100143D0(_BYTE *this);
char __thiscall sub_10014620(int this);
int __thiscall sub_100148C0(_DWORD *this, int a2);
void ***__fastcall sub_10014950(void ***a1, char *a2, void **Src, char *a4, int *a5, char *a6, int a7);
int __thiscall sub_10014B80(_DWORD *this, char *a2, char *a3, int a4);
bool __thiscall sub_10014E00(int this, int a2, int a3);
_DWORD *__fastcall sub_10014FA0(int a1, int a2, _DWORD *a3);
unsigned int __thiscall sub_100150E0(_DWORD *this, unsigned int a2);
// int **__userpurge sub_10015180@<eax>(int a1@<ecx>, int a2@<ebp>, unsigned int a3, int a4);
char __thiscall sub_100152B0(_DWORD *this, __int16 a2);
void *__thiscall sub_10015330(void *Block, char a2);
// unsigned int **__userpurge sub_10015450@<eax>(unsigned int **a1@<ecx>, int a2@<ebp>, unsigned int **a3, signed int a4, char *a5, int a6, int a7);
int **__thiscall sub_100155F0(int **this, int **a2, int a3, int a4, int a5, int a6);
// int __userpurge sub_10015840@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, unsigned int a3, int a4, int a5);
_DWORD *__stdcall sub_10015A60(unsigned int a1);
char __thiscall sub_10015AC0(int this);
bool __thiscall sub_10015FD0(char **this, int a2);
int **__thiscall sub_10016580(_DWORD *this, int **a2, _DWORD *a3, int a4);
void ***__fastcall sub_100165F0(void ***a1, char *a2, char *a3, void **Src);
char *__fastcall sub_10016660(char *a1, char *a2, char *a3, char *a4, int a5, char *a6);
char *__fastcall sub_10016760(char *a1, char *a2, _DWORD *a3);
char *__thiscall sub_100167D0(int this, unsigned int a2, int a3);
_DWORD *__thiscall sub_10016900(_DWORD *this, _DWORD *a2);
int __thiscall sub_10016990(int this);
char __thiscall sub_10016AD0(int this);
char __thiscall sub_10016C20(int this);
int __thiscall sub_10016E60(int this);
int __thiscall sub_10017090(_DWORD *this, int a2);
char __thiscall sub_10017200(int this, int a2);
char __thiscall sub_10017400(int this, _DWORD *a2, char a3, int a4);
bool __thiscall sub_10017640(_DWORD *this);
void ***__fastcall sub_100176E0(void ***a1, int a2, void **Src, char *a4, char *a5);
void ***__fastcall sub_10017850(unsigned int a1, int a2, void **Src, char *a4, char *a5);
_DWORD *__thiscall sub_10017B90(int this, unsigned int a2, int a3);
char *__thiscall sub_10017C70(int this, unsigned int a2, int a3);
char *__thiscall sub_10017DF0(int this, unsigned int a2, _DWORD *a3);
char *__thiscall sub_10017F00(void **this, char *Src, unsigned int a3);
char *__thiscall sub_10018060(void **this, char *Src, unsigned int a3);
_DWORD *__thiscall sub_100181C0(_DWORD *this, _DWORD *a2);
bool __thiscall sub_100182C0(_DWORD *this, char a2, char a3);
_DWORD *__stdcall sub_100183D0(unsigned int a1);
char __thiscall sub_10018430(int this, char a2);
int __thiscall sub_100184F0(int this);
char __thiscall sub_10018820(int this);
int __thiscall sub_10018BB0(_DWORD *this);
int __thiscall sub_10018CA0(_DWORD *this, unsigned __int8 a2);
int __thiscall sub_10018D90(_DWORD *this);
int __thiscall sub_10018E20(_DWORD *this, int a2, int a3, unsigned __int8 a4);
char __thiscall sub_100190E0(void **this, _DWORD *a2, char a3);
void **__thiscall sub_10019360(void **Block, char a2);
int __thiscall sub_100193C0(int this, int a2, int a3, int a4);
int __thiscall sub_100194C0(int this);
char __thiscall sub_100197B0(_DWORD *this, char a2);
unsigned int __thiscall sub_10019820(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_10019990(_DWORD *this, unsigned __int16 a2, char a3);
int __thiscall sub_10019A50(_DWORD *this, int a2);
int __thiscall sub_10019AF0(_DWORD **this, char *a2, char *a3, char a4);
unsigned int __thiscall sub_10019BC0(unsigned int *this, size_t Size);
int __thiscall sub_10019C50(int this, int a2);
void __thiscall sub_10019E40(int this, void *Src, size_t Size, size_t a4);
_DWORD *__stdcall sub_1001A000(char *a1, char *a2, _DWORD *a3, _DWORD **a4);
int __thiscall sub_1001A0B0(_DWORD *this, int a2, void *Src, size_t Size);
void __thiscall sub_1001A290(_DWORD *this);
_DWORD *__thiscall sub_1001A2A0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1001A2D0(_DWORD *Block, char a2);
int __stdcall sub_1001A300(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __cdecl sub_1001A3D0(int a1);
int __cdecl sub_1001A3F0(int a1);
int __cdecl sub_1001A410(int a1);
int __cdecl sub_1001A430(int a1);
int __cdecl sub_1001A450(int a1);
int __cdecl sub_1001A470(int a1);
int __cdecl sub_1001A490(int a1);
int __stdcall sub_1001A4B0(int a1);
int __stdcall sub_1001A4C0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1001A520(int a1);
int __cdecl sub_1001A540(int a1);
int __thiscall sub_1001A560(_DWORD *this, unsigned __int8 *a2);
int __thiscall sub_1001A580(_DWORD *this, int a2, unsigned __int8 *a3);
_DWORD *__thiscall sub_1001A7C0(_DWORD *this, unsigned int a2);
void __thiscall sub_1001A930(_DWORD *this, unsigned int a2, int a3);
_DWORD *__thiscall sub_1001AA1F(_DWORD *this, char a2);
_DWORD *__thiscall sub_1001AA30(_DWORD *Block, char a2);
int __stdcall sub_1001AA60(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __cdecl sub_1001AAF0(int a1);
int __stdcall sub_1001AB10(int a1, unsigned int *a2);
int __cdecl sub_1001ABA0(int a1);
_DWORD *__thiscall sub_1001ABB2(_DWORD *this, char a2);
_DWORD *__thiscall sub_1001ABC0(_DWORD *Block, char a2);
int __stdcall sub_1001ABF0(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __stdcall sub_1001AC80(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_1001ACA0@<eax>(int a1@<esi>, int a2, int a3, _DWORD *a4, _DWORD *a5);
_DWORD *__thiscall sub_1001ADE0(_DWORD *this, char a2);
_DWORD *__thiscall sub_1001ADF0(_DWORD *Block, char a2);
int __stdcall sub_1001AE20(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __stdcall sub_1001AF20(int a1);
int __cdecl sub_1001AF30(int a1);
int __stdcall sub_1001AF50(int a1, int a2, unsigned int *a3);
// int __userpurge sub_1001AFE0@<eax>(int a1@<esi>, int a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_1001B120(int a1);
int __cdecl sub_1001B140(int a1);
int __cdecl sub_1001B160(int a1);
_DWORD *__thiscall sub_1001B180(_DWORD *Block, char a2);
int __stdcall sub_1001B1B0(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __stdcall sub_1001B2B0(int a1);
// int __userpurge sub_1001B2C0@<eax>(int a1@<esi>, int a2, int a3, _DWORD *a4, _DWORD *a5);
_DWORD *__thiscall sub_1001B400(_DWORD *Block, char a2);
int __stdcall sub_1001B430(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __stdcall sub_1001B530(int a1);
int __stdcall sub_1001B540(int a1, int a2, unsigned int *a3);
// int __userpurge sub_1001B5C0@<eax>(int a1@<esi>, int a2, _DWORD *a3, _DWORD *a4);
_DWORD *__thiscall sub_1001B709(_DWORD *this, char a2);
_DWORD *__thiscall sub_1001B711(_DWORD *this, char a2);
_DWORD *__thiscall sub_1001B719(_DWORD *this, char a2);
_DWORD *__thiscall sub_1001B730(_DWORD *Block, char a2);
int __stdcall sub_1001B760(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __stdcall sub_1001B830(int a1);
int __stdcall sub_1001B840(int a1, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_1001B892(_DWORD *this, char a2);
_DWORD *__thiscall sub_1001B8A0(_DWORD *Block, char a2);
int __stdcall sub_1001B8D0(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3);
int __stdcall sub_1001B960(int a1, unsigned int *a2);
int __cdecl sub_1001B9E0(int a1);
_DWORD *__thiscall sub_1001B9F2(_DWORD *this, char a2);
int __fastcall sub_1001BA00(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_1001BB20(_DWORD *a1, _DWORD *a2);
void __thiscall sub_1001BBE0(void *); // idb
void __thiscall sub_1001BBF0(int this);
void __thiscall sub_1001BC80(_DWORD *this);
int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD); // weak
_DWORD *__thiscall sub_1001BDBC(_DWORD *this);
_DWORD *__thiscall sub_1001BDD4(_DWORD *this, int a2);
_DWORD *__thiscall sub_1001BDEF(_DWORD *this, int a2);
_DWORD *__thiscall sub_1001BE0E(_DWORD *this, int a2);
_DWORD *__thiscall sub_1001BE29(_DWORD *this, int a2);
_DWORD *__thiscall sub_1001BE44(_DWORD *this, int a2);
_DWORD *__thiscall sub_1001BEB5(_DWORD *this, int a2);
void __noreturn sub_1001BFF1(void); // weak
void __cdecl __noreturn sub_1001C00E(int a1);
void __cdecl __noreturn sub_1001C02E(int a1);
// void __cdecl __noreturn std::_Xregex_error(_DWORD); weak
void __cdecl __noreturn sub_1001C06E(int a1);
// const char *__cdecl std::_Syserror_map(int); idb
// _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); idb
// _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int); idb
// void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
// void __thiscall std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(std::_Fac_tidy_reg_t *__hidden this); idb
// int __stdcall std::_Yarn<char>::operator=(void *Src); idb
// void __cdecl std::_Facet_Register(struct std::_Facet_base *); idb
int sub_1001C2BD();
struct std::locale::_Locimp *__cdecl sub_1001C2C3(char a1);
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *Locale); idb
// void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); idb
// struct std::locale::_Locimp *__cdecl std::locale::_Locimp::_New_Locimp(bool); idb
// void __cdecl std::locale::_Setgloballocale(void *); idb
// void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *); idb
FILE *__cdecl sub_1001C5C3(char *FileName, int a2, int ShFlag);
FILE *__cdecl sub_1001C63D(char *FileName, int a2, int ShFlag);
// _Ctypevec *__cdecl _Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// int __cdecl _Tolower(int, const _Ctypevec *);
// _Cvtvec *__cdecl _Getcvt(_Cvtvec *__return_ptr __struct_ptr retstr);
// int __cdecl _Toupper(int, const _Ctypevec *);
// size_t __cdecl _Strxfrm(char *String1, char *End1, const char *, const char *, const _Collvec *);
// __int64 __cdecl _Query_perf_counter();
// __int64 __cdecl _Query_perf_frequency();
// _Collvec __cdecl _Getcoll();
// int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *);
// int __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection); idb
void __cdecl sub_1001CB1F(LPCRITICAL_SECTION lpCriticalSection);
// void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *__hidden this); idb
// void *__cdecl operator new(size_t Size); idb
char sub_1001D235();
__vcrt_bool sub_1001D299();
// int __cdecl atexit(void (__cdecl *)());
void __cdecl sub_1001D481(void *Block);
_DWORD *__thiscall sub_1001D48F(_DWORD *Block, char a2);
void __cdecl j_j__free(void *Block);
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *)); idb
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
void sub_1001DD8F();
int sub_1001DD97();
void __cdecl j__free(void *Block);
void sub_1001DE92();
int sub_1001DE9E();
void *sub_1001DEAA();
void *sub_1001DECD();
void sub_1001DED3();
void sub_1001DEFF();
// _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD); weak
// _DWORD __cdecl __std_exception_destroy(_DWORD); weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
int sub_1001E9CB();
// char *__cdecl strchr(const char *Str, int Val);
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// __vcrt_bool __cdecl __vcrt_thread_detach();
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
// __vcrt_bool __cdecl __vcrt_uninitialize_critical();
// int __cdecl __std_type_info_destroy_list(PSLIST_HEADER ListHead); idb
_DWORD *__thiscall sub_10021652(_DWORD *this, int a2);
_DWORD *__thiscall sub_1002166D(_DWORD *this);
void __stdcall sub_10021D30(int a1);
// int __usercall sub_10021D60@<eax>(int (*a1)(void)@<eax>);
// double __cdecl ceil(double X);
// FILE *__cdecl __acrt_iob_func(unsigned int Ix);
// errno_t __cdecl _get_stream_buffer_pointers(FILE *Stream, char ***Base, char ***Pointer, int **Count);
// void __cdecl _lock_file(FILE *Stream);
// void __cdecl _unlock_file(FILE *Stream);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_5(_DWORD, _DWORD, _DWORD); weak
char __thiscall sub_100229A4(int this, int a2);
char __thiscall sub_10022B21(int this, char a2);
char __thiscall sub_10022C9E(int this, char a2);
// _DWORD __stdcall unknown_libname_6(_DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_7(_DWORD, char); weak
// _DWORD __stdcall unknown_libname_8(_DWORD, char); weak
// _DWORD __stdcall unknown_libname_9(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_10(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD, char); weak
// __crt_cached_ptd_host *__thiscall __crt_cached_ptd_host::__crt_cached_ptd_host(__crt_cached_ptd_host *__hidden this, struct __crt_locale_pointers *const); idb
// void __thiscall __crt_cached_ptd_host::~__crt_cached_ptd_host(__crt_cached_ptd_host *__hidden this); idb
char __thiscall sub_10023DD4(int this);
char __thiscall sub_10023F32(int this);
char __thiscall sub_10024090(int this);
char __thiscall sub_100243D8(int this);
// int __cdecl __crt_stdio_output::to_integer_size(_DWORD); weak
// int __thiscall unknown_libname_18(_DWORD); weak
// int __thiscall unknown_libname_19(_DWORD); weak
// _DWORD __stdcall unknown_libname_20(_DWORD); weak
// int __thiscall unknown_libname_21(_DWORD); weak
char __thiscall sub_10024AB7(_DWORD *this);
char __thiscall sub_10024AD4(_DWORD *this);
// int __thiscall unknown_libname_22(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char, _DWORD); weak
// _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall unknown_libname_25(void *Src, int, int, int); idb
int __cdecl sub_10024EB6(int a1, int a2, int a3, int a4, struct __crt_locale_pointers *a5, int a6); // idb
// int __cdecl __stdio_common_vsprintf(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// int __cdecl __stdio_common_vsprintf_s(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
int __cdecl sub_1002513E(int a1);
// int __cdecl _invalid_parameter_internal(wchar_t *Expression, wchar_t *FunctionName, wchar_t *FileName, unsigned int LineNo, uintptr_t Reserved, __crt_cached_ptd_host *); idb
// void __cdecl __noreturn _invalid_parameter_noinfo_noreturn();
int __cdecl sub_10025BDA(int a1);
int sub_10025C0E();
// FILE *__cdecl freopen(const char *FileName, const char *Mode, FILE *Stream);
// void *__cdecl calloc(size_t Count, size_t Size);
// FILE *__cdecl _fsopen(const char *FileName, const char *Mode, int ShFlag);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl common_flush_all(bool); idb
int sub_10026169();
// int __cdecl fflush(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// int __cdecl _fseeki64(FILE *Stream, __int64 Offset, int Origin);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// int __cdecl fgetc(FILE *Stream);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl free(void *Block);
// int __cdecl __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>,1>(__crt_cached_ptd_host *, int, int, int, char); idb
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void *__cdecl malloc(size_t Size);
// int __cdecl fputc(int Character, FILE *Stream);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// double __cdecl fabs(double X);
// struct lconv *__cdecl localeconv();
// int __cdecl fgetpos(FILE *Stream, fpos_t *Position);
// int __cdecl setvbuf(FILE *Stream, char *Buffer, int Mode, size_t Size);
// int __cdecl ungetc(int Character, FILE *Stream);
// double __cdecl frexp(double X, int *Y);
// int __cdecl fsetpos(FILE *Stream, const fpos_t *Position);
// void *__cdecl realloc(void *Block, size_t Size);
int __cdecl sub_10027E6A(int a1, int a2, int a3);
// _DWORD __cdecl __acrt_lock(_DWORD); weak
// _DWORD __cdecl __acrt_unlock(_DWORD); weak
int __stdcall sub_10027F67(_DWORD *a1, int a2, _DWORD *a3);
// int __thiscall _lambda_2116bde18c9e5f34230805ea4a4660ed_::operator()(_DWORD); weak
// _DWORD __cdecl __acrt_errno_map_os_error(_DWORD); weak
// int *__cdecl _errno();
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); idb
// int __cdecl __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *, int, UINT CodePage); idb
int __cdecl sub_1002926D(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *a2, UINT CodePage); // idb
// int __stdcall unknown_libname_28(UINT CodePage, LPCWCH lpWideCharStr, LPSTR lpMultiByteStr, int cbMultiByte); idb
// int __thiscall unknown_libname_29(_DWORD); weak
int __thiscall sub_100292EF(void **this, int a2);
// int __cdecl __crt_win32_buffer_internal_dynamic_resizing::allocate(void **const, size_t Size, const struct __crt_win32_buffer_empty_debug_info *); idb
int __cdecl sub_10029633(int a1);
// int __cdecl unknown_libname_31(void *Block); idb
void *__cdecl sub_10029CA7(void **a1);
void *__cdecl sub_10029CC2(void **a1);
// _DWORD __cdecl __dcrt_uninitialize_environments_nolock(_DWORD, _DWORD); weak
int __stdcall sub_10029D33(_DWORD *a1, int a2, _DWORD *a3);
int __stdcall sub_10029D8E(_DWORD *a1, int a2, _DWORD *a3);
// int __thiscall unknown_libname_33(_DWORD); weak
// int __thiscall unknown_libname_34(_DWORD); weak
int __cdecl sub_10029FE4(_onexit_t Function); // idb
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_1002A0E7();
_DWORD sub_1002A10E(); // weak
__vcrt_bool sub_1002A144();
bool sub_1002A1A4();
// __crt_bool __cdecl __acrt_thread_detach();
// __crt_bool __cdecl __acrt_uninitialize_critical(__crt_bool Terminating);
BOOL __stdcall LocaleEnumProc(LPWSTR a1); // idb
// _DWORD __stdcall _lambda_29d3c280b90b41c2ae070ffca879996a_::operator()(_DWORD); weak
int sub_1002ABE8();
int sub_1002AC1C();
int sub_1002AC36();
int sub_1002AC50();
int sub_1002AC6A();
int sub_1002AC84();
int sub_1002AC9E();
// int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD); weak
LPVOID __stdcall sub_1002AF37(DWORD a1);
int __stdcall sub_1002B0F5(wchar_t *a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, int a7, int a8, int a9); // idb
// int __stdcall __acrt_LocaleNameToLCID(wchar_t *, int); idb
struct __crt_locale_data *__cdecl sub_1002B53A(int a1, struct __crt_locale_data **a2);
int __cdecl sub_1002B567(int a1, int *a2, int a3);
struct __crt_multibyte_data *__cdecl sub_1002B598(int a1, struct __crt_multibyte_data **a2);
int __cdecl sub_1002B5C5(int a1, int *a2, int a3);
// int __cdecl _wctomb_internal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int unknown_libname_36(void); weak
__int32 sub_1002CF4E();
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_d422a76eb4c3bf3ad751449ab71a6ea4_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_9476263c8ee91a25d21c55370bdb50de_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10030035(int a1, __crt_cached_ptd_host *a2); // idb
// int __cdecl common_flush_and_write_nolock<char>(int, FILE *Stream, int); idb
int __cdecl sub_1003058F(int a1, FILE *a2, int a3);
int sub_100306CE();
// _DWORD __cdecl sub_1003082C(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_100308A4(int a1, int a2, int a3);
// int __cdecl __acrt_WideCharToMultiByte(UINT CodePage, int, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, int, int); idb
int __cdecl sub_10033BEC(LPCWCH lpWideCharStr, struct __crt_win32_buffer_empty_debug_info *a2, int a3, UINT CodePage); // idb
int __thiscall sub_1003418E(void **this, size_t Size);
// int __acrt_update_thread_multibyte_data(void); weak
char sub_10034C18();
int __cdecl sub_10034CD3(int a1);
int sub_10034D28();
// int __acrt_update_thread_locale_data(void); weak
int __cdecl sub_1003A320(wchar_t Source, struct __crt_locale_pointers *a2); // idb
// void __cdecl __dcrt_lowio_initialize_console_output(); idb
BOOL sub_1003B1E3();
// int __cdecl __acrt_LCMapStringW(wchar_t *, DWORD dwMapFlags, wchar_t *Source, size_t MaxCount, LPWSTR lpDestStr, int cchDest); idb
int sub_1003BB04();
// int __usercall sub_1003BF00@<eax>(double _ST7@<st0>);
void __cdecl sub_1003D970(); // idb
void __cdecl sub_1003DA00(); // idb
void __cdecl sub_1003DA99(); // idb
void __cdecl sub_1003DAA3(); // idb
void __cdecl sub_1003DAAD(); // idb
void __cdecl sub_1003DAB7(); // idb
void __cdecl sub_1003DAC1(); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1003C42D; // weak
_UNKNOWN loc_1003C70D; // weak
_UNKNOWN loc_1003C73D; // weak
_UNKNOWN loc_1003D62B; // weak
// extern int (__stdcall *GetDeviceCaps)(HDC hdc, int index);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *CreateDirectoryA)(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern DWORD (__stdcall *GetCurrentDirectoryA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *AllocConsole)();
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern IDirect3D9 *(__stdcall *Direct3DCreate9)(UINT SDKVersion);
void *std::exception::`vftable' = &sub_100011D0; // weak
void *std::bad_alloc::`vftable' = &sub_100011D0; // weak
void *std::logic_error::`vftable' = &unknown_libname_2; // weak
void *std::length_error::`vftable' = &unknown_libname_2; // weak
void *std::out_of_range::`vftable' = &unknown_libname_2; // weak
void *std::runtime_error::`vftable' = &sub_100011D0; // weak
void *std::_Facet_base::`vftable' = &sub_100028C0; // weak
_UNKNOWN unk_1003F338; // weak
char *const off_1003F348 = "r"; // idb
void *std::bad_array_new_length::`vftable' = &sub_100011D0; // weak
void *std::bad_cast::`vftable' = &sub_100011D0; // weak
void *std::ctype<char>::`vftable' = &sub_10002D20; // weak
void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_10005310; // weak
void *std::numpunct<char>::`vftable' = &sub_10005EE0; // weak
void *std::codecvt<char,char,_Mbstatet>::`vftable' = &sub_10005310; // weak
void *std::_System_error::`vftable' = &sub_100015E0; // weak
void *std::system_error::`vftable' = &sub_100015E0; // weak
void *std::ios_base::failure::`vftable' = &sub_100015E0; // weak
void *std::collate<char>::`vftable' = &sub_100138B0; // weak
void *type_info::`vftable' = &sub_1001D48F; // weak
void *std::bad_exception::`vftable' = &unknown_libname_2; // weak
const unsigned __int16 _wctype[] = { 0u, 32u };
_UNKNOWN unk_100422DC; // weak
_UNKNOWN unk_1004230C; // weak
_UNKNOWN unk_10042324; // weak
_UNKNOWN unk_10042350; // weak
_UNKNOWN unk_1004236C; // weak
_UNKNOWN unk_10042384; // weak
_UNKNOWN unk_100423A0; // weak
_UNKNOWN unk_100423F8; // weak
_UNKNOWN unk_10042400; // weak
_UNKNOWN unk_1004A353; // weak
_UNKNOWN unk_1004A49C; // weak
void *std::streambuf::`vftable' = &sub_100045C0; // weak
void *std::ios_base::`vftable' = &sub_10002DA0; // weak
void *std::filebuf::`vftable' = &sub_10004590; // weak
void *std::ofstream::`vftable' = &sub_100074FD; // weak
_UNKNOWN unk_1004A90C; // weak
void *std::ostream::`vftable' = &sub_100074F5; // weak
_UNKNOWN unk_1004A958; // weak
void *Direct3D8::`vftable' = &sub_10007510; // weak
_UNKNOWN unk_1004A9AC; // weak
void *std::_Node_capture::`vftable' = &sub_10008640; // weak
void *std::_Node_base::`vftable' = &sub_100085E0; // weak
void *std::_Node_str<char>::`vftable' = &sub_10019360; // weak
void *Direct3DDevice8::`vftable' = &sub_10008850; // weak
_UNKNOWN unk_1004AB74; // weak
char *off_1004AB88 = "alnum"; // weak
int dword_1004AB90[] = { 5 }; // weak
__int16 word_1004AB94[] = { 263 }; // weak
_UNKNOWN unk_1004AC88; // weak
char byte_1004AC98[] = { '\0' }; // weak
char byte_1004AC99[35] =
{
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x04',
  '\0',
  '\n',
  '\0',
  '\n',
  '\x01',
  '\x05',
  '\0',
  '\x05',
  '\x01',
  '\x05',
  '\x02',
  '\x05',
  '\x03',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x06',
  '\x05',
  '\a',
  '\0',
  '\x01',
  '\x03',
  '\x01',
  '\0',
  '\0'
}; // weak
void *std::_Node_end_rep::`vftable' = &sub_10008640; // weak
void *std::_Node_assert::`vftable' = &sub_10008670; // weak
void *std::_Node_rep::`vftable' = &sub_10008740; // weak
void *std::_Node_endif::`vftable' = &sub_100085E0; // weak
void *std::_Node_back::`vftable' = &sub_10008640; // weak
char byte_1004C0AC[] = { '\0' }; // weak
char byte_1004C0AD[35] =
{
  '\x04',
  '\x01',
  '\b',
  '\x02',
  '\f',
  '\x03',
  '\x10',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x06',
  '\x04',
  '\a',
  '\b',
  '\b',
  '\x04',
  '\t',
  '\x04',
  '\n',
  '\b',
  '\v',
  '\x04',
  '\f',
  '\b',
  '\r',
  '\x06',
  '\x0E',
  '\x06',
  '\x0F',
  '\b',
  '\x10',
  '\x10',
  '\0',
  '\0'
}; // weak
void *std::_Node_class<char,std::regex_traits<char>>::`vftable' = &sub_10015330; // weak
void *std::_Node_if::`vftable' = &sub_100086C0; // weak
_UNKNOWN unk_1004C0E0; // weak
_UNKNOWN unk_1004C0F0; // weak
char byte_1004C100[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
void *std::_Node_end_group::`vftable' = &sub_10008640; // weak
void *std::_Root_node::`vftable' = &sub_10008610; // weak
void *Direct3DIndexBuffer8::`vftable' = &sub_1001AA1F; // weak
_UNKNOWN unk_1004C218; // weak
_UNKNOWN unk_1004C228; // weak
void *AddressLookupTableObject::`vftable' = &sub_1001A2A0; // weak
void *Direct3DIndexBuffer8::`vftable' = &sub_1001A300; // weak
_UNKNOWN unk_1004C27C; // weak
void *Direct3DSurface8::`vftable' = &sub_1001ABB2; // weak
void *Direct3DSurface8::`vftable' = &sub_1001AA60; // weak
void *Direct3DSwapChain8::`vftable' = &sub_1001ADE0; // weak
void *Direct3DSwapChain8::`vftable' = &sub_1001ABF0; // weak
_UNKNOWN unk_1004C2E4; // weak
_UNKNOWN unk_1004C2F4; // weak
void *Direct3DVolumeTexture8::`vftable' = &sub_1001B711; // weak
void *Direct3DCubeTexture8::`vftable' = &sub_1001B709; // weak
void *Direct3DTexture8::`vftable' = &sub_1001B719; // weak
_UNKNOWN unk_1004C31C; // weak
void *Direct3DTexture8::`vftable' = &sub_1001AE20; // weak
_UNKNOWN unk_1004C37C; // weak
void *Direct3DVolumeTexture8::`vftable' = &sub_1001B430; // weak
_UNKNOWN unk_1004C3DC; // weak
void *Direct3DCubeTexture8::`vftable' = &sub_1001B1B0; // weak
void *Direct3DVertexBuffer8::`vftable' = &sub_1001B760; // weak
void *Direct3DVertexBuffer8::`vftable' = &sub_1001B892; // weak
_UNKNOWN unk_1004C480; // weak
void *Direct3DVolume8::`vftable' = &sub_1001B9F2; // weak
void *Direct3DVolume8::`vftable' = &sub_1001B8D0; // weak
_UNKNOWN unk_1004C4C8; // weak
_UNKNOWN unk_1004C4D8; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVlength_error_std__ }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVout_of_range_std__ }; // idb
const _ThrowInfo _TI2_AVruntime_error_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVruntime_error_std__ }; // idb
const _ThrowInfo _TI5_AVfailure_ios_base_std__ = { 0u, &unknown_libname_1, NULL, &_CTA5_AVfailure_ios_base_std__ }; // idb
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &unknown_libname_1, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
const _ThrowInfo _TI2_AVbad_cast_std__ = { 0u, &unknown_libname_1, NULL, &_CTA2_AVbad_cast_std__ }; // idb
int dword_10051000 = -1; // weak
int dword_10051008[20] =
{
  1,
  2,
  18,
  10,
  33,
  34,
  50,
  42,
  3,
  19,
  11,
  35,
  51,
  43,
  130,
  146,
  147,
  162,
  178,
  179
}; // weak
wchar_t *off_10051210 = L"         (((((                  H"; // weak
int dword_100513DC = -2; // weak
HANDLE hConsoleOutput = (HANDLE)0xFFFFFFFE; // idb
char byte_10051AC8 = '\x01'; // weak
int dword_10051ACC = 30; // weak
_UNKNOWN unk_10052348; // weak
struct _RTL_CRITICAL_SECTION stru_10052350 = { NULL, 0, 0, NULL, NULL, 0u }; // idb
int dword_10052410; // weak
int dword_10052414; // weak
int dword_10052428; // idb
_DWORD dword_1005242C; // weak
int dword_10052430; // weak
_UNKNOWN unk_10052438; // weak
int dword_1005243C; // weak
_UNKNOWN unk_100524AC; // weak
_UNKNOWN unk_100524AD; // weak
int dword_100525A8; // weak
int dword_100525B0; // weak
union _SLIST_HEADER ListHead; // idb
_UNKNOWN unk_100525C0; // weak
int dword_10052910; // weak
int dword_10052998; // weak
int dword_100529B0; // weak
int dword_100529B4; // weak
int dword_10052B14; // weak
void *dword_10052C28; // idb
void *dword_10052C2C; // idb
_onexit_table_t stru_10052C30; // idb
LPCRITICAL_SECTION lpCriticalSection[128]; // weak
int dword_10052F30; // weak
int dword_10052F48; // weak
struct __crt_locale_data *dword_10052F4C; // idb
int dword_10052F50; // weak
struct __crt_multibyte_data *dword_1005303C; // idb
HANDLE hHeap; // idb
int dword_10053064; // weak
int dword_10053068; // weak
int dword_10053084; // weak
_UNKNOWN unk_10053098; // weak
int dword_10053100; // weak
int dword_10053110; // weak
int (__stdcall *dword_10053120)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10053124)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_10053128; // weak
__int64 qword_10053130; // weak
void *dword_10053138; // idb
int dword_1005313C; // weak
int dword_10053140; // weak
int dword_10053144; // weak
int dword_10053148; // weak
int dword_1005314C; // weak
int dword_10053150; // weak
int dword_10053154; // weak
int dword_10053158; // weak
int dword_1005315C; // weak
int dword_10053160; // weak
int dword_10053164; // weak
int dword_10053168; // weak
int dword_1005316C; // weak
int dword_10053170; // weak
int dword_10053174; // weak
int dword_10053178; // weak
int dword_1005317C; // weak
int dword_10053180; // weak
int dword_10053184; // weak
char byte_10053189; // weak
int dword_1005318C; // weak
int dword_10053190; // weak
char byte_10053194; // weak
int dword_10053198; // weak
int dword_100531AC; // weak
_UNKNOWN dword_100531B0; // weak
int dword_100531B8; // weak
int dword_100531BC; // weak
int dword_100531C0; // weak
int dword_100531C4; // weak
int dword_100531C8; // weak
int dword_100531CC; // weak
int dword_100531D0; // weak
int dword_100531D4; // weak
int dword_100531D8; // weak
int dword_100531DC; // weak
int dword_100531E0; // weak
int dword_100531E8; // weak
int dword_100531EC; // weak
char byte_100531F0; // weak
int dword_10053204; // weak
int dword_10053208; // weak
int dword_1005320C; // weak
int dword_10053210; // weak
int dword_10053214; // weak
int dword_10053218; // weak
int dword_1005321C; // weak
int dword_10053220; // idb
int dword_10053224; // idb
int dword_10053228; // idb
int dword_1005322C; // idb
_UNKNOWN unk_10053230; // weak


//----- (10001000) --------------------------------------------------------
int sub_10001000()
{
  return atexit(sub_1003D970);
}

//----- (10001010) --------------------------------------------------------
int __thiscall sub_10001010(void *this)
{
  sub_10004040((int)this);
  return atexit(sub_1003DA00);
}

//----- (10001022) --------------------------------------------------------
int sub_10001022()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_10052348);
  return atexit(sub_1003DA99);
}

//----- (10001038) --------------------------------------------------------
int sub_10001038()
{
  return atexit(sub_1003DAAD);
}

//----- (10001044) --------------------------------------------------------
int sub_10001044()
{
  return atexit(sub_1003DAA3);
}

//----- (10001050) --------------------------------------------------------
int sub_10001050()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_100524AC);
  return atexit(sub_1003DAC1);
}

//----- (10001066) --------------------------------------------------------
int sub_10001066()
{
  return atexit(sub_1003DAB7);
}

//----- (10001080) --------------------------------------------------------
void *sub_10001080()
{
  return &unk_10053098;
}

//----- (10001090) --------------------------------------------------------
int __cdecl sub_10001090(int a1, int a2, struct __crt_locale_pointers *a3, int a4)
{
  int *v4; // eax

  v4 = (int *)sub_10001080();
  return sub_10024EB6(*v4, v4[1], a1, a2, a3, a4);
}

//----- (100010C0) --------------------------------------------------------
int sub_100010C0(int a1, ...)
{
  FILE *v1; // eax
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, a1);
  v1 = __acrt_iob_func(1u);
  return sub_10001090((int)v1, a1, 0, (int)va);
}

//----- (100010F0) --------------------------------------------------------
int __cdecl sub_100010F0(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList)
{
  _DWORD *v5; // eax
  int result; // eax
  unsigned __int64 v7; // [esp-1Ch] [ebp-1Ch]

  v5 = sub_10001080();
  HIDWORD(v7) = v5[1];
  LODWORD(v7) = *v5 | 1;
  result = __stdio_common_vsprintf(v7, Buffer, BufferCount, Format, Locale, ArgList);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (10001130) --------------------------------------------------------
int sub_10001130(char *Buffer, char *Format, ...)
{
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, Format);
  return sub_100010F0(Buffer, 0xFFFFFFFF, Format, 0, va);
}

//----- (10001150) --------------------------------------------------------
_DWORD *__thiscall sub_10001150(_DWORD *this, int a2)
{
  int v4; // [esp+4h] [ebp-8h] BYREF
  char v5; // [esp+8h] [ebp-4h]

  v5 = 1;
  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  v4 = a2;
  __std_exception_copy(&v4, this + 1);
  return this;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';

//----- (10001190) --------------------------------------------------------
_DWORD *__thiscall sub_10001190(_DWORD *this, int a2)
{
  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  return this;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';

//----- (100011D0) --------------------------------------------------------
char *__thiscall sub_100011D0(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1001E574: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';

//----- (10001220) --------------------------------------------------------
_DWORD *__thiscall sub_10001220(_DWORD *this)
{
  _DWORD *result; // eax

  this[2] = 0;
  result = this;
  this[1] = "bad array new length";
  *this = &std::bad_array_new_length::`vftable';
  return result;
}
// 1003F4DC: using guessed type void *std::bad_array_new_length::`vftable';

//----- (10001240) --------------------------------------------------------
void __noreturn sub_10001240()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_10001220(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 10001240: using guessed type void __noreturn sub_10001240();
// 10001240: using guessed type _DWORD pExceptionObject[3];

//----- (10001260) --------------------------------------------------------
_DWORD *__thiscall sub_10001260(_DWORD *this, int a2)
{
  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  *this = &std::bad_array_new_length::`vftable';
  return this;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003F4DC: using guessed type void *std::bad_array_new_length::`vftable';

//----- (100012A0) --------------------------------------------------------
_DWORD *__thiscall sub_100012A0(_DWORD *this, int a2)
{
  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  *this = &std::bad_alloc::`vftable';
  return this;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003E230: using guessed type void *std::bad_alloc::`vftable';

//----- (100012E0) --------------------------------------------------------
void __noreturn sub_100012E0()
{
  sub_1001C00E((int)"string too long");
}
// 100012E0: using guessed type void __noreturn sub_100012E0();

//----- (100012F0) --------------------------------------------------------
_DWORD *__thiscall sub_100012F0(_DWORD *this, int a2)
{
  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  *this = &std::runtime_error::`vftable';
  return this;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003E270: using guessed type void *std::runtime_error::`vftable';

//----- (10001350) --------------------------------------------------------
bool __thiscall sub_10001350(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char v5[8]; // [esp+4h] [ebp-8h] BYREF

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);
  return *(_DWORD *)(v3[1] + 4) == *(_DWORD *)(a3[1] + 4) && *v3 == *a3;
}
// 10001350: using guessed type char var_8[8];

//----- (10001390) --------------------------------------------------------
bool __thiscall sub_10001390(_DWORD *this, _DWORD *a2, int a3)
{
  return this[1] == *(_DWORD *)(a2[1] + 4) && *a2 == a3;
}

//----- (100013E0) --------------------------------------------------------
_DWORD *__thiscall sub_100013E0(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  char *v5; // ecx
  void **v6; // eax
  int *v7; // ecx
  size_t v8; // edi
  char *v9; // ebx
  void **v10; // eax
  void *v11; // edx
  void **v12; // ecx
  void **v13; // edx
  unsigned int v14; // ecx
  void *v15; // edx
  _DWORD *result; // eax
  int Src[4]; // [esp+Ch] [ebp-60h] BYREF
  size_t Size; // [esp+1Ch] [ebp-50h]
  unsigned int v19; // [esp+20h] [ebp-4Ch]
  void *Block[5]; // [esp+24h] [ebp-48h] BYREF
  unsigned int v21; // [esp+38h] [ebp-34h]
  void *v22[4]; // [esp+3Ch] [ebp-30h] BYREF
  char *v23; // [esp+4Ch] [ebp-20h]
  unsigned int v24; // [esp+50h] [ebp-1Ch]
  void **v25; // [esp+54h] [ebp-18h] BYREF
  int v26; // [esp+58h] [ebp-14h]
  _DWORD *v27; // [esp+5Ch] [ebp-10h]
  int v28; // [esp+68h] [ebp-4h]
  void **v29; // [esp+7Ch] [ebp+10h]

  v27 = this;
  sub_10001AF0(v22, a4);
  v26 = a3;
  v28 = 0;
  v5 = v23;
  if ( v23 )
  {
    if ( v24 - (unsigned int)v23 < 2 )
    {
      LOBYTE(a4) = 0;
      sub_10001D90(v22, 2u, (int)a4, ": ", 2u);
    }
    else
    {
      v23 += 2;
      v6 = v22;
      if ( v24 >= 0x10 )
        v6 = (void **)v22[0];
      strcpy(&v5[(_DWORD)v6], ": ");
    }
  }
  (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)a3 + 8))(a3, Src, a2);
  LOBYTE(v28) = 1;
  v7 = Src;
  v8 = Size;
  if ( v19 >= 0x10 )
    v7 = (int *)Src[0];
  v9 = v23;
  if ( Size > v24 - (unsigned int)v23 )
  {
    LOBYTE(a4) = 0;
    sub_10001D90(v22, Size, (int)a4, v7, Size);
  }
  else
  {
    v23 += Size;
    v10 = v22;
    v29 = v22;
    if ( v24 >= 0x10 )
    {
      v10 = (void **)v22[0];
      v29 = (void **)v22[0];
    }
    memmove((char *)v10 + (_DWORD)v9, v7, Size);
    v9[(_DWORD)v29 + v8] = 0;
  }
  if ( v19 >= 0x10 )
  {
    v11 = (void *)Src[0];
    if ( v19 + 1 >= 0x1000 )
    {
      v11 = *(void **)(Src[0] - 4);
      if ( (unsigned int)(Src[0] - (_DWORD)v11 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v11);
  }
  v12 = Block;
  v13 = (void **)v22[0];
  Block[1] = v22[1];
  Block[2] = v22[2];
  Block[3] = v22[3];
  Block[4] = v23;
  Block[0] = v22[0];
  v21 = v24;
  v23 = 0;
  v24 = 15;
  LOBYTE(v22[0]) = 0;
  if ( v21 >= 0x10 )
    v12 = v13;
  *this = &std::exception::`vftable';
  v25 = v12;
  this[1] = 0;
  this[2] = 0;
  LOBYTE(v26) = 1;
  __std_exception_copy(&v25, this + 1);
  v14 = v21;
  *this = &std::runtime_error::`vftable';
  if ( v14 >= 0x10 )
  {
    v15 = Block[0];
    if ( v14 + 1 >= 0x1000 )
    {
      v15 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v15 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v15);
  }
  this[3] = a2;
  result = this;
  this[4] = a3;
  *this = &std::_System_error::`vftable';
  return result;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003E270: using guessed type void *std::runtime_error::`vftable';
// 1003F604: using guessed type void *std::_System_error::`vftable';

//----- (100015E0) --------------------------------------------------------
char *__thiscall sub_100015E0(char *Block, char a2)
{
  *(_DWORD *)Block = &std::exception::`vftable';
  __std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1001E574: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';

//----- (10001610) --------------------------------------------------------
_DWORD *__thiscall sub_10001610(_DWORD *this, int a2)
{
  int v3; // ecx
  _DWORD *result; // eax

  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  *this = &std::_System_error::`vftable';
  v3 = *(_DWORD *)(a2 + 16);
  this[3] = *(_DWORD *)(a2 + 12);
  result = this;
  this[4] = v3;
  *this = &std::system_error::`vftable';
  return result;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003F604: using guessed type void *std::_System_error::`vftable';
// 1003F610: using guessed type void *std::system_error::`vftable';

//----- (10001660) --------------------------------------------------------
_DWORD *__thiscall sub_10001660(_DWORD *this, int a2)
{
  int v3; // ecx
  _DWORD *result; // eax

  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  *this = &std::_System_error::`vftable';
  v3 = *(_DWORD *)(a2 + 16);
  this[3] = *(_DWORD *)(a2 + 12);
  result = this;
  this[4] = v3;
  return result;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003F604: using guessed type void *std::_System_error::`vftable';

//----- (100016B0) --------------------------------------------------------
const char *sub_100016B0()
{
  return "iostream";
}

//----- (100016C0) --------------------------------------------------------
_DWORD *__stdcall sub_100016C0(_DWORD *a1, int a2)
{
  char *v3; // edx

  if ( a2 == 1 )
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 0;
    a1[4] = 0;
    a1[5] = 0;
    sub_10001C50(a1, "iostream stream error", 0x15u);
  }
  else
  {
    v3 = (char *)std::_Syserror_map(a2);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 0;
    a1[4] = 0;
    a1[5] = 0;
    sub_10001C50(a1, v3, strlen(v3));
  }
  return a1;
}

//----- (10001780) --------------------------------------------------------
void *__thiscall sub_10001780(void *Block, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}

//----- (100017A0) --------------------------------------------------------
_DWORD *__thiscall sub_100017A0(_DWORD *this, void *Src, int *a3)
{
  int v3; // edi
  int v5; // ebx
  void *v6; // edx
  _DWORD *result; // eax
  void *Block[5]; // [esp+Ch] [ebp-28h] BYREF
  unsigned int v9; // [esp+20h] [ebp-14h]
  _DWORD *v10; // [esp+24h] [ebp-10h]
  int v11; // [esp+30h] [ebp-4h]

  v3 = *a3;
  v5 = a3[1];
  v10 = this;
  memset(Block, 0, sizeof(Block));
  v9 = 0;
  v11 = 0;
  sub_10001C50(Block, Src, strlen((const char *)Src));
  v11 = 1;
  sub_100013E0(this, v3, v5, Block);
  if ( v9 >= 0x10 )
  {
    v6 = Block[0];
    if ( v9 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v6);
  }
  result = this;
  *this = &std::ios_base::failure::`vftable';
  return result;
}
// 1003F638: using guessed type void *std::ios_base::failure::`vftable';

//----- (10001870) --------------------------------------------------------
int __thiscall sub_10001870(_DWORD *this, char a2, char a3)
{
  int result; // eax
  int v4; // ecx
  char *v5; // esi
  int *error_code; // eax
  char v7[8]; // [esp+4h] [ebp-1Ch] BYREF
  _DWORD pExceptionObject[5]; // [esp+Ch] [ebp-14h] BYREF

  result = a2 & 0x17;
  this[3] = result;
  v4 = result & this[4];
  if ( v4 )
  {
    if ( a3 )
      _CxxThrowException(0, 0);
    if ( (v4 & 4) != 0 )
    {
      v5 = "ios_base::badbit set";
    }
    else
    {
      v5 = "ios_base::failbit set";
      if ( (v4 & 2) == 0 )
        v5 = "ios_base::eofbit set";
    }
    error_code = (int *)std::make_error_code(v7, 1);
    sub_100017A0(pExceptionObject, v5, error_code);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  return result;
}
// 100013C0: using guessed type int __cdecl std::make_error_code(_DWORD, _DWORD);
// 10001870: using guessed type char var_1C[8];
// 10001870: using guessed type _DWORD pExceptionObject[5];

//----- (100018F0) --------------------------------------------------------
_DWORD *__thiscall sub_100018F0(_DWORD *this, int a2)
{
  int v3; // ecx
  _DWORD *result; // eax

  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  *this = &std::_System_error::`vftable';
  v3 = *(_DWORD *)(a2 + 16);
  this[3] = *(_DWORD *)(a2 + 12);
  result = this;
  this[4] = v3;
  *this = &std::ios_base::failure::`vftable';
  return result;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003F604: using guessed type void *std::_System_error::`vftable';
// 1003F638: using guessed type void *std::ios_base::failure::`vftable';

//----- (10001940) --------------------------------------------------------
_DWORD *__thiscall sub_10001940(_DWORD *this)
{
  if ( this[5] < 0x10u )
    return this;
  else
    return (_DWORD *)*this;
}

//----- (10001950) --------------------------------------------------------
void **__thiscall sub_10001950(void **Src, void **Srca)
{
  void *v3; // ecx
  unsigned int v4; // edi
  unsigned int v5; // edx
  _BYTE *v6; // ebx
  void *v7; // eax
  void **result; // eax
  size_t v9; // [esp-4h] [ebp-10h]
  void *Srcb; // [esp+14h] [ebp+8h]

  v3 = Srca;
  v4 = (unsigned int)Srca[4];
  if ( (unsigned int)Srca[5] >= 0x10 )
    v3 = *Srca;
  v5 = (unsigned int)Src[5];
  v6 = Src[4];
  if ( v4 > v5 - (unsigned int)v6 )
  {
    v9 = (size_t)Srca[4];
    LOBYTE(Srca) = 0;
    return sub_10001D90(Src, v4, (int)Srca, v3, v9);
  }
  else
  {
    Srcb = Src;
    Src[4] = &v6[v4];
    v7 = Src;
    if ( v5 >= 0x10 )
    {
      v7 = *Src;
      Srcb = *Src;
    }
    memmove(&v6[(_DWORD)v7], v3, v4);
    result = Src;
    v6[(_DWORD)Srcb + v4] = 0;
  }
  return result;
}

//----- (100019D0) --------------------------------------------------------
void __thiscall sub_100019D0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  v2 = this[5];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)*this;
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_1001D481(v3);
  }
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (10001A20) --------------------------------------------------------
_DWORD *__thiscall sub_10001A20(_DWORD *this, void *Src)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  sub_10001C50(this, Src, strlen((const char *)Src));
  return this;
}

//----- (10001A90) --------------------------------------------------------
_DWORD *__thiscall sub_10001A90(_DWORD *this, void *Src, size_t Size)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  sub_10001C50(this, Src, Size);
  return this;
}

//----- (10001AF0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__thiscall sub_10001AF0(_DWORD *this, _DWORD *Src)
{
  _DWORD *v3; // ebx
  bool v4; // cf
  unsigned int v5; // eax
  unsigned int v7; // edi
  size_t v8; // eax
  void *v9; // eax
  _DWORD *v10; // ecx
  void *Srca; // [esp+20h] [ebp+8h]

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  v3 = Src;
  v4 = Src[5] < 0x10u;
  v5 = Src[4];
  Srca = (void *)v5;
  if ( !v4 )
    v3 = (_DWORD *)*v3;
  if ( v5 > 0x7FFFFFFF )
    sub_100012E0();
  this[5] = 15;
  if ( v5 < 0x10 )
  {
    this[4] = v5;
    *this = *v3;
    this[1] = v3[1];
    this[2] = v3[2];
    this[3] = v3[3];
    return this;
  }
  v7 = v5 | 0xF;
  if ( (v5 | 0xF) > 0x7FFFFFFF )
  {
    v7 = 0x7FFFFFFF;
    v8 = -2147483613;
LABEL_8:
    v9 = operator new(v8);
    if ( !v9 )
      _invalid_parameter_noinfo_noreturn();
    v10 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
    *(v10 - 1) = v9;
    v5 = (unsigned int)Srca;
    goto LABEL_18;
  }
  if ( v7 < 0x16 )
    v7 = 22;
  if ( v7 + 1 >= 0x1000 )
  {
    v8 = v7 + 36;
    if ( v7 + 36 <= v7 + 1 )
      sub_10001240();
    goto LABEL_8;
  }
  if ( v7 == -1 )
  {
    v10 = 0;
  }
  else
  {
    v10 = operator new(v7 + 1);
    v5 = (unsigned int)Srca;
  }
LABEL_18:
  this[4] = v5;
  *this = v10;
  this[5] = v7;
  memmove(v10, v3, v5 + 1);
  return this;
}
// 10001C0E: bad sp value at call
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10001C30) --------------------------------------------------------
_BYTE *__fastcall sub_10001C30(_BYTE *a1, _DWORD *a2)
{
  unsigned int v2; // eax

  v2 = a2[4];
  if ( a2[5] >= 0x10u )
    a2 = (_DWORD *)*a2;
  return sub_10001EF0(a1, (int)a2, v2);
}

//----- (10001C50) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
void *__thiscall sub_10001C50(_DWORD *this, void *Src, size_t Size)
{
  void *result; // eax
  size_t v6; // esi
  size_t v7; // ecx
  void *v8; // eax
  void *v9; // ecx
  _DWORD *v10; // eax
  void *Sizea; // [esp+14h] [ebp+Ch]

  if ( Size > 0x7FFFFFFF )
    sub_100012E0();
  this[5] = 15;
  if ( Size < 0x10 )
  {
    this[4] = Size;
    result = memmove(this, Src, Size);
    *((_BYTE *)this + Size) = 0;
    return result;
  }
  v6 = Size | 0xF;
  if ( (Size | 0xF) > 0x7FFFFFFF )
  {
    v6 = 0x7FFFFFFF;
    v7 = -2147483613;
LABEL_6:
    v8 = operator new(v7);
    v9 = v8;
    if ( !v8 )
      _invalid_parameter_noinfo_noreturn();
    v10 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
    *(v10 - 1) = v9;
    goto LABEL_16;
  }
  if ( v6 < 0x16 )
    v6 = 22;
  if ( v6 + 1 >= 0x1000 )
  {
    v7 = v6 + 36;
    if ( v6 + 36 <= v6 + 1 )
      sub_10001240();
    goto LABEL_6;
  }
  if ( v6 == -1 )
    v10 = 0;
  else
    v10 = operator new(v6 + 1);
LABEL_16:
  Sizea = v10;
  *this = v10;
  this[4] = Size;
  this[5] = v6;
  memmove(v10, Src, Size);
  result = Sizea;
  *((_BYTE *)Sizea + Size) = 0;
  return result;
}
// 10001D15: bad sp value at call
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10001D30) --------------------------------------------------------
void __fastcall sub_10001D30(int a1, int a2)
{
  int i; // esi
  unsigned int v4; // ecx
  _DWORD *v5; // eax

  for ( i = a1; i != a2; i += 24 )
  {
    v4 = *(_DWORD *)(i + 20);
    if ( v4 >= 0x10 )
    {
      v5 = *(_DWORD **)i;
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v5 = (_DWORD *)*(v5 - 1);
      }
      sub_1001D481(v5);
    }
    *(_DWORD *)(i + 16) = 0;
    *(_DWORD *)(i + 20) = 15;
    *(_BYTE *)i = 0;
  }
}

//----- (10001D90) --------------------------------------------------------
void **__thiscall sub_10001D90(void **Src, unsigned int a2, int a3, void *Srca, size_t a5)
{
  size_t v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // esi
  size_t v9; // ecx
  void *v10; // eax
  _DWORD *v11; // edi
  char *v12; // esi
  void *v13; // esi
  void **result; // eax
  size_t v15; // [esp-4h] [ebp-18h]
  size_t Size; // [esp+Ch] [ebp-8h]
  void *Sizea; // [esp+Ch] [ebp-8h]
  size_t v18; // [esp+10h] [ebp-4h]
  char *v19; // [esp+10h] [ebp-4h]
  unsigned int v20; // [esp+1Ch] [ebp+8h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_100012E0();
  v7 = (unsigned int)Src[5];
  v18 = v6 + a2;
  v20 = v7;
  if ( (v18 | 0xF) > 0x7FFFFFFF )
  {
    v8 = 0x7FFFFFFF;
LABEL_4:
    v9 = -2147483613;
    goto LABEL_5;
  }
  if ( v7 > 0x7FFFFFFF - (v7 >> 1) )
  {
    v8 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  v8 = (v7 >> 1) + v7;
  if ( (v18 | 0xF) >= v8 )
    v8 = v18 | 0xF;
  if ( v8 + 1 < 0x1000 )
  {
    if ( v8 == -1 )
      v11 = 0;
    else
      v11 = operator new(v8 + 1);
    goto LABEL_17;
  }
  v9 = v8 + 36;
  if ( v8 + 36 <= v8 + 1 )
    sub_10001240();
LABEL_5:
  v10 = operator new(v9);
  if ( !v10 )
    goto LABEL_25;
  v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
  *(v11 - 1) = v10;
LABEL_17:
  Src[4] = (void *)v18;
  Src[5] = (void *)v8;
  v15 = Size;
  v12 = (char *)v11 + Size;
  Sizea = v12;
  v19 = &v12[a5];
  if ( v20 >= 0x10 )
  {
    v13 = *Src;
    memmove(v11, *Src, v15);
    memmove(Sizea, Srca, a5);
    *v19 = 0;
    if ( v20 + 1 < 0x1000 )
    {
LABEL_21:
      sub_1001D481(v13);
      *Src = v11;
      return Src;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v11, Src, v15);
  memmove(v12, Srca, a5);
  *v19 = 0;
  result = Src;
  *Src = v11;
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10001EF0) --------------------------------------------------------
_BYTE *__fastcall sub_10001EF0(_BYTE *a1, int a2, unsigned int a3)
{
  char v4; // di
  int v5; // eax
  int v6; // eax
  unsigned int v7; // esi
  int v8; // esi
  int v9; // ecx
  int v10; // ecx
  _BYTE *v11; // eax
  bool v12; // al
  _BYTE *v13; // eax
  int v14; // eax
  _DWORD *v15; // ecx
  int *v16; // eax
  _DWORD *v17; // ecx
  unsigned __int8 *v18; // edx
  int v19; // eax
  int v20; // edx
  int v21; // eax
  _DWORD *v22; // ecx
  int *v23; // eax
  _DWORD *v24; // ecx
  unsigned __int8 *v25; // edx
  int v26; // eax
  int v27; // eax
  char v28; // al
  _BYTE *v29; // esi
  int v30; // ecx
  _DWORD v32[3]; // [esp+0h] [ebp-38h] BYREF
  _BYTE *v33; // [esp+Ch] [ebp-2Ch]
  bool v34; // [esp+10h] [ebp-28h]
  int v35; // [esp+14h] [ebp-24h]
  int v36; // [esp+18h] [ebp-20h]
  int v37; // [esp+1Ch] [ebp-1Ch]
  _BYTE *v38; // [esp+20h] [ebp-18h]
  unsigned __int8 v39; // [esp+27h] [ebp-11h]
  _DWORD *v40; // [esp+28h] [ebp-10h]
  int v41; // [esp+34h] [ebp-4h]

  v35 = a2;
  v4 = 0;
  v40 = v32;
  v5 = *(_DWORD *)a1;
  v38 = a1;
  v37 = 0;
  v6 = *(_DWORD *)(v5 + 4);
  v7 = *(_DWORD *)&a1[v6 + 32];
  if ( *(__int64 *)&a1[v6 + 32] <= 0 || v7 <= a3 )
    v8 = 0;
  else
    v8 = v7 - a3;
  v9 = *(_DWORD *)&a1[v6 + 56];
  v33 = a1;
  if ( v9 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 4))(v9);
  v41 = 0;
  v10 = *(_DWORD *)a1;
  v11 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  if ( *((_DWORD *)v11 + 3) )
  {
    v12 = 0;
  }
  else
  {
    v13 = (_BYTE *)*((_DWORD *)v11 + 15);
    if ( !v13 || v13 == a1 )
    {
      v12 = 1;
    }
    else
    {
      sub_10002290(v13);
      v10 = *(_DWORD *)a1;
      v12 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] == 0;
    }
  }
  v34 = v12;
  v41 = 1;
  if ( v12 )
  {
    LOBYTE(v41) = 2;
    if ( (*(_DWORD *)&a1[*(_DWORD *)(v10 + 4) + 20] & 0x1C0) != 64 )
    {
      while ( v8 )
      {
        v14 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v15 = *(_DWORD **)&a1[v14 + 56];
        v39 = a1[v14 + 64];
        if ( *(_DWORD *)v15[8] && (v16 = (int *)v15[12], v36 = v39, *v16 > 0) )
        {
          --*v16;
          v17 = (_DWORD *)v15[8];
          v18 = (unsigned __int8 *)(*v17)++;
          *v18 = v39;
          v19 = v36;
        }
        else
        {
          v19 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v15 + 12))(v15, v39);
        }
        if ( v19 == -1 )
        {
          v4 = 4;
          v37 = 4;
          goto LABEL_26;
        }
        --v8;
      }
    }
    if ( sub_10002140(*(void **)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56], v35, a3, 0) != a3 || v20 )
    {
LABEL_33:
      v4 |= 4u;
    }
    else
    {
LABEL_26:
      while ( v8 )
      {
        v21 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v22 = *(_DWORD **)&a1[v21 + 56];
        v39 = a1[v21 + 64];
        if ( *(_DWORD *)v22[8] && (v23 = (int *)v22[12], v35 = v39, *v23 > 0) )
        {
          --*v23;
          v24 = (_DWORD *)v22[8];
          v25 = (unsigned __int8 *)(*v24)++;
          *v25 = v39;
          v26 = v35;
        }
        else
        {
          v26 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v22 + 12))(v22, v39);
        }
        if ( v26 == -1 )
          goto LABEL_33;
        --v8;
      }
    }
    v27 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    *(_DWORD *)&a1[v27 + 32] = 0;
    *(_DWORD *)&a1[v27 + 36] = 0;
    v41 = 1;
  }
  else
  {
    v4 = 4;
  }
  sub_10001870(
    &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)],
    v4 | a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] | (*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56] != 0 ? 0 : 4),
    0);
  v28 = j____uncaught_exception(v32[0], v32[1], v32[2]);
  v29 = v33;
  if ( !v28 )
    sub_100023A0(v33);
  v41 = 4;
  v30 = *(_DWORD *)&v29[*(_DWORD *)(*(_DWORD *)v29 + 4) + 56];
  if ( v30 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v30 + 8))(v30);
  return a1;
}
// 1000202D: variable 'v20' is possibly undefined
// 1001BDB7: using guessed type int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD);

//----- (10002140) --------------------------------------------------------
int __thiscall sub_10002140(void *this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 36))(this, a2, a3, a4);
}

//----- (10002160) --------------------------------------------------------
int __thiscall sub_10002160(_BYTE **this)
{
  int result; // eax
  int v3; // ecx

  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_100023A0(*this);
  result = *(_DWORD *)(*(_DWORD *)*this + 4);
  v3 = *(_DWORD *)&(*this)[result + 56];
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}
// 1001BDB7: using guessed type int j____uncaught_exception(void);

//----- (100021C0) --------------------------------------------------------
_BYTE *__thiscall sub_100021C0(_BYTE *this, int a2)
{
  int v3; // ecx
  int v4; // eax
  bool v5; // al
  int v6; // ecx

  *(_DWORD *)this = a2;
  v3 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 56);
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v4 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( *(_DWORD *)(v4 + a2 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v6 = *(_DWORD *)(v4 + a2 + 60);
    if ( !v6 || v6 == a2 )
    {
      v5 = 1;
    }
    else
    {
      sub_10002290();
      v5 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 12) == 0;
    }
  }
  this[4] = v5;
  return this;
}
// 10002290: using guessed type int sub_10002290(void);

//----- (10002250) --------------------------------------------------------
int __thiscall sub_10002250(int *this)
{
  int v1; // ecx
  int result; // eax
  int v3; // ecx

  v1 = *this;
  result = *(_DWORD *)(*(_DWORD *)v1 + 4);
  v3 = *(_DWORD *)(result + v1 + 56);
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}

//----- (10002290) --------------------------------------------------------
_BYTE *__thiscall sub_10002290(_BYTE *this)
{
  int *v2; // ebx
  char v3; // di
  int v4; // eax
  int v5; // ecx
  int v7; // [esp+0h] [ebp-30h] BYREF
  _BYTE *v8; // [esp+10h] [ebp-20h] BYREF
  char v9; // [esp+14h] [ebp-1Ch]
  int v10; // [esp+18h] [ebp-18h]
  _BYTE *v11; // [esp+1Ch] [ebp-14h]
  int *v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-4h]

  v12 = &v7;
  v11 = this;
  v2 = *(int **)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v2 )
  {
    sub_100021C0(&v8, (int)this);
    v13 = 0;
    if ( v9 )
    {
      LOBYTE(v13) = 1;
      v3 = 0;
      v4 = *v2;
      v10 = 0;
      if ( (*(int (__thiscall **)(int *))(v4 + 52))(v2) == -1 )
        v3 = 4;
      v13 = 0;
      sub_10001870(
        &this[*(_DWORD *)(*(_DWORD *)this + 4)],
        v3 | this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] | (*(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56] != 0
                                                          ? 0
                                                          : 4),
        0);
    }
    if ( !(unsigned __int8)j____uncaught_exception() )
      sub_100023A0(v8);
    v13 = 3;
    v5 = *(_DWORD *)&v8[*(_DWORD *)(*(_DWORD *)v8 + 4) + 56];
    if ( v5 )
      (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 8))(v5);
  }
  return this;
}
// 1001BDB7: using guessed type int j____uncaught_exception(void);

//----- (100023A0) --------------------------------------------------------
int __thiscall sub_100023A0(_BYTE *this)
{
  int result; // eax
  _DWORD v3[8]; // [esp+0h] [ebp-20h] BYREF

  v3[7] = 0;
  v3[4] = v3;
  result = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)&this[result + 12] && (this[result + 20] & 2) != 0 )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)&this[result + 56] + 52))(*(_DWORD *)&this[result + 56]);
    if ( result == -1 )
      return sub_10001870(
               &this[*(_DWORD *)(*(_DWORD *)this + 4)],
               *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] | 4,
               0);
  }
  return result;
}

//----- (10002420) --------------------------------------------------------
int __cdecl sub_10002420(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList)
{
  unsigned __int64 *v5; // eax
  int result; // eax

  v5 = (unsigned __int64 *)sub_10001080();
  result = __stdio_common_vsprintf_s(*v5, Buffer, BufferCount, Format, Locale, ArgList);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (10002460) --------------------------------------------------------
int sub_10002460(char *Buffer, size_t BufferCount, char *Format, ...)
{
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, Format);
  return sub_10002420(Buffer, BufferCount, Format, 0, va);
}

//----- (10002480) --------------------------------------------------------
char *__fastcall sub_10002480(const char *ArgList)
{
  char *result; // eax
  WCHAR *i; // esi
  char j; // al
  char v5; // bl
  HANDLE v6; // edi
  size_t v7; // ebx
  void *v8; // edi
  FILE *v9; // esi
  WCHAR FileName[336]; // [esp+10h] [ebp-2A8h] BYREF
  DWORD NumberOfBytesRead; // [esp+2B0h] [ebp-8h] BYREF
  HANDLE hFile; // [esp+2B4h] [ebp-4h]

  result = strstr(ArgList, "$");
  if ( !result )
  {
    result = strstr(ArgList, "@");
    if ( !result )
    {
      hFile = CreateFileA(ArgList, 0x80000000, 0, 0, 3u, 0x80u, 0);
      sub_100010C0((int)"Decrypting %s %d\n", ArgList, hFile);
      sub_10001130((char *)FileName, "NotToday/%s", ArgList);
      result = (char *)GetFileAttributesW(FileName);
      if ( result == (char *)-1 || ((unsigned __int8)result & 0x10) != 0 )
      {
        for ( i = FileName; ; i = (WCHAR *)((char *)i + 1) )
        {
          for ( j = *(_BYTE *)i; j != 47; i = (WCHAR *)((char *)i + 1) )
          {
            if ( j == 92 )
              break;
            if ( !j )
              goto LABEL_12;
            j = *((_BYTE *)i + 1);
          }
          if ( !*((_BYTE *)i + 1) )
            break;
          v5 = *(_BYTE *)i;
          *(_BYTE *)i = 0;
          CreateDirectoryA((LPCSTR)FileName, 0);
          *(_BYTE *)i = v5;
        }
LABEL_12:
        v6 = hFile;
        result = (char *)SetFilePointer(hFile, 0, 0, 2u);
        v7 = (size_t)result;
        if ( (int)result > 0 )
        {
          SetFilePointer(v6, 0, 0, 0);
          v8 = malloc(v7);
          ReadFile(hFile, v8, v7, &NumberOfBytesRead, 0);
          SetFilePointer(hFile, 0, 0, 0);
          v9 = fopen((const char *)FileName, "wb+");
          fwrite(v8, 1u, v7, v9);
          fclose(v9);
          free(v8);
          return (char *)CloseHandle(hFile);
        }
      }
    }
  }
  return result;
}

//----- (100025E0) --------------------------------------------------------
char *__thiscall sub_100025E0(const char *this)
{
  char *result; // eax
  int v3; // edi
  const char *v4; // eax
  HANDLE FirstFileA; // ebx
  const char *v6; // eax
  char Str[224]; // [esp+10h] [ebp-328h] BYREF
  struct _WIN32_FIND_DATAA FindFileData; // [esp+F0h] [ebp-248h] BYREF
  CHAR FileName[264]; // [esp+230h] [ebp-108h] BYREF

  result = strstr(this, "NotToday");
  if ( !result )
  {
    if ( strstr(this, ":") || !strlen(this) )
    {
      v3 = 1;
      v4 = "./*";
    }
    else
    {
      v3 = 0;
      v4 = "/*";
    }
    sub_10001130(FileName, "%s%s", this, v4);
    FirstFileA = FindFirstFileA(FileName, &FindFileData);
    sub_100010C0((int)"Folder %s\n", FileName);
    do
    {
      if ( strlen(FindFileData.cFileName) >= 3 || !strstr(FindFileData.cFileName, ".") )
      {
        v6 = (const char *)&unk_1004A353;
        if ( !v3 )
          v6 = "/";
        sub_10001130(Str, "%s%s%s", this, v6, FindFileData.cFileName);
        sub_100010C0((int)"Found %s\n", Str);
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          sub_100025E0(Str);
        }
        else if ( !v3 && !strstr(this, ":") && strlen(this) >= 2 )
        {
          sub_10002480(Str);
        }
      }
    }
    while ( FindNextFileA(FirstFileA, &FindFileData) );
    FindClose(FirstFileA);
    return 0;
  }
  return result;
}

//----- (10002780) --------------------------------------------------------
int Main()
{
  return 1;
}

//----- (10002790) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  int v3; // eax
  FILE *v4; // eax
  CHAR Buffer[604]; // [esp+0h] [ebp-25Ch] BYREF

  if ( !dword_10053110 )
  {
    dword_10053110 = (int)hinstDLL;
    GetModuleHandleW(0);
  }
  v3 = dword_10053100;
  if ( !dword_10053100 )
  {
    AllocConsole();
    v4 = __acrt_iob_func(1u);
    freopen("CONOUT$", "w", v4);
    v3 = ++dword_10053100;
  }
  if ( v3 != 1 )
    goto LABEL_8;
  if ( dword_10051ACC == -16 )
  {
    GetCurrentDirectoryA(0x258u, Buffer);
    sub_100025E0((const char *)&unk_1004A353);
LABEL_8:
    --dword_10051ACC;
    return 1;
  }
  --dword_10051ACC;
  return 1;
}
// 10051ACC: using guessed type int dword_10051ACC;
// 10053100: using guessed type int dword_10053100;
// 10053110: using guessed type int dword_10053110;
// 10002790: using guessed type CHAR Buffer[604];

//----- (10002840) --------------------------------------------------------
_DWORD *__thiscall sub_10002840(_DWORD *this)
{
  _DWORD *result; // eax

  this[2] = 0;
  result = this;
  this[1] = "bad cast";
  *this = &std::bad_cast::`vftable';
  return result;
}
// 1003F4E8: using guessed type void *std::bad_cast::`vftable';

//----- (10002860) --------------------------------------------------------
void __noreturn sub_10002860()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_10002840(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
}
// 10002860: using guessed type void __noreturn sub_10002860();
// 10002860: using guessed type _DWORD pExceptionObject[3];

//----- (10002880) --------------------------------------------------------
_DWORD *__thiscall sub_10002880(_DWORD *this, int a2)
{
  *this = &std::exception::`vftable';
  this[1] = 0;
  this[2] = 0;
  __std_exception_copy(a2 + 4, this + 1);
  *this = &std::bad_cast::`vftable';
  return this;
}
// 1001E511: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 1003E224: using guessed type void *std::exception::`vftable';
// 1003F4E8: using guessed type void *std::bad_cast::`vftable';

//----- (100028C0) --------------------------------------------------------
_DWORD *__thiscall sub_100028C0(_DWORD *Block, char a2)
{
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1003F318: using guessed type void *std::_Facet_base::`vftable';

//----- (100028F0) --------------------------------------------------------
void __thiscall sub_100028F0(std::_Lockit *this)
{
  std::_Locinfo::_Locinfo_dtor(this);
  if ( *((_DWORD *)this + 11) )
    free(*((void **)this + 11));
  *((_DWORD *)this + 11) = 0;
  if ( *((_DWORD *)this + 9) )
    free(*((void **)this + 9));
  *((_DWORD *)this + 9) = 0;
  if ( *((_DWORD *)this + 7) )
    free(*((void **)this + 7));
  *((_DWORD *)this + 7) = 0;
  if ( *((_DWORD *)this + 5) )
    free(*((void **)this + 5));
  *((_DWORD *)this + 5) = 0;
  if ( *((_DWORD *)this + 3) )
    free(*((void **)this + 3));
  *((_DWORD *)this + 3) = 0;
  if ( *((_DWORD *)this + 1) )
    free(*((void **)this + 1));
  *((_DWORD *)this + 1) = 0;
  std::_Lockit::~_Lockit(this);
}

//----- (100029F0) --------------------------------------------------------
void __thiscall sub_100029F0(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 1);
}

//----- (10002A20) --------------------------------------------------------
void __thiscall sub_10002A20(_DWORD *this)
{
  *this = &std::_Facet_base::`vftable';
}
// 1003F318: using guessed type void *std::_Facet_base::`vftable';

//----- (10002A30) --------------------------------------------------------
void __thiscall sub_10002A30(_DWORD *this)
{
  int v1; // ecx
  void (__thiscall ***v2)(_DWORD, int); // eax

  v1 = this[1];
  if ( v1 )
  {
    v2 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    if ( v2 )
      (**v2)(v2, 1);
  }
}

//----- (10002A50) --------------------------------------------------------
int __cdecl sub_10002A50(_DWORD *a1, int a2)
{
  char *v2; // ebx
  int v3; // ecx
  const char *v4; // esi
  char v6[4]; // [esp+Ch] [ebp-54h] BYREF
  void *v7; // [esp+10h] [ebp-50h]
  char v8; // [esp+14h] [ebp-4Ch]
  void *v9; // [esp+18h] [ebp-48h]
  char v10; // [esp+1Ch] [ebp-44h]
  void *v11; // [esp+20h] [ebp-40h]
  __int16 v12; // [esp+24h] [ebp-3Ch]
  void *v13; // [esp+28h] [ebp-38h]
  __int16 v14; // [esp+2Ch] [ebp-34h]
  void *v15; // [esp+30h] [ebp-30h]
  char v16; // [esp+34h] [ebp-2Ch]
  void *Block; // [esp+38h] [ebp-28h]
  char v18; // [esp+3Ch] [ebp-24h]
  _Ctypevec v19; // [esp+40h] [ebp-20h] BYREF
  int v20; // [esp+5Ch] [ebp-4h]

  if ( a1 && !*a1 )
  {
    v2 = (char *)operator new(0x18u);
    v20 = 0;
    v3 = *(_DWORD *)(a2 + 4);
    if ( v3 )
    {
      v4 = *(const char **)(v3 + 24);
      if ( !v4 )
        v4 = (const char *)(v3 + 28);
    }
    else
    {
      v4 = (const char *)&unk_1004A353;
    }
    std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    Block = 0;
    v18 = 0;
    LOBYTE(v20) = 7;
    if ( !v4 )
      sub_1001C06E((int)"bad locale name");
    std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)v6, v4);
    *((_DWORD *)v2 + 1) = 0;
    *(_DWORD *)v2 = &std::ctype<char>::`vftable';
    *(_Ctypevec *)(v2 + 8) = *_Getctype(&v19);
    *a1 = v2;
    v20 = 8;
    std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)v6);
    LOBYTE(v20) = 9;
    if ( Block )
      free(Block);
    Block = 0;
    LOBYTE(v20) = 10;
    if ( v15 )
      free(v15);
    v15 = 0;
    LOBYTE(v20) = 11;
    if ( v13 )
      free(v13);
    v13 = 0;
    LOBYTE(v20) = 12;
    if ( v11 )
      free(v11);
    v11 = 0;
    LOBYTE(v20) = 13;
    if ( v9 )
      free(v9);
    v9 = 0;
    LOBYTE(v20) = 14;
    if ( v7 )
      free(v7);
    v7 = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v6);
  }
  return 2;
}
// 1003F4F4: using guessed type void *std::ctype<char>::`vftable';
// 10002A50: using guessed type char var_54[4];

//----- (10002C20) --------------------------------------------------------
int __thiscall sub_10002C20(int this, unsigned __int8 a2)
{
  return _Tolower(a2, (const _Ctypevec *)(this + 8));
}

//----- (10002C40) --------------------------------------------------------
_BYTE *__thiscall sub_10002C40(char *this, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // esi
  const _Ctypevec *v4; // ebx

  v3 = a2;
  if ( a2 != a3 )
  {
    v4 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Tolower((unsigned __int8)*v3, v4);
      ++v3;
    }
    while ( v3 != a3 );
  }
  return v3;
}

//----- (10002C70) --------------------------------------------------------
int __thiscall sub_10002C70(int this, unsigned __int8 a2)
{
  return _Toupper(a2, (const _Ctypevec *)(this + 8));
}

//----- (10002C90) --------------------------------------------------------
_BYTE *__thiscall sub_10002C90(char *this, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // esi
  const _Ctypevec *v4; // ebx

  v3 = a2;
  if ( a2 != a3 )
  {
    v4 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Toupper((unsigned __int8)*v3, v4);
      ++v3;
    }
    while ( v3 != a3 );
  }
  return v3;
}

//----- (10002CD0) --------------------------------------------------------
int __stdcall sub_10002CD0(void *Src, int a2, void *a3)
{
  memmove(a3, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (10002D00) --------------------------------------------------------
int __stdcall sub_10002D00(void *Src, int a2, int a3, void *a4)
{
  memmove(a4, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (10002D20) --------------------------------------------------------
void *__thiscall sub_10002D20(void *Block, char a2)
{
  int v3; // eax

  *(_DWORD *)Block = &std::ctype<char>::`vftable';
  v3 = *((_DWORD *)Block + 4);
  if ( v3 <= 0 )
  {
    if ( v3 < 0 )
      j_j__free(*((void **)Block + 3));
  }
  else
  {
    free(*((void **)Block + 3));
  }
  free(*((void **)Block + 5));
  *(_DWORD *)Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1003F318: using guessed type void *std::_Facet_base::`vftable';
// 1003F4F4: using guessed type void *std::ctype<char>::`vftable';

//----- (10002DA0) --------------------------------------------------------
struct std::ios_base *__thiscall sub_10002DA0(struct std::ios_base *Block, char a2)
{
  *(_DWORD *)Block = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(Block);
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A8C0: using guessed type void *std::ios_base::`vftable';

//----- (10002E00) --------------------------------------------------------
_DWORD *__stdcall Direct3DCreate8(int a1)
{
  bool v1; // zf
  FILE *v2; // eax
  int v3; // esi
  struct std::_Facet_base *v4; // eax
  void (__thiscall ***v5)(_DWORD, int); // eax
  _DWORD *v6; // ecx
  int v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  IDirect3D9 *v14; // esi
  _BYTE *v15; // eax
  _DWORD *v17; // edi
  _DWORD *v18; // ebx
  unsigned int v19; // eax
  UINT v20; // ecx
  const void **v21; // edi
  char *v22; // eax
  int v23; // eax
  unsigned int v24; // esi
  _DWORD *v25; // eax
  UINT v26; // [esp+24h] [ebp-2Ch]
  IDirect3D9 *v27; // [esp+28h] [ebp-28h]
  char *v28; // [esp+2Ch] [ebp-24h]
  _DWORD *v29; // [esp+30h] [ebp-20h]
  D3DFORMAT v30; // [esp+34h] [ebp-1Ch]
  unsigned int i; // [esp+38h] [ebp-18h] BYREF
  int v32; // [esp+3Ch] [ebp-14h]
  int v33[4]; // [esp+40h] [ebp-10h] BYREF
  int savedregs; // [esp+50h] [ebp+0h] BYREF

  v1 = dword_10053198 == 0;
  if ( !dword_10053198 )
  {
    v2 = sub_1001C63D("d3d8.log", 18, 64);
    if ( v2 )
    {
      sub_10005220((int)&dword_1005314C, v2, (char **)1);
      v32 = *(_DWORD *)(dword_10053180 + 4);
      v3 = v32;
      (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
      v4 = sub_10006580((int)&i);
      sub_100050F0(&dword_1005314C, (int)v4);
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
      if ( v5 )
        (**v5)(v5, 1);
      v6 = (int *)((char *)&dword_10053148 + *(_DWORD *)(dword_10053148 + 4));
      LOBYTE(v7) = v6[14] != 0 ? 0 : 4;
    }
    else
    {
      v6 = (int *)((char *)&dword_10053148 + *(_DWORD *)(dword_10053148 + 4));
      v7 = v6[3] | (4 * (v6[14] == 0) + 2);
    }
    sub_10001870(v6, v7, 0);
    v1 = dword_10053198 == 0;
  }
  if ( v1 && byte_10051AC8 )
  {
    byte_10051AC8 = 0;
    MessageBoxW(0, L"Failed to open debug log file \"d3d8.log\"!", 0, 0x30u);
  }
  v8 = sub_10006250(&dword_10053148, "Redirecting '");
  v9 = sub_10006250(v8, "Direct3DCreate8");
  v10 = sub_10006250(v9, "(");
  v11 = sub_100042E0(v10, (int)&savedregs, a1);
  v12 = sub_10006250(v11, ")' ...");
  sub_100064E0(v12);
  v13 = sub_10006250(&dword_10053148, "> Passing on to 'Direct3DCreate9':");
  sub_100064E0(v13);
  v14 = Direct3DCreate9(0x20u);
  v27 = v14;
  if ( !v14 )
    return 0;
  if ( (!dword_10053124 || !dword_10053120 || !dword_10053128) && !LoadLibraryW(L"d3dx9_43.dll") )
  {
    v15 = sub_10006250(&dword_10053148, "Failed to load d3dx9_43.dll! Some features will not work correctly.");
    sub_100064E0(v15);
    if ( MessageBoxW(
           0,
           L"Failed to load d3dx9_43.dll! Some features will not work correctly.\n"
            "\n"
            "It's required to install the \"Microsoft DirectX End-User Runtime\" in order to use d3d8to9.\n"
            "\n"
            "Please click \"OK\" to open the official download page or \"CANCEL\" to continue anyway.",
           0,
           0x50031u) == 1 )
    {
      ShellExecuteW(0, L"open", L"https://www.microsoft.com/download/details.aspx?id=35", 0, 0, 5);
      return 0;
    }
  }
  DllMain(0, 0, 0);
  v17 = operator new(0x8Cu);
  v29 = v17;
  v18 = v17 + 3;
  *v17 = &Direct3D8::`vftable';
  v17[1] = v14;
  v17[2] = 0;
  v17[3] = 0;
  v17[4] = 0;
  v17[5] = 0;
  v17[6] = 0;
  v17[7] = 0;
  v17[8] = 0;
  v17[9] = 0;
  v17[10] = 0;
  `eh vector constructor iterator'(
    v17 + 11,
    0xCu,
    8u,
    (void (__thiscall *)(void *))sub_10008040,
    (void (__thiscall *)(void *))sub_10007FE0);
  DllMain(0, 0, 0);
  v19 = v14->lpVtbl->GetAdapterCount(v14);
  v17[2] = v19;
  if ( v19 > 8 )
    v17[2] = 8;
  v20 = 0;
  v26 = 0;
  if ( v17[2] )
  {
    v21 = (const void **)(v17 + 12);
    do
    {
      v22 = (char *)&unk_1004A49C;
      v28 = (char *)&unk_1004A49C;
      do
      {
        v30 = *(_DWORD *)v22;
        v23 = v14->lpVtbl->GetAdapterModeCount(v14, v20, *(D3DFORMAT *)v22);
        v24 = 0;
        for ( i = v23; v24 < i; ++v24 )
        {
          v27->lpVtbl->EnumAdapterModes(v27, v26, v30, v24, (D3DDISPLAYMODE *)v33);
          v25 = *v21;
          if ( *v21 == v21[1] )
          {
            sub_100080D0(v21 - 1, v25, v33);
          }
          else
          {
            *v25 = v33[0];
            v25[1] = v33[1];
            v25[2] = v33[2];
            v25[3] = v33[3];
            *v21 = (char *)*v21 + 16;
          }
          ++*v18;
        }
        v14 = v27;
        v22 = v28 + 4;
        v20 = v26;
        v28 = v22;
      }
      while ( v22 != "bad cast" );
      v20 = v26 + 1;
      v21 += 3;
      v26 = v20;
      ++v18;
    }
    while ( v20 < v29[2] );
    return v29;
  }
  return v17;
}
// 1004A96C: using guessed type void *Direct3D8::`vftable';
// 10051AC8: using guessed type char byte_10051AC8;
// 10053120: using guessed type int dword_10053120;
// 10053124: using guessed type int dword_10053124;
// 10053128: using guessed type int dword_10053128;
// 10053148: using guessed type int dword_10053148;
// 1005314C: using guessed type int dword_1005314C;
// 10053180: using guessed type int dword_10053180;
// 10053198: using guessed type int dword_10053198;

//----- (10003140) --------------------------------------------------------
_DWORD *__thiscall sub_10003140(_DWORD *this, int a2)
{
  struct std::_Facet_base *v3; // eax

  v3 = sub_10006580(a2);
  return sub_100050F0(this, (int)v3);
}

//----- (10003160) --------------------------------------------------------
int __thiscall sub_10003160(FILE **this)
{
  if ( !this[19] || ((int (__thiscall *)(FILE **, int))(*this)->_flag)(this, -1) == -1 )
    return 0;
  else
    return (fflush(this[19]) >= 0) - 1;
}

//----- (10003190) --------------------------------------------------------
FILE **__thiscall sub_10003190(FILE **this, char *Buffer, __int64 Size)
{
  int v4; // eax

  if ( Buffer || Size )
    v4 = 0;
  else
    v4 = 4;
  if ( !this[19] || setvbuf(this[19], Buffer, v4, Size) )
    return 0;
  sub_10005220((int)this, this[19], (char **)1);
  return this;
}

//----- (100031F0) --------------------------------------------------------
_DWORD *__thiscall sub_100031F0(int this, _DWORD *a2, __int64 a3, __int64 a4, int a5, int a6, int a7)
{
  _DWORD *v8; // esi
  int v9; // ecx
  int v10; // edx
  _DWORD *result; // eax
  int v12; // esi
  int v13; // edi
  int v14; // edx
  fpos_t Position; // [esp+8h] [ebp-8h] BYREF

  Position = a3 + a4;
  if ( *(_DWORD *)(this + 76) && sub_10005180((void *)this) && !fsetpos(*(FILE **)(this + 76), &Position) )
  {
    v8 = *(_DWORD **)(this + 12);
    *(_DWORD *)(this + 64) = a5;
    *(_DWORD *)(this + 68) = a6;
    if ( *v8 == this + 60 )
    {
      v9 = *(_DWORD *)(this + 80);
      v10 = *(_DWORD *)(this + 84) - v9;
      *v8 = v9;
      **(_DWORD **)(this + 28) = v9;
      **(_DWORD **)(this + 44) = v10;
    }
    result = a2;
    v12 = *(_DWORD *)(this + 64);
    v13 = *(_DWORD *)(this + 68);
    v14 = HIDWORD(Position);
    *a2 = Position;
    a2[1] = v14;
    a2[2] = 0;
    a2[3] = 0;
    a2[4] = v12;
    a2[5] = v13;
  }
  else
  {
    result = a2;
    *a2 = -1;
    a2[1] = -1;
    a2[2] = 0;
    a2[3] = 0;
    a2[4] = 0;
    a2[5] = 0;
  }
  return result;
}

//----- (100032C0) --------------------------------------------------------
_DWORD *__thiscall sub_100032C0(int this, _DWORD *a2, __int64 a3, int Origin, int a5)
{
  unsigned int v6; // ebx
  unsigned int v7; // esi
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // edx
  _DWORD *result; // eax
  int v12; // esi
  int v13; // edi
  int v14; // edx
  fpos_t Position; // [esp+10h] [ebp-8h] BYREF

  if ( **(_DWORD **)(this + 28) == this + 60 && Origin == 1 && !*(_DWORD *)(this + 56) )
  {
    v6 = (unsigned __int64)(a3 - 1) >> 32;
    v7 = a3 - 1;
  }
  else
  {
    v6 = HIDWORD(a3);
    v7 = a3;
  }
  if ( !*(_DWORD *)(this + 76)
    || !sub_10005180((void *)this)
    || (v6 | v7 || Origin != 1) && _fseeki64(*(FILE **)(this + 76), __SPAIR64__(v6, v7), Origin)
    || fgetpos(*(FILE **)(this + 76), &Position) )
  {
    result = a2;
    *a2 = -1;
    a2[1] = -1;
    a2[2] = 0;
    a2[3] = 0;
    a2[4] = 0;
    a2[5] = 0;
  }
  else
  {
    v8 = *(_DWORD **)(this + 12);
    if ( *v8 == this + 60 )
    {
      v9 = *(_DWORD *)(this + 80);
      v10 = *(_DWORD *)(this + 84) - v9;
      *v8 = v9;
      **(_DWORD **)(this + 28) = v9;
      **(_DWORD **)(this + 44) = v10;
    }
    result = a2;
    v12 = *(_DWORD *)(this + 64);
    v13 = *(_DWORD *)(this + 68);
    v14 = HIDWORD(Position);
    *a2 = Position;
    a2[1] = v14;
    a2[2] = 0;
    a2[3] = 0;
    a2[4] = v12;
    a2[5] = v13;
  }
  return result;
}

//----- (100033D0) --------------------------------------------------------
int __thiscall sub_100033D0(char *this, char *Buffer, __int64 ElementCount)
{
  int v3; // ebx
  int v4; // edx
  size_t v5; // edi
  _DWORD **v6; // edx
  int v7; // eax
  size_t v8; // esi
  int v9; // eax
  bool v10; // cf
  int v12; // edi
  size_t v13; // esi
  int v14; // edx
  __int64 v15; // rax
  char *v16; // ebx
  char *Src; // [esp+Ch] [ebp-1Ch]
  void *Srca; // [esp+Ch] [ebp-1Ch]
  char *v19; // [esp+10h] [ebp-18h]
  int v20; // [esp+14h] [ebp-14h]
  unsigned int v21; // [esp+14h] [ebp-14h]
  void *v22; // [esp+18h] [ebp-10h]
  _DWORD **v23; // [esp+18h] [ebp-10h]
  _DWORD **v24; // [esp+1Ch] [ebp-Ch]
  void *v25; // [esp+1Ch] [ebp-Ch]

  v19 = this;
  if ( !*((_DWORD *)this + 14) )
  {
    v12 = HIDWORD(ElementCount);
    v13 = ElementCount;
    v25 = (void *)**((_DWORD **)this + 8);
    v23 = (_DWORD **)(this + 48);
    if ( v25 )
    {
      v14 = **((_DWORD **)this + 12);
    }
    else
    {
      v14 = 0;
      v23 = (_DWORD **)(this + 48);
    }
    v15 = v14;
    Srca = (void *)HIDWORD(v15);
    v21 = v15;
    if ( ElementCount <= 0 )
    {
      v16 = Buffer;
    }
    else
    {
      if ( v15 < 0 || !(_DWORD)v15 )
      {
        v16 = Buffer;
        goto LABEL_34;
      }
      if ( ElementCount < v15 )
      {
        Srca = (void *)HIDWORD(ElementCount);
        LODWORD(v15) = ElementCount;
        v21 = ElementCount;
      }
      memmove(v25, Buffer, v15);
      v16 = &Buffer[v21];
      this = v19;
      v12 = (ElementCount - __PAIR64__((unsigned int)Srca, v21)) >> 32;
      v13 = ElementCount - v21;
      **v23 -= v21;
      **((_DWORD **)v19 + 8) += v21;
    }
    if ( v12 < 0 || v12 <= 0 && !v13 )
      return ElementCount - v13;
LABEL_34:
    if ( *((_DWORD *)this + 19) )
      v13 -= fwrite(v16, 1u, v13, *((FILE **)this + 19));
    return ElementCount - v13;
  }
  v3 = HIDWORD(ElementCount);
  v4 = ElementCount;
  v5 = ElementCount;
  Src = Buffer;
  if ( ElementCount > 0 )
  {
    v6 = (_DWORD **)(this + 48);
    do
    {
      v24 = v6;
      v22 = (void *)**((_DWORD **)this + 8);
      if ( v22 )
        v7 = **v6;
      else
        v7 = 0;
      v8 = v7;
      v9 = v7 >> 31;
      v20 = v9;
      if ( __SPAIR64__(v9, v8) <= 0 )
      {
        if ( (*(int (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 12))(this, (unsigned __int8)*Src) == -1 )
          break;
        this = v19;
        v10 = v5-- != 0;
        v8 = 1;
        v3 = v10 + v3 - 1;
        v6 = (_DWORD **)(v19 + 48);
      }
      else
      {
        if ( v3 <= v9 && (v3 < v9 || v5 < v8) )
        {
          v8 = v5;
          v20 = v3;
        }
        memmove(v22, Src, v8);
        v6 = v24;
        this = v19;
        v3 = (__PAIR64__(v3, v5) - __PAIR64__(v20, v8)) >> 32;
        v5 -= v8;
        **v24 -= v8;
        **((_DWORD **)v19 + 8) += v8;
      }
      Src += v8;
    }
    while ( v3 > 0 || v3 >= 0 && v5 );
    v4 = ElementCount;
  }
  return v4 - v5;
}
// 10003511: conditional instruction was optimized away because edx.4==0

//----- (100035A0) --------------------------------------------------------
__int64 __thiscall sub_100035A0(char *this, char *a2, __int64 a3)
{
  size_t v5; // ebx
  _DWORD **v6; // edx
  int v7; // ecx
  int v8; // eax
  size_t v9; // esi
  int v10; // eax
  int v11; // eax
  bool v12; // cf
  size_t v13; // esi
  const void *v14; // ebx
  size_t v15; // eax
  char *v16; // ebx
  int v17; // ecx
  int v18; // edx
  size_t v19; // eax
  int v20; // [esp+Ch] [ebp-14h]
  _BYTE *v21; // [esp+10h] [ebp-10h]
  _DWORD **v22; // [esp+10h] [ebp-10h]
  int v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+14h] [ebp-Ch]
  void *Src; // [esp+18h] [ebp-8h]
  _DWORD **v26; // [esp+1Ch] [ebp-4h]

  if ( a3 <= 0 )
    return 0i64;
  if ( !*((_DWORD *)this + 14) )
  {
    v13 = a3;
    v14 = (const void *)**((_DWORD **)this + 7);
    if ( v14 )
    {
      v22 = (_DWORD **)(this + 44);
      v15 = **((_DWORD **)this + 11);
      v24 = v15;
      if ( v15 )
      {
        if ( v15 >= (unsigned int)a3 )
        {
          v15 = a3;
          v24 = a3;
        }
        memmove(a2, v14, v15);
        v16 = &a2[v24];
        v13 = a3 - v24;
        **((_DWORD **)this + 11) -= v24;
        **((_DWORD **)this + 7) += v24;
LABEL_29:
        if ( *((_DWORD *)this + 19) )
        {
          if ( **((char ***)this + 3) == this + 60 )
          {
            v17 = *((_DWORD *)this + 20);
            v18 = *((_DWORD *)this + 21) - v17;
            **((_DWORD **)this + 3) = v17;
            **((_DWORD **)this + 7) = v17;
            **v22 = v18;
          }
          if ( v13 <= 0xFFF )
          {
LABEL_35:
            if ( v13 )
              v13 -= fread(v16, 1u, v13, *((FILE **)this + 19));
          }
          else
          {
            while ( 1 )
            {
              v19 = fread(v16, 1u, 0xFFFu, *((FILE **)this + 19));
              v16 += v19;
              v13 -= v19;
              if ( v19 != 4095 )
                break;
              if ( v13 <= 0xFFF )
                goto LABEL_35;
            }
          }
        }
        return a3 - v13;
      }
    }
    else
    {
      v22 = (_DWORD **)(this + 44);
    }
    v16 = a2;
    goto LABEL_29;
  }
  v5 = a3;
  v6 = (_DWORD **)(this + 44);
  v7 = HIDWORD(a3);
  v20 = HIDWORD(a3);
  v21 = a2;
  while ( 1 )
  {
    v26 = v6;
    Src = (void *)**((_DWORD **)this + 7);
    if ( Src )
      v8 = **v6;
    else
      v8 = 0;
    v9 = v8;
    v10 = v8 >> 31;
    v23 = v10;
    if ( __SPAIR64__(v10, v9) > 0 )
    {
      if ( v7 <= v10 && (v7 < v10 || v5 < v9) )
      {
        v9 = v5;
        v23 = v7;
      }
      memmove(v21, Src, v9);
      v6 = v26;
      v7 = (__PAIR64__(v20, v5) - __PAIR64__(v23, v9)) >> 32;
      v5 -= v9;
      **v26 -= v9;
      **((_DWORD **)this + 7) += v9;
      goto LABEL_16;
    }
    v11 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 28))(this);
    if ( v11 == -1 )
      break;
    v6 = (_DWORD **)(this + 44);
    v12 = v5-- != 0;
    v9 = 1;
    *v21 = v11;
    v7 = v12 + v20 - 1;
LABEL_16:
    v21 += v9;
    v20 = v7;
    if ( v7 <= 0 )
    {
      if ( v7 < 0 )
        return a3 - __PAIR64__(v7, v5);
      if ( !v5 )
        return a3 - __PAIR64__(v7, 0);
    }
  }
  v7 = v20;
  return a3 - __PAIR64__(v7, v5);
}

//----- (10003790) --------------------------------------------------------
int __thiscall sub_10003790(int this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // edx
  _DWORD *v4; // ecx
  unsigned __int8 *v5; // edx
  int result; // eax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // edx
  FILE *v10; // eax
  int v11; // edx
  int v12; // ecx
  void **v13; // eax
  void **v14; // edx
  int v15; // ebx
  int v16; // eax
  void **v17; // edx
  int v18; // eax
  int v19; // eax
  void **v20; // eax
  int v21; // ecx
  void **v22; // edx
  int v23; // esi
  int v24; // esi
  void *v25; // edx
  void **v26; // eax
  void **v27; // ecx
  int v28; // eax
  int v29; // esi
  int v30; // eax
  FILE *v31; // [esp-14h] [ebp-58h]
  void *Block[4]; // [esp+8h] [ebp-3Ch] BYREF
  int v33; // [esp+18h] [ebp-2Ch]
  unsigned int v34; // [esp+1Ch] [ebp-28h]
  char *v35; // [esp+20h] [ebp-24h] BYREF
  int v36; // [esp+24h] [ebp-20h]
  int v37; // [esp+28h] [ebp-1Ch]
  char v38[4]; // [esp+2Ch] [ebp-18h]
  int v39; // [esp+30h] [ebp-14h] BYREF
  unsigned __int8 v40; // [esp+37h] [ebp-Dh] BYREF
  int v41[3]; // [esp+38h] [ebp-Ch] BYREF

  v2 = **(_DWORD **)(this + 28);
  if ( v2 )
  {
    v3 = *(_DWORD **)(this + 44);
    if ( v2 < *v3 + v2 )
    {
      --*v3;
      v4 = *(_DWORD **)(this + 28);
      v5 = (unsigned __int8 *)(*v4)++;
      return *v5;
    }
  }
  if ( !*(_DWORD *)(this + 76) )
    return -1;
  v7 = *(_DWORD **)(this + 12);
  if ( *v7 == this + 60 )
  {
    v8 = *(_DWORD *)(this + 80);
    v9 = *(_DWORD *)(this + 84) - v8;
    *v7 = v8;
    **(_DWORD **)(this + 28) = v8;
    **(_DWORD **)(this + 44) = v9;
  }
  v10 = *(FILE **)(this + 76);
  if ( *(_DWORD *)(this + 56) )
  {
    v34 = 15;
    memset(Block, 0, sizeof(Block));
    v33 = 0;
    v41[2] = 0;
    v11 = fgetc(v10);
    if ( v11 == -1 )
    {
LABEL_31:
      v24 = -1;
    }
    else
    {
      while ( 1 )
      {
        v12 = v33;
        v38[0] = v11;
        if ( v33 >= v34 )
        {
          LOBYTE(v37) = 0;
          sub_100068E0(Block, v33, v37, v38[0]);
        }
        else
        {
          ++v33;
          v13 = Block;
          if ( v34 >= 0x10 )
            v13 = (void **)Block[0];
          *((_BYTE *)v13 + v12) = v11;
          *((_BYTE *)v13 + v12 + 1) = 0;
        }
        v14 = Block;
        v15 = *(_DWORD *)(this + 56);
        if ( v34 >= 0x10 )
          v14 = (void **)Block[0];
        v16 = (int)v14 + v33;
        v17 = Block;
        v36 = v16;
        if ( v34 >= 0x10 )
          v17 = (void **)Block[0];
        v18 = (*(int (__thiscall **)(int, int, void **, int, int *, unsigned __int8 *, int *, char **))(*(_DWORD *)v15 + 24))(
                v15,
                this + 64,
                v17,
                v36,
                &v39,
                &v40,
                v41,
                &v35);
        if ( v18 )
        {
          v19 = v18 - 1;
          if ( v19 )
            break;
        }
        if ( v35 != (char *)&v40 )
        {
          v27 = Block;
          if ( v34 >= 0x10 )
            v27 = (void **)Block[0];
          v28 = v39;
          v29 = (int)v27 + v33 - v39;
          if ( v29 > 0 )
          {
            while ( 1 )
            {
              v30 = *(char *)(v29 + v28 - 1);
              --v29;
              ungetc(v30, *(FILE **)(this + 76));
              if ( v29 <= 0 )
                break;
              v28 = v39;
            }
          }
          v24 = v40;
          goto LABEL_32;
        }
        v20 = Block;
        if ( v34 >= 0x10 )
          v20 = (void **)Block[0];
        v21 = v39 - (_DWORD)v20;
        if ( v33 < (unsigned int)(v39 - (_DWORD)v20) )
          v21 = v33;
        v22 = Block;
        if ( v34 >= 0x10 )
          v22 = (void **)Block[0];
        v23 = v33 - v21;
        memmove(v22, (char *)v22 + v21, v33 - v21 + 1);
        v31 = *(FILE **)(this + 76);
        v33 = v23;
        v11 = fgetc(v31);
        if ( v11 == -1 )
          goto LABEL_31;
      }
      if ( v19 != 2 )
        goto LABEL_31;
      v26 = Block;
      if ( v34 >= 0x10 )
        v26 = (void **)Block[0];
      v24 = *(char *)v26;
    }
LABEL_32:
    if ( v34 >= 0x10 )
    {
      v25 = Block[0];
      if ( v34 + 1 >= 0x1000 )
      {
        v25 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v25 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_1001D481(v25);
    }
    return v24;
  }
  else
  {
    result = fgetc(*(FILE **)(this + 76));
    if ( result == -1 )
      return -1;
    return (unsigned __int8)result;
  }
}
// 10003790: using guessed type int var_14;

//----- (10003A10) --------------------------------------------------------
int __thiscall sub_10003A10(_DWORD **this)
{
  unsigned __int8 *v2; // ecx
  int result; // eax
  int v4; // edi

  v2 = (unsigned __int8 *)*this[7];
  if ( v2 && v2 < &v2[*this[11]] )
    return *v2;
  result = ((int (__thiscall *)(_DWORD **))(*this)[7])(this);
  v4 = result;
  if ( result != -1 )
  {
    ((void (__thiscall *)(_DWORD **, int))(*this)[4])(this, result);
    return v4;
  }
  return result;
}

//----- (10003A50) --------------------------------------------------------
int __thiscall sub_10003A50(int this, int a2)
{
  unsigned int v3; // ecx
  _DWORD *v5; // edx
  _BYTE *v6; // ecx
  _DWORD *v7; // edi

  v3 = **(_DWORD **)(this + 28);
  if ( v3 && **(_DWORD **)(this + 12) < v3 && (a2 == -1 || *(unsigned __int8 *)(v3 - 1) == a2) )
  {
    ++**(_DWORD **)(this + 44);
    --**(_DWORD **)(this + 28);
    return a2 != -1 ? a2 : 0;
  }
  if ( !*(_DWORD *)(this + 76) || a2 == -1 )
    return -1;
  if ( !*(_DWORD *)(this + 56) && ungetc((unsigned __int8)a2, *(FILE **)(this + 76)) != -1 )
    return a2;
  v5 = *(_DWORD **)(this + 28);
  v6 = (_BYTE *)(this + 60);
  if ( *v5 == this + 60 )
    return -1;
  v7 = *(_DWORD **)(this + 12);
  *v6 = a2;
  if ( (_BYTE *)*v7 != v6 )
  {
    *(_DWORD *)(this + 80) = *v7;
    *(_DWORD *)(this + 84) = *v5 + **(_DWORD **)(this + 44);
  }
  *v7 = v6;
  **(_DWORD **)(this + 28) = v6;
  **(_DWORD **)(this + 44) = 1;
  return a2;
}

//----- (10003B10) --------------------------------------------------------
int __thiscall sub_10003B10(int this, char *a2)
{
  char *v2; // ebx
  int result; // eax
  unsigned int v5; // ecx
  _DWORD *v6; // edx
  _DWORD *v7; // edx
  _BYTE *v8; // esi
  _DWORD *v9; // edi
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // edi
  char Buffer[32]; // [esp+8h] [ebp-28h] BYREF
  char *v18; // [esp+28h] [ebp-8h] BYREF
  char v19; // [esp+2Fh] [ebp-1h] BYREF
  char vars0; // [esp+30h] [ebp+0h] BYREF

  v2 = a2;
  if ( a2 == (char *)-1 )
    return 0;
  v5 = **(_DWORD **)(this + 32);
  if ( v5 )
  {
    v6 = *(_DWORD **)(this + 48);
    if ( v5 < *v6 + v5 )
    {
      result = (int)a2;
      --*v6;
      v7 = *(_DWORD **)(this + 32);
      v8 = (_BYTE *)(*v7)++;
      *v8 = (_BYTE)v2;
      return result;
    }
  }
  if ( *(_DWORD *)(this + 76) )
  {
    v9 = *(_DWORD **)(this + 12);
    if ( *v9 == this + 60 )
    {
      v10 = *(_DWORD *)(this + 80);
      v11 = *(_DWORD *)(this + 84) - v10;
      *v9 = v10;
      **(_DWORD **)(this + 28) = v10;
      **(_DWORD **)(this + 44) = v11;
    }
    v12 = *(_DWORD *)(this + 56);
    if ( !v12 )
    {
      v13 = (char)v2;
      goto LABEL_15;
    }
    v19 = (char)v2;
    v14 = (*(int (__thiscall **)(int, int, char *, char *, char **, char *, char **, char **))(*(_DWORD *)v12 + 28))(
            v12,
            this + 64,
            &v19,
            &vars0,
            &v18,
            Buffer,
            &v18,
            &a2);
    if ( v14 && (v15 = v14 - 1) != 0 )
    {
      if ( v15 == 2 )
      {
        v13 = v19;
LABEL_15:
        if ( fputc(v13, *(FILE **)(this + 76)) == -1 )
          return -1;
        return (int)v2;
      }
    }
    else if ( a2 == Buffer || (v16 = a2 - Buffer, v16 == fwrite(Buffer, 1u, a2 - Buffer, *(FILE **)(this + 76))) )
    {
      *(_BYTE *)(this + 61) = 1;
      if ( v18 != &v19 )
        return (int)v2;
    }
  }
  return -1;
}
// 10003B10: using guessed type char *var_8;

//----- (10003C20) --------------------------------------------------------
void __thiscall sub_10003C20(FILE **this)
{
  if ( this[19] )
    _unlock_file(this[19]);
}

//----- (10003C30) --------------------------------------------------------
void __thiscall sub_10003C30(FILE **this)
{
  if ( this[19] )
    _lock_file(this[19]);
}

//----- (10003C40) --------------------------------------------------------
void __thiscall sub_10003C40(int this)
{
  bool v2; // zf
  _DWORD *v3; // edi
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // edi
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  _DWORD *v11; // esi
  int v12; // ecx
  void (__thiscall ***v13)(_DWORD, int); // eax

  v2 = *(_DWORD *)(this + 76) == 0;
  *(_DWORD *)this = &std::filebuf::`vftable';
  if ( !v2 )
  {
    v3 = *(_DWORD **)(this + 12);
    if ( *v3 == this + 60 )
    {
      v4 = *(_DWORD *)(this + 84);
      v5 = *(_DWORD *)(this + 80);
      *v3 = v5;
      **(_DWORD **)(this + 28) = v5;
      **(_DWORD **)(this + 44) = v4 - v5;
    }
  }
  if ( *(_BYTE *)(this + 72) )
  {
    if ( *(_DWORD *)(this + 76) )
    {
      v6 = *(_DWORD **)(this + 12);
      if ( *v6 == this + 60 )
      {
        v7 = *(_DWORD *)(this + 80);
        v8 = *(_DWORD *)(this + 84) - v7;
        *v6 = v7;
        **(_DWORD **)(this + 28) = v7;
        **(_DWORD **)(this + 44) = v8;
      }
      sub_10005180((void *)this);
      fclose(*(FILE **)(this + 76));
    }
    *(_BYTE *)(this + 72) = 0;
    *(_DWORD *)(this + 12) = this + 4;
    *(_DWORD *)(this + 32) = this + 24;
    *(_DWORD *)(this + 28) = this + 20;
    *(_BYTE *)(this + 61) = 0;
    *(_DWORD *)(this + 44) = this + 36;
    *(_DWORD *)(this + 48) = this + 40;
    *(_DWORD *)(this + 16) = this + 8;
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 24) = 0;
    v9 = dword_10053218;
    *(_DWORD *)(this + 40) = 0;
    **(_DWORD **)(this + 12) = 0;
    **(_DWORD **)(this + 28) = 0;
    **(_DWORD **)(this + 44) = 0;
    v10 = dword_10053214;
    *(_DWORD *)(this + 76) = 0;
    *(_DWORD *)(this + 64) = v10;
    *(_DWORD *)(this + 68) = v9;
    *(_DWORD *)(this + 56) = 0;
  }
  *(_DWORD *)this = &std::streambuf::`vftable';
  v11 = *(_DWORD **)(this + 52);
  if ( v11 )
  {
    v12 = v11[1];
    if ( v12 )
    {
      v13 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v12 + 8))(v12);
      if ( v13 )
        (**v13)(v13, 1);
    }
    sub_1001D481(v11);
  }
}
// 1004A880: using guessed type void *std::streambuf::`vftable';
// 1004A8C8: using guessed type void *std::filebuf::`vftable';
// 10053214: using guessed type int dword_10053214;
// 10053218: using guessed type int dword_10053218;

//----- (10003DA0) --------------------------------------------------------
int sub_10003DA0()
{
  return 0;
}

//----- (10003DB0) --------------------------------------------------------
void *__thiscall sub_10003DB0(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (10003DC0) --------------------------------------------------------
_DWORD *__stdcall sub_10003DC0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = -1;
  a1[1] = -1;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return result;
}

//----- (10003DF0) --------------------------------------------------------
_DWORD *__stdcall sub_10003DF0(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = -1;
  a1[1] = -1;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return result;
}

//----- (10003E20) --------------------------------------------------------
unsigned __int64 __thiscall sub_10003E20(_DWORD **this, unsigned __int8 *Src, __int64 a3)
{
  int v3; // ebx
  size_t v4; // edi
  __int64 v5; // rax
  int v6; // eax
  size_t v7; // esi
  int v8; // eax
  bool v9; // cf
  int v11; // [esp+Ch] [ebp-14h]
  _DWORD **v12; // [esp+10h] [ebp-10h]
  void *v13; // [esp+14h] [ebp-Ch]

  v3 = HIDWORD(a3);
  v12 = this;
  v4 = a3;
  v5 = a3;
  if ( a3 > 0 )
  {
    do
    {
      v13 = (void *)*this[8];
      if ( v13 )
        v6 = *this[12];
      else
        v6 = 0;
      v7 = v6;
      v8 = v6 >> 31;
      v11 = v8;
      if ( __SPAIR64__(v8, v7) <= 0 )
      {
        if ( ((int (__thiscall *)(_DWORD **, _DWORD))(*this)[3])(this, *Src) == -1 )
          break;
        this = v12;
        v9 = v4-- != 0;
        v7 = 1;
        v3 = v9 + v3 - 1;
      }
      else
      {
        if ( v3 <= v8 && (v3 < v8 || v4 < v7) )
        {
          v7 = v4;
          v11 = v3;
        }
        memmove(v13, Src, v7);
        this = v12;
        v3 = (__PAIR64__(v3, v4) - __PAIR64__(v11, v7)) >> 32;
        v4 -= v7;
        *v12[12] -= v7;
        *v12[8] += v7;
      }
      Src += v7;
    }
    while ( v3 > 0 || v3 >= 0 && v4 );
    v5 = a3;
  }
  return v5 - __PAIR64__(v3, v4);
}

//----- (10003F00) --------------------------------------------------------
unsigned __int64 __thiscall sub_10003F00(_DWORD **this, char *a2, __int64 a3)
{
  int v3; // ebx
  size_t v4; // edi
  __int64 v5; // rax
  int v6; // eax
  size_t v7; // esi
  int v8; // eax
  int v9; // eax
  bool v10; // cf
  int v12; // [esp+Ch] [ebp-14h]
  _DWORD **v13; // [esp+10h] [ebp-10h]
  void *Src; // [esp+14h] [ebp-Ch]

  v3 = HIDWORD(a3);
  v13 = this;
  v4 = a3;
  v5 = a3;
  if ( a3 > 0 )
  {
    do
    {
      Src = (void *)*this[7];
      if ( Src )
        v6 = *this[11];
      else
        v6 = 0;
      v7 = v6;
      v8 = v6 >> 31;
      v12 = v8;
      if ( __SPAIR64__(v8, v7) <= 0 )
      {
        v9 = ((int (__thiscall *)(_DWORD **))(*this)[7])(this);
        if ( v9 == -1 )
          break;
        v10 = v4-- != 0;
        v7 = 1;
        v3 = v10 + v3 - 1;
        *a2 = v9;
        this = v13;
      }
      else
      {
        if ( v3 <= v8 && (v3 < v8 || v4 < v7) )
        {
          v7 = v4;
          v12 = v3;
        }
        memmove(a2, Src, v7);
        this = v13;
        v3 = (__PAIR64__(v3, v4) - __PAIR64__(v12, v7)) >> 32;
        v4 -= v7;
        *v13[11] -= v7;
        *v13[7] += v7;
      }
      a2 += v7;
    }
    while ( v3 > 0 || v3 >= 0 && v4 );
    v5 = a3;
  }
  return v5 - __PAIR64__(v3, v4);
}

//----- (10003FE0) --------------------------------------------------------
int __thiscall sub_10003FE0(_DWORD **this)
{
  int result; // eax
  _DWORD *v3; // ecx
  unsigned __int8 *v4; // edx

  result = ((int (__thiscall *)(_DWORD **))(*this)[6])(this);
  if ( result != -1 )
  {
    --*this[11];
    v3 = this[7];
    v4 = (unsigned __int8 *)(*v3)++;
    return *v4;
  }
  return result;
}

//----- (10004010) --------------------------------------------------------
int sub_10004010()
{
  return -1;
}

//----- (10004020) --------------------------------------------------------
__int64 sub_10004020()
{
  return 0i64;
}

//----- (10004030) --------------------------------------------------------
int __stdcall sub_10004030(int a1)
{
  return -1;
}

//----- (10004040) --------------------------------------------------------
int *__stdcall sub_10004040(int a1)
{
  _DWORD *v1; // esi
  int v2; // esi
  struct std::_Facet_base *v3; // eax
  char v4; // al
  char v5; // bl
  void (__thiscall ***v6)(_DWORD, int); // eax
  _DWORD *v7; // esi
  struct std::locale::_Locimp *v8; // eax
  int v9; // ecx
  int *result; // eax
  char v11[4]; // [esp+8h] [ebp-1Ch] BYREF
  int v12; // [esp+Ch] [ebp-18h]
  int *v13; // [esp+10h] [ebp-14h]
  int v14; // [esp+14h] [ebp-10h]
  int v15; // [esp+20h] [ebp-4h]

  v13 = &dword_10053148;
  dword_10053148 = (int)&unk_1004A90C;
  v14 = 1;
  dword_100531B0 = &std::ostream::`vftable';
  dword_100531AC = 96;
  dword_100531E0 = 0;
  dword_100531B8 = 0;
  dword_100531C0 = 0;
  dword_100531C4 = 513;
  dword_100531C8 = 6;
  dword_100531CC = 0;
  dword_100531D0 = 0;
  dword_100531D4 = 0;
  dword_100531D8 = 0;
  dword_100531DC = 0;
  sub_10001870(&dword_100531B0, 0, 0);
  v1 = operator new(8u);
  v15 = 2;
  v1[1] = sub_1001C2C3(1);
  dword_100531E0 = (int)v1;
  dword_100531E8 = (int)&dword_1005314C;
  dword_100531EC = 0;
  v2 = v1[1];
  v12 = v2;
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  v15 = 3;
  v3 = sub_10006130((int)v11);
  v4 = (*(int (__thiscall **)(struct std::_Facet_base *, int))(*(_DWORD *)v3 + 32))(v3, 32);
  LOBYTE(v15) = 1;
  v5 = v4;
  v6 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v2 + 8))(v2);
  if ( v6 )
    (**v6)(v6, 1);
  byte_100531F0 = v5;
  if ( !dword_100531E8 )
    sub_10001870(&dword_100531B0, dword_100531BC | 4, 0);
  v15 = 4;
  *(int *)((char *)&dword_10053148 + *(_DWORD *)(dword_10053148 + 4)) = (int)&std::ofstream::`vftable';
  *(int *)((char *)&dword_10053144 + *(_DWORD *)(dword_10053148 + 4)) = *(_DWORD *)(dword_10053148 + 4) - 104;
  dword_1005314C = (int)&std::streambuf::`vftable';
  v7 = operator new(8u);
  LOBYTE(v15) = 5;
  v8 = sub_1001C2C3(1);
  v9 = dword_10053218;
  v7[1] = v8;
  dword_10053180 = (int)v7;
  dword_10053190 = v9;
  dword_1005318C = dword_10053214;
  result = &dword_10053148;
  dword_1005314C = (int)&std::filebuf::`vftable';
  byte_10053194 = 0;
  byte_10053189 = 0;
  dword_10053158 = (int)&dword_10053150;
  dword_1005315C = (int)&dword_10053154;
  dword_10053168 = (int)&dword_10053160;
  dword_1005316C = (int)&dword_10053164;
  dword_10053178 = (int)&dword_10053170;
  dword_1005317C = (int)&dword_10053174;
  dword_10053154 = 0;
  dword_10053164 = 0;
  dword_10053174 = 0;
  dword_10053150 = 0;
  dword_10053160 = 0;
  dword_10053170 = 0;
  dword_10053198 = 0;
  dword_10053184 = 0;
  return result;
}
// 1004A880: using guessed type void *std::streambuf::`vftable';
// 1004A8C8: using guessed type void *std::filebuf::`vftable';
// 1004A908: using guessed type void *std::ofstream::`vftable';
// 1004A918: using guessed type void *std::ostream::`vftable';
// 10053144: using guessed type int dword_10053144;
// 10053148: using guessed type int dword_10053148;
// 1005314C: using guessed type int dword_1005314C;
// 10053150: using guessed type int dword_10053150;
// 10053154: using guessed type int dword_10053154;
// 10053158: using guessed type int dword_10053158;
// 1005315C: using guessed type int dword_1005315C;
// 10053160: using guessed type int dword_10053160;
// 10053164: using guessed type int dword_10053164;
// 10053168: using guessed type int dword_10053168;
// 1005316C: using guessed type int dword_1005316C;
// 10053170: using guessed type int dword_10053170;
// 10053174: using guessed type int dword_10053174;
// 10053178: using guessed type int dword_10053178;
// 1005317C: using guessed type int dword_1005317C;
// 10053180: using guessed type int dword_10053180;
// 10053184: using guessed type int dword_10053184;
// 10053189: using guessed type char byte_10053189;
// 1005318C: using guessed type int dword_1005318C;
// 10053190: using guessed type int dword_10053190;
// 10053194: using guessed type char byte_10053194;
// 10053198: using guessed type int dword_10053198;
// 100531AC: using guessed type int dword_100531AC;
// 100531B8: using guessed type int dword_100531B8;
// 100531BC: using guessed type int dword_100531BC;
// 100531C0: using guessed type int dword_100531C0;
// 100531C4: using guessed type int dword_100531C4;
// 100531C8: using guessed type int dword_100531C8;
// 100531CC: using guessed type int dword_100531CC;
// 100531D0: using guessed type int dword_100531D0;
// 100531D4: using guessed type int dword_100531D4;
// 100531D8: using guessed type int dword_100531D8;
// 100531DC: using guessed type int dword_100531DC;
// 100531E0: using guessed type int dword_100531E0;
// 100531E8: using guessed type int dword_100531E8;
// 100531EC: using guessed type int dword_100531EC;
// 100531F0: using guessed type char byte_100531F0;
// 10053214: using guessed type int dword_10053214;
// 10053218: using guessed type int dword_10053218;
// 10004040: using guessed type char var_1C[4];

//----- (100042E0) --------------------------------------------------------
_BYTE *__userpurge sub_100042E0@<eax>(_BYTE *a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  _BYTE *v8; // eax
  bool v9; // al
  _BYTE *v10; // eax
  struct std::_Facet_base *v11; // edi
  void (__thiscall ***v12)(_DWORD, int); // eax
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v17; // [esp-4Ch] [ebp-58h]
  _DWORD v18[2]; // [esp-48h] [ebp-54h] BYREF
  int *v19; // [esp-40h] [ebp-4Ch]
  int v20[3]; // [esp-38h] [ebp-44h] BYREF
  bool v21; // [esp-2Ch] [ebp-38h]
  int v22; // [esp-28h] [ebp-34h]
  int v23; // [esp-24h] [ebp-30h] BYREF
  struct std::_Facet_base *v24; // [esp-20h] [ebp-2Ch]
  _BYTE *v25; // [esp-1Ch] [ebp-28h]
  int *v26; // [esp-14h] [ebp-20h]
  _DWORD *v27; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v29; // [esp-8h] [ebp-14h]
  int v30; // [esp-4h] [ebp-10h]
  int v31; // [esp+0h] [ebp-Ch]
  int v32; // [esp+4h] [ebp-8h]
  int v33; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v31 = a2;
  v32 = retaddr;
  v30 = -1;
  v29 = &loc_1003C42D;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v26 = &v33;
  v19 = &v33;
  LOBYTE(v4) = 0;
  v27 = v18;
  v25 = a1;
  v5 = *(_DWORD *)a1;
  v22 = 0;
  v20[2] = (int)a1;
  v6 = *(_DWORD *)&a1[*(_DWORD *)(v5 + 4) + 56];
  if ( v6 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
  v30 = 0;
  v7 = *(_DWORD *)a1;
  v8 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  if ( *((_DWORD *)v8 + 3) )
  {
    v9 = 0;
  }
  else
  {
    v10 = (_BYTE *)*((_DWORD *)v8 + 15);
    if ( !v10 || v10 == a1 )
    {
      v9 = 1;
    }
    else
    {
      sub_10002290(v10);
      v7 = *(_DWORD *)a1;
      v9 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] == 0;
    }
  }
  v21 = v9;
  v30 = 1;
  if ( v9 )
  {
    v11 = *(struct std::_Facet_base **)(*(_DWORD *)&a1[*(_DWORD *)(v7 + 4) + 48] + 4);
    v24 = v11;
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v11 + 4))(v11);
    LOBYTE(v30) = 2;
    v24 = sub_100066A0((int)&v23);
    if ( v11 )
    {
      v12 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v11 + 8))(v11);
      if ( v12 )
        (**v12)(v12, 1);
    }
    LOBYTE(v30) = 3;
    v13 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v14 = (int)&a1[v13];
    LOBYTE(v20[0]) = 0;
    v17 = *(_DWORD *)&a1[v13 + 56];
    LOBYTE(v13) = a1[v13 + 64];
    v4 = *(_BYTE *)sub_10005050(v24, (int)v20, v14, v13, a3, v20[0], v17) != 0 ? 4 : 0;
    v30 = 1;
  }
  sub_10001870(
    &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)],
    v4 | a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] | (*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56] != 0 ? 0 : 4),
    0);
  if ( !(unsigned __int8)j____uncaught_exception(v18[0], v18[1], v19) )
    sub_100023A0(a1);
  v30 = 5;
  v15 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
  if ( v15 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 8))(v15);
  return a1;
}
// 100042E0: could not find valid save-restore pair for ebp
// 1001BDB7: using guessed type int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD);

//----- (100044D0) --------------------------------------------------------
void __thiscall sub_100044D0(struct std::ios_base *this)
{
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
}
// 1004A8C0: using guessed type void *std::ios_base::`vftable';

//----- (10004520) --------------------------------------------------------
void __thiscall sub_10004520(void **this)
{
  if ( *this )
    free(*this);
  *this = 0;
}

//----- (10004570) --------------------------------------------------------
_DWORD *__thiscall sub_10004570(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
  return this;
}

//----- (10004590) --------------------------------------------------------
void *__thiscall sub_10004590(void *Block, char a2)
{
  sub_10003C40((int)Block);
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}

//----- (100045C0) --------------------------------------------------------
_DWORD *__thiscall sub_100045C0(_DWORD *Block, char a2)
{
  _DWORD *v3; // edi
  int v4; // ecx
  void (__thiscall ***v5)(_DWORD, int); // eax

  v3 = (_DWORD *)Block[13];
  *Block = &std::streambuf::`vftable';
  if ( v3 )
  {
    v4 = v3[1];
    if ( v4 )
    {
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 8))(v4);
      if ( v5 )
        (**v5)(v5, 1);
    }
    sub_1001D481(v3);
  }
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A880: using guessed type void *std::streambuf::`vftable';

//----- (10004610) --------------------------------------------------------
char *__thiscall sub_10004610(struct std::ios_base *this, char a2)
{
  char *v3; // edi

  v3 = (char *)this - 104;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 104) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)this - 26) + 4)
                                                                            - 104;
  sub_10003C40((int)this - 100);
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 104) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)this - 26) + 4)
                                                                            - 8;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_1001D481(v3);
  return v3;
}
// 1004A8C0: using guessed type void *std::ios_base::`vftable';
// 1004A908: using guessed type void *std::ofstream::`vftable';
// 1004A918: using guessed type void *std::ostream::`vftable';

//----- (100046B0) --------------------------------------------------------
char *__thiscall sub_100046B0(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_1001D481(v2);
  return v2;
}
// 1004A8C0: using guessed type void *std::ios_base::`vftable';
// 1004A918: using guessed type void *std::ostream::`vftable';

//----- (10004730) --------------------------------------------------------
_DWORD *__thiscall sub_10004730(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        __int64 *a5,
        unsigned __int8 a6,
        const void *ArgList)
{
  int v8; // eax
  char Buffer[64]; // [esp+8h] [ebp-40h] BYREF

  v8 = sub_10002460(Buffer, 0x40u, "%p", ArgList);
  sub_10005590((int)this, a2, a3, a4, a5, a6, Buffer, v8);
  return a2;
}

//----- (10004780) --------------------------------------------------------
_DWORD *__thiscall sub_10004780(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7)
{
  size_t v7; // edx
  unsigned int v8; // ebx
  int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // esi
  size_t v12; // esi
  size_t v13; // edi
  char *v14; // esi
  int v15; // edi
  char *v16; // eax
  char *v17; // ecx
  int v18; // eax
  char *v19; // ecx
  char *v20; // edx
  size_t v22; // [esp-4h] [ebp-4Ch]
  char Buffer[4]; // [esp+Ch] [ebp-3Ch] BYREF
  int v24; // [esp+10h] [ebp-38h]
  int v25; // [esp+14h] [ebp-34h]
  int v26; // [esp+18h] [ebp-30h]
  size_t BufferCount; // [esp+1Ch] [ebp-2Ch]
  unsigned int v28; // [esp+20h] [ebp-28h]
  char v29[8]; // [esp+24h] [ebp-24h] BYREF
  int v30; // [esp+2Ch] [ebp-1Ch]
  double v31; // [esp+30h] [ebp-18h] BYREF
  char ArgList[4]; // [esp+38h] [ebp-10h]
  int v33; // [esp+44h] [ebp-4h]

  v30 = (int)this;
  v7 = 0;
  *(_DWORD *)Buffer = 0;
  v8 = 15;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  BufferCount = 0;
  v28 = 15;
  v33 = 0;
  v9 = *(_DWORD *)(a5 + 20) & 0x3000;
  if ( v9 == 12288 )
  {
    v10 = 13;
    *(_DWORD *)ArgList = -1;
    HIDWORD(v31) = -1;
    goto LABEL_14;
  }
  v11 = *(_DWORD *)(a5 + 28);
  *(_DWORD *)ArgList = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v11, *(unsigned int *)ArgList) <= 0 )
  {
    if ( v11 | *(_DWORD *)ArgList )
    {
      v10 = 6;
    }
    else
    {
      if ( !v9 )
      {
        v10 = 1;
        goto LABEL_14;
      }
      v10 = 0;
    }
  }
  else
  {
    v10 = *(_DWORD *)ArgList;
  }
  if ( v9 == 0x2000 )
  {
    v31 = fabs(a7);
    if ( v31 > 1.0e10 )
    {
      frexp(a7, (int *)&v31 + 1);
      v10 += (int)(30103 * abs32(SHIDWORD(v31))) / 100000;
    }
    v7 = BufferCount;
    v8 = v28;
  }
LABEL_14:
  v12 = v10 + 50;
  if ( v12 > v7 )
  {
    v13 = v12 - v7;
    if ( v12 - v7 > v8 - v7 )
    {
      BYTE4(v31) = 0;
      sub_10006BA0((void **)Buffer, v12 - v7, SHIDWORD(v31), v12 - v7, 0);
    }
    else
    {
      BufferCount = v12;
      v22 = v12 - v7;
      v14 = &Buffer[v7];
      memset(&Buffer[v7], 0, v22);
      v14[v13] = 0;
    }
  }
  else
  {
    BufferCount = v12;
    Buffer[v12] = 0;
  }
  v15 = v30;
  v16 = sub_10005DA0(v30, v29, 76, *(_DWORD *)(a5 + 20));
  v17 = Buffer;
  if ( v28 >= 0x10 )
    v17 = *(char **)Buffer;
  v18 = sub_10002460(v17, BufferCount, v16, *(_DWORD *)ArgList, a7);
  v19 = Buffer;
  if ( v28 >= 0x10 )
    v19 = *(char **)Buffer;
  sub_10005970(v15, a2, a3, a4, (__int64 *)a5, a6, v19, v18);
  if ( v28 >= 0x10 )
  {
    v20 = *(char **)Buffer;
    if ( v28 + 1 >= 0x1000 )
    {
      v20 = *(char **)(*(_DWORD *)Buffer - 4);
      if ( (unsigned int)(*(_DWORD *)Buffer - (_DWORD)v20 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v20);
  }
  return a2;
}
// 10004893: conditional instruction was optimized away because ebx.4==F
// 100048B6: conditional instruction was optimized away because ebx.4==F
// 10004780: using guessed type char var_24[8];

//----- (100049A0) --------------------------------------------------------
_DWORD *__thiscall sub_100049A0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7)
{
  size_t v7; // edx
  unsigned int v8; // ebx
  int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // esi
  size_t v12; // esi
  size_t v13; // edi
  char *v14; // esi
  int v15; // edi
  char *v16; // eax
  char *v17; // ecx
  int v18; // eax
  char *v19; // ecx
  char *v20; // edx
  size_t v22; // [esp-4h] [ebp-4Ch]
  char Buffer[4]; // [esp+Ch] [ebp-3Ch] BYREF
  int v24; // [esp+10h] [ebp-38h]
  int v25; // [esp+14h] [ebp-34h]
  int v26; // [esp+18h] [ebp-30h]
  size_t BufferCount; // [esp+1Ch] [ebp-2Ch]
  unsigned int v28; // [esp+20h] [ebp-28h]
  char v29[8]; // [esp+24h] [ebp-24h] BYREF
  int v30; // [esp+2Ch] [ebp-1Ch]
  int Y; // [esp+34h] [ebp-14h] BYREF
  char ArgList[4]; // [esp+38h] [ebp-10h]
  int v33; // [esp+44h] [ebp-4h]

  v30 = (int)this;
  v7 = 0;
  *(_DWORD *)Buffer = 0;
  v8 = 15;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  BufferCount = 0;
  v28 = 15;
  v33 = 0;
  v9 = *(_DWORD *)(a5 + 20) & 0x3000;
  if ( v9 == 12288 )
  {
    v10 = 13;
    *(_DWORD *)ArgList = -1;
    Y = -1;
    goto LABEL_14;
  }
  v11 = *(_DWORD *)(a5 + 28);
  *(_DWORD *)ArgList = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v11, *(unsigned int *)ArgList) <= 0 )
  {
    if ( v11 | *(_DWORD *)ArgList )
    {
      v10 = 6;
    }
    else
    {
      if ( !v9 )
      {
        v10 = 1;
        goto LABEL_14;
      }
      v10 = 0;
    }
  }
  else
  {
    v10 = *(_DWORD *)ArgList;
  }
  if ( v9 == 0x2000 )
  {
    if ( fabs(a7) > 1.0e10 )
    {
      frexp(a7, &Y);
      v10 += (int)(30103 * abs32(Y)) / 100000;
    }
    v7 = BufferCount;
    v8 = v28;
  }
LABEL_14:
  v12 = v10 + 50;
  if ( v12 > v7 )
  {
    v13 = v12 - v7;
    if ( v12 - v7 > v8 - v7 )
    {
      LOBYTE(Y) = 0;
      sub_10006BA0((void **)Buffer, v12 - v7, Y, v12 - v7, 0);
    }
    else
    {
      BufferCount = v12;
      v22 = v12 - v7;
      v14 = &Buffer[v7];
      memset(&Buffer[v7], 0, v22);
      v14[v13] = 0;
    }
  }
  else
  {
    BufferCount = v12;
    Buffer[v12] = 0;
  }
  v15 = v30;
  v16 = sub_10005DA0(v30, v29, 0, *(_DWORD *)(a5 + 20));
  v17 = Buffer;
  if ( v28 >= 0x10 )
    v17 = *(char **)Buffer;
  v18 = sub_10002460(v17, BufferCount, v16, *(_DWORD *)ArgList, a7);
  v19 = Buffer;
  if ( v28 >= 0x10 )
    v19 = *(char **)Buffer;
  sub_10005970(v15, a2, a3, a4, (__int64 *)a5, a6, v19, v18);
  if ( v28 >= 0x10 )
  {
    v20 = *(char **)Buffer;
    if ( v28 + 1 >= 0x1000 )
    {
      v20 = *(char **)(*(_DWORD *)Buffer - 4);
      if ( (unsigned int)(*(_DWORD *)Buffer - (_DWORD)v20 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v20);
  }
  return a2;
}
// 10004AAD: conditional instruction was optimized away because ebx.4==F
// 10004AD0: conditional instruction was optimized away because ebx.4==F
// 100049A0: using guessed type char var_24[8];

//----- (10004BC0) --------------------------------------------------------
_DWORD *__thiscall sub_10004BC0(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        int a5,
        unsigned __int8 a6,
        int ArgList,
        int a8)
{
  char *v8; // eax
  int v10; // edx
  int v11; // ecx
  char v12; // dl
  int v13; // eax
  char Format; // [esp+8h] [ebp-48h] BYREF
  char v16; // [esp+9h] [ebp-47h] BYREF
  char v17; // [esp+Ah] [ebp-46h] BYREF
  char Buffer[64]; // [esp+10h] [ebp-40h] BYREF

  v8 = &v16;
  Format = 37;
  v10 = *(_DWORD *)(a5 + 20);
  if ( (v10 & 0x20) != 0 )
  {
    v16 = 43;
    v8 = &v17;
  }
  if ( (v10 & 8) != 0 )
    *v8++ = 35;
  *(_WORD *)v8 = 13897;
  v11 = v10 & 0xE00;
  v8[2] = 52;
  if ( v11 == 1024 )
  {
    v12 = 111;
  }
  else if ( v11 == 2048 )
  {
    v12 = ~(8 * v10) & 0x20 | 0x58;
  }
  else
  {
    v12 = 117;
  }
  v8[3] = v12;
  v8[4] = 0;
  v13 = sub_10002460(Buffer, 0x40u, &Format, ArgList, a8);
  sub_10005590((int)this, a2, a3, a4, (__int64 *)a5, a6, Buffer, v13);
  return a2;
}
// 10004BC0: using guessed type _DWORD ArgList;

//----- (10004C70) --------------------------------------------------------
_DWORD *__thiscall sub_10004C70(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        int a5,
        unsigned __int8 a6,
        int ArgList,
        int a8)
{
  char *v8; // eax
  int v10; // edx
  int v11; // ecx
  char v12; // dl
  int v13; // eax
  char Format; // [esp+8h] [ebp-48h] BYREF
  char v16; // [esp+9h] [ebp-47h] BYREF
  char v17; // [esp+Ah] [ebp-46h] BYREF
  char Buffer[64]; // [esp+10h] [ebp-40h] BYREF

  v8 = &v16;
  Format = 37;
  v10 = *(_DWORD *)(a5 + 20);
  if ( (v10 & 0x20) != 0 )
  {
    v16 = 43;
    v8 = &v17;
  }
  if ( (v10 & 8) != 0 )
    *v8++ = 35;
  *(_WORD *)v8 = 13897;
  v11 = v10 & 0xE00;
  v8[2] = 52;
  if ( v11 == 1024 )
  {
    v12 = 111;
  }
  else if ( v11 == 2048 )
  {
    v12 = ~(8 * v10) & 0x20 | 0x58;
  }
  else
  {
    v12 = 100;
  }
  v8[3] = v12;
  v8[4] = 0;
  v13 = sub_10002460(Buffer, 0x40u, &Format, ArgList, a8);
  sub_10005590((int)this, a2, a3, a4, (__int64 *)a5, a6, Buffer, v13);
  return a2;
}
// 10004C70: using guessed type _DWORD ArgList;

//----- (10004D20) --------------------------------------------------------
_DWORD *__thiscall sub_10004D20(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList)
{
  char *v7; // edx
  int v9; // eax
  int v10; // ecx
  char v11; // al
  int v12; // eax
  char Format; // [esp+8h] [ebp-48h] BYREF
  char v15; // [esp+9h] [ebp-47h] BYREF
  char v16; // [esp+Ah] [ebp-46h] BYREF
  char Buffer[64]; // [esp+10h] [ebp-40h] BYREF

  v7 = &v15;
  Format = 37;
  v9 = *(_DWORD *)(a5 + 20);
  if ( (v9 & 0x20) != 0 )
  {
    v15 = 43;
    v7 = &v16;
  }
  if ( (v9 & 8) != 0 )
    *v7++ = 35;
  *v7 = 108;
  v10 = v9 & 0xE00;
  if ( v10 == 1024 )
  {
    v11 = 111;
  }
  else if ( v10 == 2048 )
  {
    v11 = ~(8 * v9) & 0x20 | 0x58;
  }
  else
  {
    v11 = 117;
  }
  v7[1] = v11;
  v7[2] = 0;
  v12 = sub_10002460(Buffer, 0x40u, &Format, ArgList);
  sub_10005590((int)this, a2, a3, a4, (__int64 *)a5, a6, Buffer, v12);
  return a2;
}

//----- (10004DC0) --------------------------------------------------------
_DWORD *__thiscall sub_10004DC0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, int ArgList)
{
  char *v7; // edx
  int v9; // eax
  int v10; // ecx
  char v11; // al
  int v12; // eax
  char Format; // [esp+8h] [ebp-48h] BYREF
  char v15; // [esp+9h] [ebp-47h] BYREF
  char v16; // [esp+Ah] [ebp-46h] BYREF
  char Buffer[64]; // [esp+10h] [ebp-40h] BYREF

  v7 = &v15;
  Format = 37;
  v9 = *(_DWORD *)(a5 + 20);
  if ( (v9 & 0x20) != 0 )
  {
    v15 = 43;
    v7 = &v16;
  }
  if ( (v9 & 8) != 0 )
    *v7++ = 35;
  *v7 = 108;
  v10 = v9 & 0xE00;
  if ( v10 == 1024 )
  {
    v11 = 111;
  }
  else if ( v10 == 2048 )
  {
    v11 = ~(8 * v9) & 0x20 | 0x58;
  }
  else
  {
    v11 = 100;
  }
  v7[1] = v11;
  v7[2] = 0;
  v12 = sub_10002460(Buffer, 0x40u, &Format, ArgList);
  sub_10005590((int)this, a2, a3, a4, (__int64 *)a5, a6, Buffer, v12);
  return a2;
}

//----- (10004E60) --------------------------------------------------------
_DWORD *__userpurge sub_10004E60@<eax>(
        int a1@<ecx>,
        int a2@<edi>,
        _DWORD *a3,
        int a4,
        _DWORD *a5,
        _DWORD *a6,
        int a7,
        unsigned __int8 a8)
{
  int v10; // esi
  struct std::_Facet_base *v11; // edi
  void (__thiscall ***v12)(_DWORD, int); // eax
  int v13; // eax
  bool v14; // sf
  bool v15; // cc
  unsigned __int8 *v16; // edi
  unsigned int v17; // esi
  int v18; // esi
  int *v19; // eax
  int v20; // ecx
  _DWORD *v21; // eax
  unsigned __int8 *v22; // edx
  int *v23; // eax
  unsigned __int8 *v24; // eax
  int v25; // [esp-34h] [ebp-84h]
  void *Block[4]; // [esp+8h] [ebp-48h] BYREF
  unsigned int v27; // [esp+18h] [ebp-38h]
  unsigned int v28; // [esp+1Ch] [ebp-34h]
  void *v29; // [esp+20h] [ebp-30h] BYREF
  void *v30; // [esp+24h] [ebp-2Ch]
  void *v31; // [esp+28h] [ebp-28h]
  void *v32; // [esp+2Ch] [ebp-24h]
  unsigned int v33; // [esp+30h] [ebp-20h]
  unsigned int v34; // [esp+34h] [ebp-1Ch]
  int v35; // [esp+38h] [ebp-18h] BYREF
  int v36; // [esp+3Ch] [ebp-14h]
  int v37; // [esp+40h] [ebp-10h]
  int v38; // [esp+4Ch] [ebp-4h]
  int v39; // [esp+5Ch] [ebp+Ch]
  _DWORD *v40; // [esp+60h] [ebp+10h]
  int v41; // [esp+64h] [ebp+14h]
  unsigned int v42; // [esp+6Ch] [ebp+1Ch]

  v37 = a1;
  if ( (a6[5] & 0x4000) != 0 )
  {
    v36 = *(_DWORD *)(a6[12] + 4);
    v10 = v36;
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v10 + 4))(v10, a2);
    v38 = 0;
    v11 = sub_100067C0((int)&v35);
    if ( v10 )
    {
      v12 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
      if ( v12 )
        (**v12)(v12, 1);
    }
    v34 = 15;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v38 = 1;
    v13 = *(_DWORD *)v11;
    if ( a8 )
      (*(void (__thiscall **)(struct std::_Facet_base *, void **))(v13 + 28))(v11, Block);
    else
      (*(void (__thiscall **)(struct std::_Facet_base *))(v13 + 24))(v11);
    v14 = (int)a6[9] < 0;
    v15 = a6[9] <= 0;
    v16 = (unsigned __int8 *)Block[0];
    v17 = a6[8];
    v30 = Block[1];
    v31 = Block[2];
    v32 = Block[3];
    v34 = v28;
    v42 = v28;
    v33 = v27;
    v41 = v27;
    v29 = Block[0];
    if ( v14 || v15 && !v17 || v17 <= v27 )
      v18 = 0;
    else
      v18 = v17 - v27;
    if ( (a6[5] & 0x1C0) == 64 )
    {
      v21 = a5;
      v20 = a4;
    }
    else
    {
      v19 = sub_100054B0(v37, &v35, a4, a5, a7, v18);
      v18 = 0;
      v20 = *v19;
      v21 = (_DWORD *)v19[1];
    }
    v22 = (unsigned __int8 *)&v29;
    if ( v42 >= 0x10 )
      v22 = v16;
    v23 = sub_10005520(v37, &v35, v20, v21, v22, v41);
    v25 = v37;
    v39 = *v23;
    v40 = (_DWORD *)v23[1];
    a6[8] = 0;
    a6[9] = 0;
    sub_100054B0(v25, a3, v39, v40, a7, v18);
    if ( v42 >= 0x10 )
    {
      v24 = v16;
      if ( v42 + 1 >= 0x1000 )
      {
        v16 = (unsigned __int8 *)*((_DWORD *)v16 - 1);
        if ( (unsigned int)(v24 - v16 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_1001D481(v16);
    }
    return a3;
  }
  else
  {
    (*(void (__thiscall **)(int, _DWORD *, int, _DWORD *, _DWORD *, int, _DWORD))(*(_DWORD *)a1 + 36))(
      a1,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8);
    return a3;
  }
}

//----- (10005050) --------------------------------------------------------
int __thiscall sub_10005050(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  (*(void (__thiscall **)(void *, int, int, int, int, int, int))(*(_DWORD *)this + 32))(this, a2, a6, a7, a3, a4, a5);
  return a2;
}

//----- (10005080) --------------------------------------------------------
unsigned int __stdcall sub_10005080(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int result; // eax

  result = a3 - a2;
  if ( a3 - a2 >= a4 )
    return a4;
  return result;
}

//----- (100050A0) --------------------------------------------------------
int __stdcall sub_100050A0(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = a2;
  return 3;
}

//----- (100050C0) --------------------------------------------------------
int __stdcall sub_100050C0(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7)
{
  *a4 = a2;
  *a7 = a5;
  return 3;
}

//----- (100050E0) --------------------------------------------------------
char sub_100050E0()
{
  return 1;
}

//----- (100050F0) --------------------------------------------------------
_DWORD *__thiscall sub_100050F0(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // edi
  _DWORD *v6; // ecx
  _DWORD *v7; // ebx
  _DWORD *v8; // esi
  _DWORD *v9; // edx

  result = (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 12))(a2);
  if ( (_BYTE)result )
  {
    this[14] = 0;
  }
  else
  {
    v4 = this;
    v5 = this + 5;
    v6 = this + 6;
    this[14] = a2;
    v7 = this + 1;
    v4[3] = v7;
    v8 = v4 + 2;
    v4[4] = v4 + 2;
    v9 = v4 + 9;
    v4[7] = v5;
    v4[8] = v6;
    v4[11] = v4 + 9;
    result = v4 + 10;
    this[12] = result;
    *v8 = 0;
    *v6 = 0;
    *result = 0;
    *v7 = 0;
    *v5 = 0;
    *v9 = 0;
  }
  return result;
}

//----- (10005180) --------------------------------------------------------
bool __thiscall sub_10005180(void *this)
{
  int v2; // eax
  int v3; // eax
  int v5; // edi
  char Buffer[32]; // [esp+4h] [ebp-24h] BYREF
  char *v7; // [esp+24h] [ebp-4h] BYREF

  if ( *((_DWORD *)this + 14) && *((_BYTE *)this + 61) )
  {
    if ( (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 12))(this, -1) != -1 )
    {
      v2 = (*(int (__thiscall **)(_DWORD, int, char *, char **, char **))(**((_DWORD **)this + 14) + 32))(
             *((_DWORD *)this + 14),
             (int)this + 64,
             Buffer,
             &v7,
             &v7);
      if ( v2 )
      {
        v3 = v2 - 1;
        if ( v3 )
        {
          if ( v3 == 2 )
          {
            *((_BYTE *)this + 61) = 0;
            return 1;
          }
          return 0;
        }
      }
      else
      {
        *((_BYTE *)this + 61) = 0;
      }
      if ( v7 == Buffer )
        return *((_BYTE *)this + 61) == 0;
      v5 = v7 - Buffer;
      if ( v5 == fwrite(Buffer, 1u, v7 - Buffer, *((FILE **)this + 19)) )
        return *((_BYTE *)this + 61) == 0;
    }
    return 0;
  }
  return 1;
}

//----- (10005220) --------------------------------------------------------
int __thiscall sub_10005220(int this, FILE *Stream, char **Base)
{
  int v3; // edx
  char **v4; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // ecx
  _DWORD *v8; // edi
  int v9; // ebx
  char **v10; // ebx
  FILE *v11; // esi
  _DWORD *v12; // edx
  char **v13; // eax
  FILE *v14; // eax
  int *v15; // eax
  int result; // eax
  int v17; // ecx
  int *Count; // [esp+Ch] [ebp-8h] BYREF
  _DWORD *v19; // [esp+10h] [ebp-4h]

  v3 = this;
  v19 = (_DWORD *)this;
  *(_BYTE *)(this + 72) = Base == (char **)1;
  v4 = (char **)(this + 4);
  v5 = v19;
  v6 = (_DWORD *)(this + 8);
  *(_DWORD *)(this + 12) = this + 4;
  v7 = (_DWORD *)(this + 24);
  *(_DWORD *)(v3 + 16) = v6;
  *(_BYTE *)(v3 + 61) = 0;
  *(_DWORD *)(v3 + 32) = v7;
  v8 = (_DWORD *)(v3 + 20);
  Base = v4;
  v9 = (int)v19;
  *(_DWORD *)(v3 + 28) = v3 + 20;
  v3 += 36;
  v5[11] = v3;
  v5 += 10;
  *(_DWORD *)(v9 + 48) = v5;
  v10 = Base;
  *v6 = 0;
  v11 = Stream;
  *v7 = 0;
  *v5 = 0;
  *v10 = 0;
  *v8 = 0;
  *(_DWORD *)v3 = 0;
  if ( v11 )
  {
    Base = 0;
    Stream = 0;
    Count = 0;
    _get_stream_buffer_pointers(v11, &Base, (char ***)&Stream, &Count);
    v12 = v19;
    v13 = Base;
    v19[3] = Base;
    v12[4] = v13;
    v14 = Stream;
    v12[7] = Stream;
    v12[8] = v14;
    v15 = Count;
    v12[11] = Count;
    v12[12] = v15;
  }
  else
  {
    v12 = v19;
  }
  result = dword_10053214;
  v17 = dword_10053218;
  v12[19] = v11;
  v12[16] = result;
  v12[17] = v17;
  v12[14] = 0;
  return result;
}
// 10053214: using guessed type int dword_10053214;
// 10053218: using guessed type int dword_10053218;

//----- (10005310) --------------------------------------------------------
_DWORD *__thiscall sub_10005310(_DWORD *Block, char a2)
{
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1003F318: using guessed type void *std::_Facet_base::`vftable';

//----- (10005340) --------------------------------------------------------
_DWORD *__thiscall sub_10005340(_DWORD *this, _DWORD *a2)
{
  void *v2; // edx

  v2 = (void *)this[5];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  sub_10001C50(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (100053B0) --------------------------------------------------------
_DWORD *__thiscall sub_100053B0(_DWORD *this, _DWORD *a2)
{
  void *v2; // edx

  v2 = (void *)this[4];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  sub_10001C50(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (10005420) --------------------------------------------------------
_DWORD *__thiscall sub_10005420(_DWORD *this, _DWORD *a2)
{
  void *v2; // edx

  v2 = (void *)this[2];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  sub_10001C50(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (10005490) --------------------------------------------------------
char __thiscall sub_10005490(_BYTE *this)
{
  return this[13];
}

//----- (100054A0) --------------------------------------------------------
char __thiscall sub_100054A0(_BYTE *this)
{
  return this[12];
}

//----- (100054B0) --------------------------------------------------------
_DWORD *__cdecl sub_100054B0(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 a5, int a6)
{
  _DWORD *v6; // eax
  int i; // esi
  int *v8; // ecx
  _DWORD *v9; // ecx
  unsigned __int8 *v10; // edx
  int v11; // eax
  bool v12; // zf
  _DWORD *result; // eax

  v6 = a4;
  for ( i = a6; i; --i )
  {
    if ( v6 )
    {
      if ( *(_DWORD *)v6[8] && (v8 = (int *)v6[12], *v8 > 0) )
      {
        --*v8;
        v9 = (_DWORD *)v6[8];
        v10 = (unsigned __int8 *)(*v9)++;
        *v10 = a5;
        v11 = a5;
      }
      else
      {
        v11 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v6 + 12))(v6, a5);
      }
      v12 = v11 == -1;
      v6 = a4;
      if ( !v12 )
        continue;
    }
    LOBYTE(a3) = 1;
  }
  a2[1] = v6;
  result = a2;
  *a2 = a3;
  return result;
}

//----- (10005520) --------------------------------------------------------
_DWORD *__cdecl sub_10005520(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6)
{
  _DWORD *v6; // eax
  int i; // esi
  unsigned __int8 v9; // bl
  int *v10; // ecx
  _DWORD *v11; // ecx
  unsigned __int8 *v12; // edx
  int v13; // eax
  bool v14; // zf
  _DWORD *result; // eax

  v6 = a4;
  for ( i = a6; i; --i )
  {
    if ( !v6 )
      goto LABEL_8;
    v9 = *a5;
    if ( *(_DWORD *)v6[8] && (v10 = (int *)v6[12], *v10 > 0) )
    {
      --*v10;
      v11 = (_DWORD *)v6[8];
      v12 = (unsigned __int8 *)(*v11)++;
      *v12 = v9;
      v13 = v9;
    }
    else
    {
      v13 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v6 + 12))(v6, v9);
    }
    v14 = v13 == -1;
    v6 = a4;
    if ( v14 )
LABEL_8:
      LOBYTE(a3) = 1;
    ++a5;
  }
  a2[1] = v6;
  result = a2;
  *a2 = a3;
  return result;
}

//----- (10005590) --------------------------------------------------------
_DWORD *__cdecl sub_10005590(
        int a1,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        __int64 *a5,
        unsigned __int8 a6,
        _BYTE *Val,
        size_t Size)
{
  size_t v8; // edi
  int v9; // esi
  int v10; // eax
  char v11; // cl
  int v12; // ebx
  void (__thiscall ***v13)(_DWORD, int); // eax
  void **v14; // ecx
  struct std::_Facet_base *v15; // eax
  struct std::_Facet_base *v16; // ebx
  void (__thiscall ***v17)(_DWORD, int); // eax
  void **v18; // ebx
  char v19; // al
  char v20; // cl
  unsigned int v21; // ecx
  void **v22; // eax
  char *v23; // esi
  unsigned int v24; // esi
  int v25; // esi
  int v26; // eax
  int v27; // ebx
  int *v28; // eax
  int v29; // ecx
  _DWORD *v30; // edx
  unsigned __int8 *v31; // eax
  int v32; // edi
  int *v33; // eax
  unsigned __int8 *v34; // eax
  int *v35; // eax
  unsigned __int8 *v36; // eax
  void **v37; // ecx
  int *v38; // eax
  void *v39; // edx
  void *v40; // edx
  void *Block[5]; // [esp+Ch] [ebp-44h] BYREF
  unsigned int v43; // [esp+20h] [ebp-30h]
  void *Src[4]; // [esp+24h] [ebp-2Ch] BYREF
  unsigned int v45; // [esp+34h] [ebp-1Ch]
  unsigned int v46; // [esp+38h] [ebp-18h]
  int v47; // [esp+3Ch] [ebp-14h] BYREF
  int v48; // [esp+40h] [ebp-10h]
  int v49; // [esp+4Ch] [ebp-4h]
  int v50; // [esp+60h] [ebp+10h]
  _DWORD *v51; // [esp+64h] [ebp+14h]
  int Vala; // [esp+70h] [ebp+20h]
  char Valb; // [esp+70h] [ebp+20h]
  int Valc; // [esp+70h] [ebp+20h]
  int Sizea; // [esp+74h] [ebp+24h]

  v8 = Size;
  v9 = Size && (*Val == 43 || *Val == 45);
  Sizea = v9;
  if ( (*((_DWORD *)a5 + 5) & 0xE00) == 2048 )
  {
    v10 = v9 + 2;
    if ( v9 + 2 <= v8 && Val[v9] == 48 )
    {
      v11 = Val[v9 + 1];
      if ( v11 == 120 || v11 == 88 )
      {
        v9 += 2;
        Sizea = v10;
      }
    }
  }
  v48 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  v12 = v48;
  (*(void (__thiscall **)(int))(*(_DWORD *)v12 + 4))(v12);
  v49 = 0;
  v48 = (int)sub_10006130((int)&v47);
  v49 = -1;
  if ( v12 )
  {
    v13 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v12 + 8))(v12);
    if ( v13 )
      (**v13)(v13, 1);
  }
  sub_10005FF0(Src, v8, 0);
  v49 = 1;
  v14 = Src;
  if ( v46 >= 0x10 )
    v14 = (void **)Src[0];
  (*(void (__thiscall **)(int, _BYTE *, _BYTE *, void **))(*(_DWORD *)v48 + 28))(v48, Val, &Val[v8], v14);
  Vala = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  v48 = Vala;
  (*(void (**)(void))(*(_DWORD *)Vala + 4))();
  LOBYTE(v49) = 2;
  v15 = sub_100067C0((int)&v47);
  LOBYTE(v49) = 1;
  v16 = v15;
  v48 = (int)v15;
  if ( Vala )
  {
    v17 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)Vala + 8))(Vala);
    if ( v17 )
      (**v17)(v17, 1);
  }
  (*(void (__thiscall **)(struct std::_Facet_base *, void **))(*(_DWORD *)v16 + 20))(v16, Block);
  LOBYTE(v49) = 3;
  v18 = Block;
  if ( v43 >= 0x10 )
    v18 = (void **)Block[0];
  if ( *(_BYTE *)v18 != 127 && *(char *)v18 > 0 )
  {
    v19 = (*(int (__thiscall **)(int))(*(_DWORD *)v48 + 16))(v48);
    v20 = *(_BYTE *)v18;
    for ( Valb = v19; *(_BYTE *)v18 != 127; v20 = *(_BYTE *)v18 )
    {
      if ( v20 <= 0 || v20 >= v8 - v9 )
        break;
      v8 -= v20;
      v21 = v45;
      if ( v45 < v8 )
        sub_10006120();
      if ( v46 == v45 )
      {
        LOBYTE(v48) = 0;
        sub_10006A20((const void **)Src, 1u, v48, v8, 1u, Valb);
      }
      else
      {
        ++v45;
        v22 = Src;
        if ( v46 >= 0x10 )
          v22 = (void **)Src[0];
        v23 = (char *)v22 + v8;
        memmove((char *)v22 + v8 + 1, (char *)v22 + v8, v21 - v8 + 1);
        *v23 = Valb;
        v9 = Sizea;
      }
      if ( *((char *)v18 + 1) > 0 )
        v18 = (void **)((char *)v18 + 1);
    }
  }
  Valc = v45;
  v24 = *((_DWORD *)a5 + 8);
  if ( a5[4] <= 0 || v24 <= v45 )
    v25 = 0;
  else
    v25 = v24 - v45;
  v26 = *((_DWORD *)a5 + 5) & 0x1C0;
  if ( v26 == 64 )
  {
    v36 = (unsigned __int8 *)Src;
    if ( v46 >= 0x10 )
      v36 = (unsigned __int8 *)Src[0];
    v32 = Sizea;
    v27 = a1;
    v33 = sub_10005520(a1, &v47, a3, a4, v36, Sizea);
  }
  else if ( v26 == 256 )
  {
    v34 = (unsigned __int8 *)Src;
    if ( v46 >= 0x10 )
      v34 = (unsigned __int8 *)Src[0];
    v32 = Sizea;
    v27 = a1;
    v35 = sub_10005520(a1, &v47, a3, a4, v34, Sizea);
    v33 = sub_100054B0(a1, &v47, *v35, (_DWORD *)v35[1], a6, v25);
    v25 = 0;
  }
  else
  {
    v27 = a1;
    v28 = sub_100054B0(a1, &v47, a3, a4, a6, v25);
    v25 = 0;
    v29 = *v28;
    v30 = (_DWORD *)v28[1];
    v31 = (unsigned __int8 *)Src;
    if ( v46 >= 0x10 )
      v31 = (unsigned __int8 *)Src[0];
    v32 = Sizea;
    v33 = sub_10005520(a1, &v47, v29, v30, v31, Sizea);
  }
  v37 = Src;
  if ( v46 >= 0x10 )
    v37 = (void **)Src[0];
  v38 = sub_10005520(v27, &v47, *v33, (_DWORD *)v33[1], (unsigned __int8 *)v37 + v32, Valc - v32);
  v50 = *v38;
  v51 = (_DWORD *)v38[1];
  *((_DWORD *)a5 + 8) = 0;
  *((_DWORD *)a5 + 9) = 0;
  sub_100054B0(v27, a2, v50, v51, a6, v25);
  if ( v43 >= 0x10 )
  {
    v39 = Block[0];
    if ( v43 + 1 >= 0x1000 )
    {
      v39 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v39 - 4) > 0x1F )
        goto LABEL_63;
    }
    sub_1001D481(v39);
  }
  Block[4] = 0;
  v43 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v46 >= 0x10 )
  {
    v40 = Src[0];
    if ( v46 + 1 < 0x1000 || (v40 = (void *)*((_DWORD *)Src[0] - 1), (unsigned int)(Src[0] - v40 - 4) <= 0x1F) )
    {
      sub_1001D481(v40);
      return a2;
    }
LABEL_63:
    _invalid_parameter_noinfo_noreturn();
  }
  return a2;
}
// 10006120: using guessed type void __noreturn sub_10006120(void);

//----- (10005970) --------------------------------------------------------
_DWORD *__cdecl sub_10005970(
        int a1,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        __int64 *a5,
        unsigned __int8 a6,
        char *Str,
        unsigned int Control)
{
  size_t v8; // ebx
  int v9; // esi
  const char *v10; // edx
  int v11; // eax
  char v12; // cl
  _DWORD *v13; // edi
  struct std::_Facet_base *v14; // eax
  void (__thiscall ***v15)(_DWORD, int); // eax
  void **v16; // ecx
  struct std::_Facet_base *v17; // ecx
  void (__thiscall ***v18)(_DWORD, int); // eax
  char v19; // al
  void **v20; // ecx
  void **v21; // ebx
  char i; // al
  unsigned int v23; // ecx
  void **v24; // eax
  _BYTE *v25; // esi
  unsigned int v26; // edi
  int v27; // edi
  int v28; // eax
  int v29; // ebx
  int *v30; // eax
  int v31; // ecx
  _DWORD *v32; // edx
  unsigned __int8 *v33; // eax
  int *v34; // eax
  unsigned __int8 *v35; // eax
  int *v36; // eax
  unsigned __int8 *v37; // eax
  void **v38; // ecx
  int v39; // edx
  int *v40; // eax
  void *v41; // edx
  void *v42; // edx
  int v44; // [esp-28h] [ebp-88h]
  void *Block[5]; // [esp+Ch] [ebp-54h] BYREF
  unsigned int v46; // [esp+20h] [ebp-40h]
  void *Src[4]; // [esp+24h] [ebp-3Ch] BYREF
  unsigned int v48; // [esp+34h] [ebp-2Ch]
  unsigned int v49; // [esp+38h] [ebp-28h]
  int v50; // [esp+3Ch] [ebp-24h] BYREF
  _DWORD *v51; // [esp+40h] [ebp-20h]
  int v52; // [esp+44h] [ebp-1Ch]
  char v53[4]; // [esp+48h] [ebp-18h] BYREF
  int Val; // [esp+4Ch] [ebp-14h]
  int v55; // [esp+50h] [ebp-10h]
  int v56; // [esp+5Ch] [ebp-4h]
  _DWORD *v57; // [esp+74h] [ebp+14h]
  char *Stra; // [esp+80h] [ebp+20h]
  char *Strb; // [esp+80h] [ebp+20h]

  v8 = Control;
  v9 = Control && (*Str == 43 || *Str == 45);
  v55 = v9;
  if ( (*((_DWORD *)a5 + 5) & 0x3000) == 12288 )
  {
    v11 = v9 + 2;
    v10 = "pP";
    if ( v9 + 2 <= Control && Str[v9] == 48 )
    {
      v12 = Str[v9 + 1];
      if ( v12 == 120 || v12 == 88 )
      {
        v9 += 2;
        v55 = v11;
      }
    }
  }
  else
  {
    v10 = "eE";
  }
  v51 = (_DWORD *)strcspn(Str, v10);
  LOWORD(Control) = 46;
  LOBYTE(Control) = *localeconv()->decimal_point;
  v13 = (_DWORD *)strcspn(Str, (const char *)&Control);
  v52 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  Val = v52;
  (*(void (__thiscall **)(int))(*(_DWORD *)v52 + 4))(v52);
  v56 = 0;
  v14 = sub_10006130((int)v53);
  v56 = -1;
  Val = (int)v14;
  if ( v52 )
  {
    v15 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v52 + 8))(v52);
    if ( v15 )
      (**v15)(v15, 1);
  }
  sub_10005FF0(Src, v8, 0);
  v56 = 1;
  v16 = Src;
  if ( v49 >= 0x10 )
    v16 = (void **)Src[0];
  (*(void (__thiscall **)(int, char *, char *, void **))(*(_DWORD *)Val + 28))(Val, Str, &Str[v8], v16);
  v52 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  Val = v52;
  (*(void (**)(void))(*(_DWORD *)v52 + 4))();
  LOBYTE(v56) = 2;
  v17 = sub_100067C0((int)v53);
  LOBYTE(v56) = 1;
  Stra = (char *)v17;
  if ( v52 )
  {
    v18 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v52 + 8))(v52);
    if ( v18 )
      (**v18)(v18, 1);
    v17 = (struct std::_Facet_base *)Stra;
  }
  (*(void (__thiscall **)(struct std::_Facet_base *, void **))(*(_DWORD *)v17 + 20))(v17, Block);
  LOBYTE(v56) = 3;
  LOBYTE(Val) = (*(int (__thiscall **)(char *))(*(_DWORD *)Stra + 16))(Stra);
  if ( v13 == (_DWORD *)v8 )
  {
    v13 = v51;
  }
  else
  {
    v19 = (*(int (__thiscall **)(char *))(*(_DWORD *)Stra + 12))(Stra);
    v20 = Src;
    if ( v49 >= 0x10 )
      v20 = (void **)Src[0];
    *((_BYTE *)v13 + (_DWORD)v20) = v19;
  }
  v21 = Block;
  if ( v46 >= 0x10 )
    v21 = (void **)Block[0];
  for ( i = *(_BYTE *)v21; *(_BYTE *)v21 != 127; i = *(_BYTE *)v21 )
  {
    if ( i <= 0 || i >= (unsigned int)v13 - v9 )
      break;
    v13 = (_DWORD *)((char *)v13 - i);
    v23 = v48;
    if ( v48 < (unsigned int)v13 )
      sub_10006120();
    if ( v49 == v48 )
    {
      LOBYTE(Stra) = 0;
      sub_10006A20((const void **)Src, 1u, (int)Stra, (size_t)v13, 1u, Val);
    }
    else
    {
      ++v48;
      v24 = Src;
      if ( v49 >= 0x10 )
        v24 = (void **)Src[0];
      v25 = (char *)v13 + (_DWORD)v24;
      memmove((char *)v13 + (_DWORD)v24 + 1, (char *)v13 + (_DWORD)v24, v23 - (_DWORD)v13 + 1);
      *v25 = Val;
      v9 = v55;
    }
    if ( *((char *)v21 + 1) > 0 )
      v21 = (void **)((char *)v21 + 1);
  }
  Strb = (char *)v48;
  v26 = *((_DWORD *)a5 + 8);
  if ( a5[4] <= 0 || v26 <= v48 )
    v27 = 0;
  else
    v27 = v26 - v48;
  v28 = *((_DWORD *)a5 + 5) & 0x1C0;
  if ( v28 == 64 )
  {
    v37 = (unsigned __int8 *)Src;
    if ( v49 >= 0x10 )
      v37 = (unsigned __int8 *)Src[0];
    v29 = a1;
    v34 = sub_10005520(a1, &v50, a3, a4, v37, v9);
  }
  else if ( v28 == 256 )
  {
    v35 = (unsigned __int8 *)Src;
    if ( v49 >= 0x10 )
      v35 = (unsigned __int8 *)Src[0];
    v29 = a1;
    v36 = sub_10005520(a1, &v50, a3, a4, v35, v9);
    v34 = sub_100054B0(a1, &v50, *v36, (_DWORD *)v36[1], a6, v27);
    v27 = 0;
  }
  else
  {
    v29 = a1;
    v30 = sub_100054B0(a1, &v50, a3, a4, a6, v27);
    v27 = 0;
    v31 = *v30;
    v32 = (_DWORD *)v30[1];
    v33 = (unsigned __int8 *)Src;
    if ( v49 >= 0x10 )
      v33 = (unsigned __int8 *)Src[0];
    v34 = sub_10005520(a1, &v50, v31, v32, v33, v9);
  }
  v38 = Src;
  v39 = *v34;
  v51 = (_DWORD *)v34[1];
  if ( v49 >= 0x10 )
    v38 = (void **)Src[0];
  v40 = sub_10005520(v29, &v50, v39, v51, (unsigned __int8 *)v38 + v9, (int)&Strb[-v9]);
  v44 = *v40;
  v57 = (_DWORD *)v40[1];
  *((_DWORD *)a5 + 8) = 0;
  *((_DWORD *)a5 + 9) = 0;
  sub_100054B0(v29, a2, v44, v57, a6, v27);
  if ( v46 >= 0x10 )
  {
    v41 = Block[0];
    if ( v46 + 1 >= 0x1000 )
    {
      v41 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v41 - 4) > 0x1F )
        goto LABEL_68;
    }
    sub_1001D481(v41);
  }
  Block[4] = 0;
  v46 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v49 >= 0x10 )
  {
    v42 = Src[0];
    if ( v49 + 1 < 0x1000 || (v42 = (void *)*((_DWORD *)Src[0] - 1), (unsigned int)(Src[0] - v42 - 4) <= 0x1F) )
    {
      sub_1001D481(v42);
      return a2;
    }
LABEL_68:
    _invalid_parameter_noinfo_noreturn();
  }
  return a2;
}
// 10006120: using guessed type void __noreturn sub_10006120(void);
// 10005970: using guessed type char var_18[4];

//----- (10005DA0) --------------------------------------------------------
_BYTE *__cdecl sub_10005DA0(int a1, _BYTE *a2, char a3, __int16 a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  int v6; // ecx

  *a2 = 37;
  v4 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v4 = 43;
    v4 = a2 + 2;
  }
  if ( (a4 & 0x10) != 0 )
    *v4++ = 35;
  *(_WORD *)v4 = 10798;
  v5 = v4 + 2;
  if ( a3 )
    *v5++ = a3;
  v6 = a4 & 0x3000;
  if ( (a4 & 4) != 0 )
  {
    if ( v6 != 0x2000 )
    {
      if ( v6 == 12288 )
        *v5 = 65;
      else
        *v5 = 2 * (v6 != 4096) + 69;
      v5[1] = 0;
      return a2;
    }
LABEL_14:
    *v5 = 102;
    v5[1] = 0;
    return a2;
  }
  if ( v6 == 0x2000 )
    goto LABEL_14;
  if ( v6 == 12288 )
    *v5 = 97;
  else
    *v5 = 2 * (v6 != 4096) + 101;
  v5[1] = 0;
  return a2;
}

//----- (10005E60) --------------------------------------------------------
void **__thiscall sub_10005E60(_DWORD *this, unsigned int a2, char Val)
{
  unsigned int v3; // edx
  unsigned int v4; // ebx
  unsigned int *v5; // esi
  bool v6; // cf
  char *v7; // esi
  void **result; // eax

  v3 = a2;
  v4 = this[4];
  v5 = this + 4;
  if ( a2 > v4 )
  {
    if ( a2 - v4 > this[5] - v4 )
    {
      LOBYTE(a2) = 0;
      return sub_10006BA0((void **)this, v3 - v4, a2, v3 - v4, Val);
    }
    else
    {
      v6 = this[5] < 0x10u;
      *v5 = a2;
      if ( !v6 )
        this = (_DWORD *)*this;
      v7 = (char *)this + v4;
      result = (void **)memset((char *)this + v4, Val, a2 - v4);
      v7[a2 - v4] = 0;
    }
  }
  else
  {
    if ( this[5] >= 0x10u )
      this = (_DWORD *)*this;
    *v5 = a2;
    *((_BYTE *)this + a2) = 0;
  }
  return result;
}

//----- (10005EE0) --------------------------------------------------------
void **__thiscall sub_10005EE0(void **Block, char a2)
{
  *Block = &std::numpunct<char>::`vftable';
  free(Block[2]);
  free(Block[4]);
  free(Block[5]);
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1003F318: using guessed type void *std::_Facet_base::`vftable';
// 1003F554: using guessed type void *std::numpunct<char>::`vftable';

//----- (10005F60) --------------------------------------------------------
_DWORD *__thiscall sub_10005F60(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  if ( this != a2 )
  {
    v3 = this[5];
    if ( v3 >= 0x10 )
    {
      v4 = (_DWORD *)*this;
      if ( v3 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v4 = (_DWORD *)*(v4 - 1);
      }
      sub_1001D481(v4);
    }
    this[4] = 0;
    this[5] = 15;
    *(_BYTE *)this = 0;
    *this = *a2;
    this[1] = a2[1];
    this[2] = a2[2];
    this[3] = a2[3];
    this[4] = a2[4];
    this[5] = a2[5];
    a2[4] = 0;
    a2[5] = 15;
    *(_BYTE *)a2 = 0;
  }
  return this;
}

//----- (10005FF0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__thiscall sub_10005FF0(_DWORD *this, size_t Size, char a3)
{
  size_t v6; // edi
  size_t v7; // ecx
  void *v8; // eax
  _DWORD *v9; // ecx
  size_t Sizea; // [esp+20h] [ebp+8h]

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  if ( Size > 0x7FFFFFFF )
    sub_100012E0();
  this[5] = 15;
  if ( Size < 0x10 )
  {
    this[4] = Size;
    memset(this, a3, Size);
    *((_BYTE *)this + Size) = 0;
    return this;
  }
  v6 = Size | 0xF;
  if ( (Size | 0xF) > 0x7FFFFFFF )
  {
    v6 = 0x7FFFFFFF;
    v7 = -2147483613;
LABEL_6:
    v8 = operator new(v7);
    if ( !v8 )
      _invalid_parameter_noinfo_noreturn();
    v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
    *(v9 - 1) = v8;
    goto LABEL_16;
  }
  if ( v6 < 0x16 )
    v6 = 22;
  if ( v6 + 1 >= 0x1000 )
  {
    v7 = v6 + 36;
    if ( v6 + 36 <= v6 + 1 )
      sub_10001240();
    goto LABEL_6;
  }
  if ( v6 == -1 )
    v9 = 0;
  else
    v9 = operator new(v6 + 1);
LABEL_16:
  Sizea = (size_t)v9;
  *this = v9;
  this[4] = Size;
  this[5] = v6;
  memset(v9, a3, Size);
  *(_BYTE *)(Sizea + Size) = 0;
  return this;
}
// 10006104: bad sp value at call
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10006120) --------------------------------------------------------
void __noreturn sub_10006120()
{
  sub_1001C02E((int)"invalid string position");
}
// 10006120: using guessed type void __noreturn sub_10006120();

//----- (10006130) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_10006130(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // edx
  struct std::_Facet_base *v4; // esi
  int v5; // eax
  char v7[4]; // [esp+Ch] [ebp-18h] BYREF
  struct std::_Facet_base *v8; // [esp+10h] [ebp-14h] BYREF
  unsigned int v9; // [esp+14h] [ebp-10h] BYREF
  int v10; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
  v10 = 0;
  v1 = dword_10052428;
  v2 = dword_1005320C;
  v8 = (struct std::_Facet_base *)dword_1005320C;
  if ( !dword_10052428 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
    if ( !dword_10052428 )
      dword_10052428 = ++dword_10052410;
    std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    v1 = dword_10052428;
  }
  v9 = 4 * v1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
    v9 = 4 * v1;
  }
  else
  {
    v4 = *(struct std::_Facet_base **)(4 * v1 + *(_DWORD *)(v3 + 8));
    if ( v4 )
      goto LABEL_17;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_1001C2BD();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(struct std::_Facet_base **)(v9 + *(_DWORD *)(v5 + 8));
LABEL_12:
    if ( v4 )
      goto LABEL_17;
  }
  if ( v2 )
  {
    v4 = (struct std::_Facet_base *)v2;
  }
  else
  {
    if ( sub_10002A50(&v8, a1) == -1 )
      sub_10002860();
    v4 = v8;
    LOBYTE(v10) = 1;
    std::_Facet_Register(v8);
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v4 + 4))(v4);
    dword_1005320C = (int)v4;
  }
LABEL_17:
  std::_Lockit::~_Lockit((std::_Lockit *)v7);
  return v4;
}
// 10002860: using guessed type void __noreturn sub_10002860(void);
// 10052410: using guessed type int dword_10052410;
// 1005320C: using guessed type int dword_1005320C;
// 10006130: using guessed type char var_18[4];

//----- (10006250) --------------------------------------------------------
_BYTE *__fastcall sub_10006250(_BYTE *a1, const char *a2)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  int v8; // edi
  unsigned int v9; // esi
  int v10; // ecx
  int v11; // ecx
  _BYTE *v12; // eax
  bool v13; // al
  _BYTE *v14; // eax
  char v15; // si
  int v16; // eax
  _DWORD *v17; // ecx
  int *v18; // eax
  _DWORD *v19; // ecx
  unsigned __int8 *v20; // edx
  int v21; // eax
  int v22; // eax
  int v23; // edx
  int v24; // eax
  _DWORD *v25; // ecx
  int *v26; // eax
  _DWORD *v27; // ecx
  unsigned __int8 *v28; // edx
  int v29; // eax
  int v30; // eax
  char v31; // al
  _BYTE *v32; // esi
  int v33; // ecx
  _DWORD v35[3]; // [esp+0h] [ebp-40h] BYREF
  _BYTE *v36; // [esp+Ch] [ebp-34h]
  bool v37; // [esp+10h] [ebp-30h]
  const char *v38; // [esp+14h] [ebp-2Ch]
  int v39; // [esp+18h] [ebp-28h]
  _BYTE *v40; // [esp+1Ch] [ebp-24h]
  int v41; // [esp+20h] [ebp-20h]
  int v42; // [esp+24h] [ebp-1Ch]
  int v43; // [esp+28h] [ebp-18h]
  unsigned __int8 v44; // [esp+2Fh] [ebp-11h]
  _DWORD *v45; // [esp+30h] [ebp-10h]
  int v46; // [esp+3Ch] [ebp-4h]

  v38 = a2;
  v40 = a1;
  v45 = v35;
  v43 = 0;
  v42 = 0;
  v3 = strlen(a2);
  v4 = *(_DWORD *)a1;
  v41 = v3;
  v5 = *(_DWORD *)(v4 + 4);
  v6 = *(_DWORD *)&a1[v5 + 36];
  v7 = *(_DWORD *)&a1[v5 + 32];
  if ( v6 >= 0 && (v6 > 0 || v7 && v7 > v3) )
  {
    v8 = (__PAIR64__(v6, v7) - v3) >> 32;
    v9 = v7 - v3;
  }
  else
  {
    v9 = 0;
    v8 = 0;
  }
  v10 = *(_DWORD *)&a1[v5 + 56];
  v36 = a1;
  if ( v10 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 4))(v10);
  v46 = 0;
  v11 = *(_DWORD *)a1;
  v12 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  if ( *((_DWORD *)v12 + 3) )
  {
    v13 = 0;
  }
  else
  {
    v14 = (_BYTE *)*((_DWORD *)v12 + 15);
    if ( !v14 || v14 == a1 )
    {
      v13 = 1;
    }
    else
    {
      sub_10002290(v14);
      v11 = *(_DWORD *)a1;
      v13 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] == 0;
    }
  }
  v37 = v13;
  v46 = 1;
  if ( v13 )
  {
    LOBYTE(v46) = 2;
    if ( (*(_DWORD *)&a1[*(_DWORD *)(v11 + 4) + 20] & 0x1C0) != 64 )
    {
      while ( v8 >= 0 && (v8 > 0 || v9) )
      {
        v16 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v17 = *(_DWORD **)&a1[v16 + 56];
        v44 = a1[v16 + 64];
        if ( *(_DWORD *)v17[8] && (v18 = (int *)v17[12], v39 = v44, *v18 > 0) )
        {
          --*v18;
          v19 = (_DWORD *)v17[8];
          v20 = (unsigned __int8 *)(*v19)++;
          *v20 = v44;
          v21 = v39;
        }
        else
        {
          v21 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v17 + 12))(v17, v44);
        }
        if ( v21 == -1 )
        {
          v15 = 4;
          goto LABEL_42;
        }
        v8 = (__PAIR64__(v8, v9--) - 1) >> 32;
      }
    }
    v22 = sub_10002140(*(void **)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56], (int)v38, v41, 0);
    if ( v22 == v41 && !v23 )
    {
      while ( v8 >= 0 && (v8 > 0 || v9) )
      {
        v24 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        v25 = *(_DWORD **)&a1[v24 + 56];
        v44 = a1[v24 + 64];
        if ( *(_DWORD *)v25[8] && (v26 = (int *)v25[12], v38 = (const char *)v44, *v26 > 0) )
        {
          --*v26;
          v27 = (_DWORD *)v25[8];
          v28 = (unsigned __int8 *)(*v27)++;
          *v28 = v44;
          v29 = (int)v38;
        }
        else
        {
          v29 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v25 + 12))(v25, v44);
        }
        if ( v29 == -1 )
        {
          v15 = v43 | 4;
          goto LABEL_42;
        }
        v8 = (__PAIR64__(v8, v9--) - 1) >> 32;
      }
      v15 = v43;
    }
    else
    {
      v15 = 4;
    }
LABEL_42:
    v30 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    *(_DWORD *)&a1[v30 + 32] = 0;
    *(_DWORD *)&a1[v30 + 36] = 0;
    v46 = 1;
  }
  else
  {
    v15 = 4;
  }
  sub_10001870(
    &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)],
    v15 | a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] | (*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56] != 0 ? 0 : 4),
    0);
  v31 = j____uncaught_exception(v35[0], v35[1], v35[2]);
  v32 = v36;
  if ( !v31 )
    sub_100023A0(v36);
  v46 = 4;
  v33 = *(_DWORD *)&v32[*(_DWORD *)(*(_DWORD *)v32 + 4) + 56];
  if ( v33 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v33 + 8))(v33);
  return a1;
}
// 100062AB: conditional instruction was optimized away because edi.4==0
// 100062AD: conditional instruction was optimized away because edi.4==0
// 100063B4: variable 'v23' is possibly undefined
// 1001BDB7: using guessed type int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD);

//----- (100064E0) --------------------------------------------------------
_BYTE *__cdecl sub_100064E0(_BYTE *a1)
{
  int v2; // edi
  struct std::_Facet_base *v3; // eax
  void (__thiscall ***v4)(_DWORD, int); // eax
  char v6[4]; // [esp+8h] [ebp-14h] BYREF
  int v7; // [esp+Ch] [ebp-10h]
  int v8; // [esp+18h] [ebp-4h]
  unsigned __int8 v9; // [esp+24h] [ebp+8h]

  v7 = *(_DWORD *)(*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 48] + 4);
  v2 = v7;
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  v8 = 0;
  v3 = sub_10006130((int)v6);
  v9 = (*(int (__thiscall **)(struct std::_Facet_base *, int))(*(_DWORD *)v3 + 32))(v3, 10);
  v8 = -1;
  if ( v2 )
  {
    v4 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v2 + 8))(v2);
    if ( v4 )
      (**v4)(v4, 1);
  }
  sub_10007310(a1, v9);
  sub_10002290(a1);
  return a1;
}
// 100064E0: using guessed type char var_14[4];

//----- (10006580) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_10006580(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // edx
  struct std::_Facet_base *v4; // esi
  int v5; // eax
  char v7[4]; // [esp+Ch] [ebp-18h] BYREF
  struct std::_Facet_base *v8; // [esp+10h] [ebp-14h] BYREF
  unsigned int v9; // [esp+14h] [ebp-10h] BYREF
  int v10; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
  v10 = 0;
  v1 = dword_10053224;
  v2 = dword_10053210;
  v8 = (struct std::_Facet_base *)dword_10053210;
  if ( !dword_10053224 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
    if ( !dword_10053224 )
      dword_10053224 = ++dword_10052410;
    std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    v1 = dword_10053224;
  }
  v9 = 4 * v1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
    v9 = 4 * v1;
  }
  else
  {
    v4 = *(struct std::_Facet_base **)(4 * v1 + *(_DWORD *)(v3 + 8));
    if ( v4 )
      goto LABEL_17;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_1001C2BD();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(struct std::_Facet_base **)(v9 + *(_DWORD *)(v5 + 8));
LABEL_12:
    if ( v4 )
      goto LABEL_17;
  }
  if ( v2 )
  {
    v4 = (struct std::_Facet_base *)v2;
  }
  else
  {
    if ( sub_10007160(&v8, a1) == -1 )
      sub_10002860();
    v4 = v8;
    LOBYTE(v10) = 1;
    std::_Facet_Register(v8);
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v4 + 4))(v4);
    dword_10053210 = (int)v4;
  }
LABEL_17:
  std::_Lockit::~_Lockit((std::_Lockit *)v7);
  return v4;
}
// 10002860: using guessed type void __noreturn sub_10002860(void);
// 10052410: using guessed type int dword_10052410;
// 10053210: using guessed type int dword_10053210;
// 10006580: using guessed type char var_18[4];

//----- (100066A0) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_100066A0(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // edx
  struct std::_Facet_base *v4; // esi
  int v5; // eax
  char v7[4]; // [esp+Ch] [ebp-18h] BYREF
  struct std::_Facet_base *v8; // [esp+10h] [ebp-14h] BYREF
  unsigned int v9; // [esp+14h] [ebp-10h] BYREF
  int v10; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
  v10 = 0;
  v1 = dword_10053220;
  v2 = dword_10053208;
  v8 = (struct std::_Facet_base *)dword_10053208;
  if ( !dword_10053220 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
    if ( !dword_10053220 )
      dword_10053220 = ++dword_10052410;
    std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    v1 = dword_10053220;
  }
  v9 = 4 * v1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
    v9 = 4 * v1;
  }
  else
  {
    v4 = *(struct std::_Facet_base **)(4 * v1 + *(_DWORD *)(v3 + 8));
    if ( v4 )
      goto LABEL_17;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_1001C2BD();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(struct std::_Facet_base **)(v9 + *(_DWORD *)(v5 + 8));
LABEL_12:
    if ( v4 )
      goto LABEL_17;
  }
  if ( v2 )
  {
    v4 = (struct std::_Facet_base *)v2;
  }
  else
  {
    if ( sub_10006FB0(&v8, a1) == -1 )
      sub_10002860();
    v4 = v8;
    LOBYTE(v10) = 1;
    std::_Facet_Register(v8);
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v4 + 4))(v4);
    dword_10053208 = (int)v4;
  }
LABEL_17:
  std::_Lockit::~_Lockit((std::_Lockit *)v7);
  return v4;
}
// 10002860: using guessed type void __noreturn sub_10002860(void);
// 10052410: using guessed type int dword_10052410;
// 10053208: using guessed type int dword_10053208;
// 100066A0: using guessed type char var_18[4];

//----- (100067C0) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_100067C0(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // edx
  struct std::_Facet_base *v4; // esi
  int v5; // eax
  char v7[4]; // [esp+Ch] [ebp-18h] BYREF
  struct std::_Facet_base *v8; // [esp+10h] [ebp-14h] BYREF
  unsigned int v9; // [esp+14h] [ebp-10h] BYREF
  int v10; // [esp+20h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
  v10 = 0;
  v1 = dword_10053228;
  v2 = dword_10053204;
  v8 = (struct std::_Facet_base *)dword_10053204;
  if ( !dword_10053228 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
    if ( !dword_10053228 )
      dword_10053228 = ++dword_10052410;
    std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    v1 = dword_10053228;
  }
  v9 = 4 * v1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
    v9 = 4 * v1;
  }
  else
  {
    v4 = *(struct std::_Facet_base **)(4 * v1 + *(_DWORD *)(v3 + 8));
    if ( v4 )
      goto LABEL_17;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_1001C2BD();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(struct std::_Facet_base **)(v9 + *(_DWORD *)(v5 + 8));
LABEL_12:
    if ( v4 )
      goto LABEL_17;
  }
  if ( v2 )
  {
    v4 = (struct std::_Facet_base *)v2;
  }
  else
  {
    if ( sub_10006D10(&v8, a1) == -1 )
      sub_10002860();
    v4 = v8;
    LOBYTE(v10) = 1;
    std::_Facet_Register(v8);
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v4 + 4))(v4);
    dword_10053204 = (int)v4;
  }
LABEL_17:
  std::_Lockit::~_Lockit((std::_Lockit *)v7);
  return v4;
}
// 10002860: using guessed type void __noreturn sub_10002860(void);
// 10052410: using guessed type int dword_10052410;
// 10053204: using guessed type int dword_10053204;
// 100067C0: using guessed type char var_18[4];

//----- (100068E0) --------------------------------------------------------
void **__thiscall sub_100068E0(void **Src, int a2, int a3, char a4)
{
  size_t v5; // edx
  unsigned int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // esi
  size_t v9; // ecx
  void *v10; // eax
  _DWORD *v11; // edi
  _DWORD *v12; // eax
  void *v13; // esi
  void **result; // eax
  unsigned int v15; // [esp+Ch] [ebp-8h]
  size_t Size; // [esp+10h] [ebp-4h]

  v5 = (size_t)Src[4];
  Size = v5;
  if ( v5 == 0x7FFFFFFF )
    sub_100012E0();
  v6 = (unsigned int)Src[5];
  v7 = (v5 + 1) | 0xF;
  v15 = v6;
  if ( v7 > 0x7FFFFFFF )
  {
    v8 = 0x7FFFFFFF;
LABEL_4:
    v9 = -2147483613;
    goto LABEL_5;
  }
  if ( v6 > 0x7FFFFFFF - (v6 >> 1) )
  {
    v8 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  v8 = v6 + (v6 >> 1);
  if ( v7 >= v8 )
    v8 = (v5 + 1) | 0xF;
  if ( v8 + 1 < 0x1000 )
  {
    if ( v8 == -1 )
    {
      v11 = 0;
    }
    else
    {
      v12 = operator new(v8 + 1);
      v5 = Size;
      v11 = v12;
    }
    goto LABEL_17;
  }
  v9 = v8 + 36;
  if ( v8 + 36 <= v8 + 1 )
    sub_10001240();
LABEL_5:
  v10 = operator new(v9);
  if ( !v10 )
    goto LABEL_25;
  v5 = Size;
  v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
  *(v11 - 1) = v10;
LABEL_17:
  Src[4] = (void *)(v5 + 1);
  Src[5] = (void *)v8;
  if ( v15 >= 0x10 )
  {
    v13 = *Src;
    memmove(v11, *Src, v5);
    *((_BYTE *)v11 + Size) = a4;
    *((_BYTE *)v11 + Size + 1) = 0;
    if ( v15 + 1 < 0x1000 )
    {
LABEL_21:
      sub_1001D481(v13);
      *Src = v11;
      return Src;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v11, Src, v5);
  *((_BYTE *)v11 + Size) = a4;
  result = Src;
  *((_BYTE *)v11 + Size + 1) = 0;
  *Src = v11;
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10006A20) --------------------------------------------------------
const void **__thiscall sub_10006A20(const void **Src, unsigned int a2, int a3, size_t Size, size_t a5, char Val)
{
  size_t v7; // esi
  size_t v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // esi
  size_t v12; // ecx
  void *v13; // eax
  _DWORD *v14; // edi
  char *v15; // esi
  void *v17; // [esp+10h] [ebp-8h]
  char *v18; // [esp+10h] [ebp-8h]
  size_t v19; // [esp+14h] [ebp-4h]
  size_t v20; // [esp+14h] [ebp-4h]
  unsigned int v21; // [esp+20h] [ebp+8h]

  v7 = (size_t)Src[4];
  v19 = v7;
  if ( 0x7FFFFFFF - v7 < a2 )
    sub_100012E0();
  v8 = v7 + a2;
  v9 = (unsigned int)Src[5];
  v17 = (void *)v8;
  v10 = v8 | 0xF;
  v21 = v9;
  if ( v10 > 0x7FFFFFFF )
  {
    v11 = 0x7FFFFFFF;
LABEL_4:
    v12 = -2147483613;
    goto LABEL_5;
  }
  if ( v9 > 0x7FFFFFFF - (v9 >> 1) )
  {
    v11 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  v11 = (v9 >> 1) + v9;
  if ( v10 >= v11 )
    v11 = v10;
  if ( v11 + 1 < 0x1000 )
  {
    if ( v11 == -1 )
      v14 = 0;
    else
      v14 = operator new(v11 + 1);
    goto LABEL_17;
  }
  v12 = v11 + 36;
  if ( v11 + 36 <= v11 + 1 )
    sub_10001240();
LABEL_5:
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_25;
  v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
  *(v14 - 1) = v13;
LABEL_17:
  Src[4] = v17;
  Src[5] = (const void *)v11;
  v20 = v19 - Size + 1;
  v18 = (char *)v14 + Size + a5;
  if ( v21 >= 0x10 )
  {
    v15 = (char *)*Src;
    memmove(v14, *Src, Size);
    memset((char *)v14 + Size, Val, a5);
    memmove(v18, &v15[Size], v20);
    if ( v21 + 1 < 0x1000 )
    {
LABEL_21:
      sub_1001D481(v15);
      *Src = v14;
      return Src;
    }
    if ( (unsigned int)&v15[-*((_DWORD *)v15 - 1) - 4] <= 0x1F )
    {
      v15 = (char *)*((_DWORD *)v15 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v14, Src, Size);
  memset((char *)v14 + Size, Val, a5);
  memmove(v18, (char *)Src + Size, v20);
  *Src = v14;
  return Src;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10006BA0) --------------------------------------------------------
void **__thiscall sub_10006BA0(void **Src, unsigned int a2, int a3, size_t a4, char Val)
{
  size_t v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // esi
  size_t v9; // ecx
  void *v10; // eax
  _DWORD *v11; // edi
  char *v12; // esi
  void *v13; // esi
  void **result; // eax
  size_t v15; // [esp-4h] [ebp-18h]
  size_t Size; // [esp+Ch] [ebp-8h]
  void *Sizea; // [esp+Ch] [ebp-8h]
  size_t v18; // [esp+10h] [ebp-4h]
  char *v19; // [esp+10h] [ebp-4h]
  unsigned int v20; // [esp+1Ch] [ebp+8h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_100012E0();
  v7 = (unsigned int)Src[5];
  v18 = v6 + a2;
  v20 = v7;
  if ( (v18 | 0xF) > 0x7FFFFFFF )
  {
    v8 = 0x7FFFFFFF;
LABEL_4:
    v9 = -2147483613;
    goto LABEL_5;
  }
  if ( v7 > 0x7FFFFFFF - (v7 >> 1) )
  {
    v8 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  v8 = (v7 >> 1) + v7;
  if ( (v18 | 0xF) >= v8 )
    v8 = v18 | 0xF;
  if ( v8 + 1 < 0x1000 )
  {
    if ( v8 == -1 )
      v11 = 0;
    else
      v11 = operator new(v8 + 1);
    goto LABEL_17;
  }
  v9 = v8 + 36;
  if ( v8 + 36 <= v8 + 1 )
    sub_10001240();
LABEL_5:
  v10 = operator new(v9);
  if ( !v10 )
    goto LABEL_25;
  v11 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
  *(v11 - 1) = v10;
LABEL_17:
  Src[4] = (void *)v18;
  Src[5] = (void *)v8;
  v15 = Size;
  v12 = (char *)v11 + Size;
  Sizea = v12;
  v19 = &v12[a4];
  if ( v20 >= 0x10 )
  {
    v13 = *Src;
    memmove(v11, *Src, v15);
    memset(Sizea, Val, a4);
    *v19 = 0;
    if ( v20 + 1 < 0x1000 )
    {
LABEL_21:
      sub_1001D481(v13);
      *Src = v11;
      return Src;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v11, Src, v15);
  memset(v12, Val, a4);
  *v19 = 0;
  result = Src;
  *Src = v11;
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10006D10) --------------------------------------------------------
int __cdecl sub_10006D10(_DWORD *a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // eax
  const char *v4; // esi
  _BYTE *v5; // eax
  int v6; // edi
  const char *v7; // esi
  _BYTE *v8; // eax
  char v9; // cl
  int v10; // edi
  const char *v11; // esi
  _BYTE *v12; // eax
  char v13; // cl
  _Cvtvec v15; // [esp+0h] [ebp-A4h] BYREF
  _Cvtvec v16; // [esp+2Ch] [ebp-78h] BYREF
  _DWORD *v17; // [esp+58h] [ebp-4Ch]
  void *v18; // [esp+5Ch] [ebp-48h]
  int v19; // [esp+60h] [ebp-44h]
  char v20[4]; // [esp+64h] [ebp-40h] BYREF
  void *v21; // [esp+68h] [ebp-3Ch]
  char v22; // [esp+6Ch] [ebp-38h]
  void *v23; // [esp+70h] [ebp-34h]
  char v24; // [esp+74h] [ebp-30h]
  void *v25; // [esp+78h] [ebp-2Ch]
  __int16 v26; // [esp+7Ch] [ebp-28h]
  void *v27; // [esp+80h] [ebp-24h]
  __int16 v28; // [esp+84h] [ebp-20h]
  void *v29; // [esp+88h] [ebp-1Ch]
  char v30; // [esp+8Ch] [ebp-18h]
  void *Block; // [esp+90h] [ebp-14h]
  char v32; // [esp+94h] [ebp-10h]
  int v33; // [esp+A0h] [ebp-4h]

  v19 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x18u);
    v18 = v2;
    v33 = 0;
    v3 = *(_DWORD *)(a2 + 4);
    if ( v3 )
    {
      v4 = *(const char **)(v3 + 24);
      if ( !v4 )
        v4 = (const char *)(v3 + 28);
    }
    else
    {
      v4 = (const char *)&unk_1004A353;
    }
    std::_Lockit::_Lockit((std::_Lockit *)v20, 0);
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    Block = 0;
    v32 = 0;
    LOBYTE(v33) = 7;
    if ( !v4 )
      sub_1001C06E((int)"bad locale name");
    std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)v20, v4);
    v19 = 1;
    v2[1] = 0;
    v33 = 9;
    *v2 = &std::numpunct<char>::`vftable';
    localeconv();
    _Getcvt(&v16);
    v2[2] = 0;
    v2[4] = 0;
    v2[5] = 0;
    v17 = v2;
    LOBYTE(v33) = 10;
    _Getcvt(&v15);
    v5 = calloc(1u, 1u);
    if ( !v5 )
      goto LABEL_28;
    v6 = 6;
    *v5 = 0;
    v2[2] = v5;
    v7 = "false";
    v8 = calloc(6u, 1u);
    if ( !v8 )
      goto LABEL_28;
    do
    {
      v9 = *v7++;
      v7[v8 - "false" - 1] = v9;
      --v6;
    }
    while ( v6 );
    v10 = 5;
    v2[4] = v8;
    v11 = "true";
    v12 = calloc(5u, 1u);
    if ( !v12 )
LABEL_28:
      sub_1001BFF1();
    do
    {
      v13 = *v11++;
      v11[v12 - "true" - 1] = v13;
      --v10;
    }
    while ( v10 );
    v2[5] = v12;
    *((_WORD *)v2 + 6) = 11310;
    *a1 = v2;
    v33 = 13;
    std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)v20);
    LOBYTE(v33) = 14;
    if ( Block )
      free(Block);
    Block = 0;
    LOBYTE(v33) = 15;
    if ( v29 )
      free(v29);
    v29 = 0;
    LOBYTE(v33) = 16;
    if ( v27 )
      free(v27);
    v27 = 0;
    LOBYTE(v33) = 17;
    if ( v25 )
      free(v25);
    v25 = 0;
    LOBYTE(v33) = 18;
    if ( v23 )
      free(v23);
    v23 = 0;
    LOBYTE(v33) = 19;
    if ( v21 )
      free(v21);
    v21 = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v20);
  }
  return 4;
}
// 1001BFF1: using guessed type void __noreturn sub_1001BFF1(void);
// 1003F554: using guessed type void *std::numpunct<char>::`vftable';
// 10006D10: using guessed type char var_40[4];

//----- (10006FB0) --------------------------------------------------------
int __cdecl sub_10006FB0(_DWORD *a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // eax
  const char *v4; // esi
  char v6[4]; // [esp+4h] [ebp-44h] BYREF
  void *v7; // [esp+8h] [ebp-40h]
  char v8; // [esp+Ch] [ebp-3Ch]
  void *v9; // [esp+10h] [ebp-38h]
  char v10; // [esp+14h] [ebp-34h]
  void *v11; // [esp+18h] [ebp-30h]
  __int16 v12; // [esp+1Ch] [ebp-2Ch]
  void *v13; // [esp+20h] [ebp-28h]
  __int16 v14; // [esp+24h] [ebp-24h]
  void *v15; // [esp+28h] [ebp-20h]
  char v16; // [esp+2Ch] [ebp-1Ch]
  void *Block; // [esp+30h] [ebp-18h]
  char v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+44h] [ebp-4h]

  if ( a1 && !*a1 )
  {
    v2 = operator new(8u);
    v19 = 0;
    v3 = *(_DWORD *)(a2 + 4);
    if ( v3 )
    {
      v4 = *(const char **)(v3 + 24);
      if ( !v4 )
        v4 = (const char *)(v3 + 28);
    }
    else
    {
      v4 = (const char *)&unk_1004A353;
    }
    std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    Block = 0;
    v18 = 0;
    LOBYTE(v19) = 7;
    if ( !v4 )
      sub_1001C06E((int)"bad locale name");
    std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)v6, v4);
    v2[1] = 0;
    *v2 = &std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
    *a1 = v2;
    v19 = 8;
    std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)v6);
    LOBYTE(v19) = 9;
    if ( Block )
      free(Block);
    Block = 0;
    LOBYTE(v19) = 10;
    if ( v15 )
      free(v15);
    v15 = 0;
    LOBYTE(v19) = 11;
    if ( v13 )
      free(v13);
    v13 = 0;
    LOBYTE(v19) = 12;
    if ( v11 )
      free(v11);
    v11 = 0;
    LOBYTE(v19) = 13;
    if ( v9 )
      free(v9);
    v9 = 0;
    LOBYTE(v19) = 14;
    if ( v7 )
      free(v7);
    v7 = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v6);
  }
  return 4;
}
// 1003F524: using guessed type void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
// 10006FB0: using guessed type char var_44[4];

//----- (10007160) --------------------------------------------------------
int __cdecl sub_10007160(_DWORD *a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // eax
  const char *v4; // esi
  char v6[4]; // [esp+4h] [ebp-44h] BYREF
  void *v7; // [esp+8h] [ebp-40h]
  char v8; // [esp+Ch] [ebp-3Ch]
  void *v9; // [esp+10h] [ebp-38h]
  char v10; // [esp+14h] [ebp-34h]
  void *v11; // [esp+18h] [ebp-30h]
  __int16 v12; // [esp+1Ch] [ebp-2Ch]
  void *v13; // [esp+20h] [ebp-28h]
  __int16 v14; // [esp+24h] [ebp-24h]
  void *v15; // [esp+28h] [ebp-20h]
  char v16; // [esp+2Ch] [ebp-1Ch]
  void *Block; // [esp+30h] [ebp-18h]
  char v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+44h] [ebp-4h]

  if ( a1 && !*a1 )
  {
    v2 = operator new(8u);
    v19 = 0;
    v3 = *(_DWORD *)(a2 + 4);
    if ( v3 )
    {
      v4 = *(const char **)(v3 + 24);
      if ( !v4 )
        v4 = (const char *)(v3 + 28);
    }
    else
    {
      v4 = (const char *)&unk_1004A353;
    }
    std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    Block = 0;
    v18 = 0;
    LOBYTE(v19) = 7;
    if ( !v4 )
      sub_1001C06E((int)"bad locale name");
    std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)v6, v4);
    v2[1] = 0;
    *v2 = &std::codecvt<char,char,_Mbstatet>::`vftable';
    *a1 = v2;
    v19 = 8;
    std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)v6);
    LOBYTE(v19) = 9;
    if ( Block )
      free(Block);
    Block = 0;
    LOBYTE(v19) = 10;
    if ( v15 )
      free(v15);
    v15 = 0;
    LOBYTE(v19) = 11;
    if ( v13 )
      free(v13);
    v13 = 0;
    LOBYTE(v19) = 12;
    if ( v11 )
      free(v11);
    v11 = 0;
    LOBYTE(v19) = 13;
    if ( v9 )
      free(v9);
    v9 = 0;
    LOBYTE(v19) = 14;
    if ( v7 )
      free(v7);
    v7 = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v6);
  }
  return 2;
}
// 1003F578: using guessed type void *std::codecvt<char,char,_Mbstatet>::`vftable';
// 10007160: using guessed type char var_44[4];

//----- (10007310) --------------------------------------------------------
_BYTE *__thiscall sub_10007310(_BYTE *this, unsigned __int8 a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  _BYTE *v6; // eax
  bool v7; // al
  _BYTE *v8; // eax
  char v9; // bl
  _DWORD *v10; // ecx
  int *v11; // eax
  _DWORD *v12; // ecx
  unsigned __int8 *v13; // edx
  int v14; // ecx
  _DWORD v16[5]; // [esp+0h] [ebp-2Ch] BYREF
  bool v17; // [esp+14h] [ebp-18h]
  _BYTE *v18; // [esp+18h] [ebp-14h]
  _DWORD *v19; // [esp+1Ch] [ebp-10h]
  int v20; // [esp+28h] [ebp-4h]

  v19 = v16;
  v18 = this;
  v3 = *(_DWORD *)this;
  v16[4] = this;
  v4 = *(_DWORD *)&this[*(_DWORD *)(v3 + 4) + 56];
  if ( v4 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
  v20 = 0;
  v5 = *(_DWORD *)this;
  v6 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
  if ( *((_DWORD *)v6 + 3) )
  {
    v7 = 0;
  }
  else
  {
    v8 = (_BYTE *)*((_DWORD *)v6 + 15);
    if ( !v8 || v8 == this )
    {
      v7 = 1;
    }
    else
    {
      sub_10002290(v8);
      v5 = *(_DWORD *)this;
      v7 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] == 0;
    }
  }
  v17 = v7;
  v20 = 1;
  if ( v7 )
  {
    LOBYTE(v20) = 2;
    v10 = *(_DWORD **)&this[*(_DWORD *)(v5 + 4) + 56];
    if ( *(_DWORD *)v10[8] && (v11 = (int *)v10[12], *v11 > 0) )
    {
      --*v11;
      v12 = (_DWORD *)v10[8];
      v13 = (unsigned __int8 *)(*v12)++;
      *v13 = a2;
      v9 = a2 != -1 ? 0 : 4;
    }
    else
    {
      v9 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v10 + 12))(v10, a2) != -1 ? 0 : 4;
    }
    v20 = 1;
  }
  else
  {
    v9 = 4;
  }
  sub_10001870(
    &this[*(_DWORD *)(*(_DWORD *)this + 4)],
    v9 | this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] | (*(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56] != 0
                                                      ? 0
                                                      : 4),
    0);
  if ( !(unsigned __int8)j____uncaught_exception(v16[0], v16[1], v16[2]) )
    sub_100023A0(this);
  v20 = 4;
  v14 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v14 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 8))(v14);
  return this;
}
// 1001BDB7: using guessed type int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD);

//----- (100074A0) --------------------------------------------------------
void __thiscall sub_100074A0(void ***this)
{
  void **v1; // esi

  v1 = *this;
  if ( *this )
  {
    free(v1[2]);
    free(v1[4]);
    free(v1[5]);
  }
}

//----- (100074F5) --------------------------------------------------------
char *__thiscall sub_100074F5(_DWORD *this, char a2)
{
  return sub_100046B0((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (100074FD) --------------------------------------------------------
char *__thiscall sub_100074FD(_DWORD *this, char a2)
{
  return sub_10004610((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (10007510) --------------------------------------------------------
int __stdcall sub_10007510(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004A9AC;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_6:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_6;
  }
  return (**a1[1])(a1[1], a2, a3);
}

//----- (100075A0) --------------------------------------------------------
int __cdecl sub_100075A0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 4) + 4))(*(_DWORD *)(a1 + 4));
}

//----- (100075C0) --------------------------------------------------------
int __stdcall sub_100075C0(_DWORD **Block)
{
  int result; // eax

  result = (*(int (__stdcall **)(_DWORD *))(*Block[1] + 8))(Block[1]);
  if ( !result )
  {
    *Block = &Direct3D8::`vftable';
    `eh vector destructor iterator'(Block + 11, 0xCu, 8u, (void (__thiscall *)(void *))sub_10007FE0);
    sub_1001D481(Block);
    return 0;
  }
  return result;
}
// 1004A96C: using guessed type void *Direct3D8::`vftable';

//----- (10007630) --------------------------------------------------------
int __cdecl sub_10007630(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 4) + 12))(*(_DWORD *)(a1 + 4));
}

//----- (10007650) --------------------------------------------------------
int __stdcall sub_10007650(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (10007660) --------------------------------------------------------
int __stdcall sub_10007660(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  char v9[512]; // [esp+4h] [ebp-44Ch] BYREF
  char v10[512]; // [esp+204h] [ebp-24Ch] BYREF
  int v11; // [esp+424h] [ebp-2Ch]
  int v12; // [esp+428h] [ebp-28h]
  int v13; // [esp+42Ch] [ebp-24h]
  int v14; // [esp+430h] [ebp-20h]
  int v15; // [esp+434h] [ebp-1Ch]
  int v16; // [esp+438h] [ebp-18h]
  int v17; // [esp+43Ch] [ebp-14h]
  int v18; // [esp+440h] [ebp-10h]
  int v19; // [esp+444h] [ebp-Ch]
  int v20; // [esp+448h] [ebp-8h]
  int v21; // [esp+44Ch] [ebp-4h]

  if ( !a4 )
    return -2005530516;
  if ( (a3 & 2) != 0 )
    v5 = a3 ^ 2;
  else
    v5 = a3 | 2;
  result = (*(int (__stdcall **)(_DWORD, int, int, char *))(**(_DWORD **)(a1 + 4) + 20))(
             *(_DWORD *)(a1 + 4),
             a2,
             v5,
             v9);
  if ( result >= 0 )
  {
    a4[256] = v11;
    a4[258] = v13;
    a4[259] = v14;
    a4[260] = v15;
    a4[261] = v16;
    a4[262] = v17;
    a4[263] = v18;
    v6 = v19;
    qmemcpy(a4, v9, 0x200u);
    a4[264] = v6;
    a4[265] = v20;
    v7 = v21;
    qmemcpy(a4 + 128, v10, 0x200u);
    v8 = v12;
    a4[266] = v7;
    result = 0;
    a4[257] = v8;
  }
  return result;
}

//----- (10007740) --------------------------------------------------------
int __stdcall sub_10007740(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 12);
}

//----- (10007760) --------------------------------------------------------
int __stdcall sub_10007760(int a1, unsigned int a2, unsigned int a3, _DWORD *a4)
{
  int v4; // esi
  int v5; // ebx
  int v6; // ebx
  int v7; // ebx
  int v8; // ebx

  if ( !a4 || a2 >= *(_DWORD *)(a1 + 8) || a3 >= *(_DWORD *)(a1 + 4 * a2 + 12) )
    return -2005530516;
  v4 = a1 + 12 * a2;
  v5 = *(_DWORD *)(v4 + 44);
  if ( (*(_DWORD *)(v4 + 48) - v5) >> 4 <= a3
    || (a4[3] = *(_DWORD *)(v5 + 16 * a3 + 12), v6 = *(_DWORD *)(v4 + 44), (*(_DWORD *)(v4 + 48) - v6) >> 4 <= a3)
    || (a4[1] = *(_DWORD *)(v6 + 16 * a3 + 4), v7 = *(_DWORD *)(v4 + 44), (*(_DWORD *)(v4 + 48) - v7) >> 4 <= a3)
    || (a4[2] = *(_DWORD *)(v7 + 16 * a3 + 8), v8 = *(_DWORD *)(v4 + 44), (*(_DWORD *)(v4 + 48) - v8) >> 4 <= a3) )
  {
    sub_100080C0();
  }
  *a4 = *(_DWORD *)(v8 + 16 * a3);
  return 0;
}
// 100080C0: using guessed type void __noreturn sub_100080C0(void);

//----- (10007800) --------------------------------------------------------
int __cdecl sub_10007800(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 4) + 32))(*(_DWORD *)(a1 + 4));
}

//----- (10007820) --------------------------------------------------------
int __cdecl sub_10007820(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 4) + 36))(*(_DWORD *)(a1 + 4));
}

//----- (10007840) --------------------------------------------------------
int __stdcall sub_10007840(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a7 == 1498831189 || a7 == 844715353 || a7 == 842094169 || a7 == 842094158 )
    return -2005530518;
  else
    return (*(int (__stdcall **)(_DWORD, int, int, int, int, int, int))(**(_DWORD **)(a1 + 4) + 40))(
             *(_DWORD *)(a1 + 4),
             a2,
             a3,
             a4,
             a5,
             a6,
             a7);
}

//----- (10007890) --------------------------------------------------------
int __stdcall sub_10007890(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return (*(int (__stdcall **)(_DWORD, int, int, int, int, int, _DWORD))(**(_DWORD **)(a1 + 4) + 44))(
           *(_DWORD *)(a1 + 4),
           a2,
           a3,
           a4,
           a5,
           a6,
           0);
}

//----- (100078C0) --------------------------------------------------------
int __cdecl sub_100078C0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 4) + 48))(*(_DWORD *)(a1 + 4));
}

//----- (100078E0) --------------------------------------------------------
int __stdcall sub_100078E0(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax
  unsigned int v5; // eax
  int v6[76]; // [esp+10h] [ebp-130h] BYREF

  if ( !a4 )
    return -2005530516;
  result = (*(int (__stdcall **)(_DWORD, int, int, int *))(**(_DWORD **)(a1 + 4) + 56))(*(_DWORD *)(a1 + 4), a2, a3, v6);
  if ( result >= 0 )
  {
    v5 = v6[50];
    qmemcpy(a4, v6, 0xD4u);
    a4[3] |= 0x80000u;
    a4[9] |= 0x4000u;
    a4[34] &= ~0x100u;
    a4[51] = -65276;
    a4[49] = -130815;
    if ( v5 > 0x100 )
      v5 = 256;
    a4[50] = v5;
    return 0;
  }
  return result;
}

//----- (10007980) --------------------------------------------------------
int __cdecl sub_10007980(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 4) + 60))(*(_DWORD *)(a1 + 4));
}

//----- (100079A0) --------------------------------------------------------
int __stdcall sub_100079A0(int a1, int a2, void *Block, int a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  _BYTE *v19; // eax
  _BYTE *v20; // eax
  _BYTE *v21; // eax
  _DWORD *v22; // ebx
  _BYTE *v23; // eax
  _BYTE *v24; // eax
  _DWORD *v25; // ecx
  int v26; // ecx
  void *v27; // ebx
  int v28; // ecx
  int result; // eax
  int v30; // ecx
  unsigned int v31; // edx
  HDC DC; // esi
  char v33; // bl
  _DWORD *v34; // eax
  _DWORD v35[4]; // [esp+Ch] [ebp-48h] BYREF
  int v36; // [esp+1Ch] [ebp-38h]
  int v37; // [esp+20h] [ebp-34h]
  int v38; // [esp+2Ch] [ebp-28h]
  int v39; // [esp+34h] [ebp-20h]
  unsigned int v40; // [esp+38h] [ebp-1Ch]
  int v41; // [esp+44h] [ebp-10h] BYREF
  int v42; // [esp+50h] [ebp-4h]
  int savedregs; // [esp+54h] [ebp+0h] BYREF
  _DWORD *Blocka; // [esp+64h] [ebp+10h]
  _DWORD *v45; // [esp+6Ch] [ebp+18h]

  v7 = sub_10006250(&dword_10053148, "Redirecting '");
  v8 = sub_10006250(v7, "IDirect3D8::CreateDevice");
  v9 = sub_10006250(v8, "(");
  v10 = sub_10007C40(v9, (int)&savedregs, a1);
  v11 = sub_10006250(v10, ", ");
  v12 = sub_100042E0(v11, (int)&savedregs, a2);
  v13 = sub_10006250(v12, ", ");
  v14 = sub_10007E10(v13, (int)&savedregs, (int)Block);
  v15 = sub_10006250(v14, ", ");
  v16 = sub_10007C40(v15, (int)&savedregs, a4);
  v17 = sub_10006250(v16, ", ");
  v18 = sub_100042E0(v17, (int)&savedregs, (int)a5);
  v19 = sub_10006250(v18, ", ");
  v20 = sub_10007C40(v19, (int)&savedregs, (int)a6);
  v21 = sub_10006250(v20, ", ");
  v22 = a7;
  v23 = sub_10007C40(v21, (int)&savedregs, (int)a7);
  v24 = sub_10006250(v23, ")' ...");
  sub_100064E0(v24);
  v25 = a6;
  if ( !a6 || !v22 )
    return -2005530516;
  *v22 = 0;
  sub_1001BB20(v25, v35);
  if ( v36 )
  {
    v26 = *(_DWORD *)(a1 + 4);
    v27 = Block;
    a6 = 0;
    if ( !(*(int (__stdcall **)(int, int, void *, _DWORD, int, int, _DWORD **))(*(_DWORD *)v26 + 44))(
            v26,
            a2,
            Block,
            v35[2],
            v38,
            v36,
            &a6)
      && !(*(int (__stdcall **)(_DWORD, int, void *, int, int, int, _DWORD **))(**(_DWORD **)(a1 + 4) + 44))(
            *(_DWORD *)(a1 + 4),
            a2,
            Block,
            v39,
            v38,
            v36,
            &a6) )
    {
      if ( a6 )
        v37 = (int)a6 - 1;
      else
        v37 = 0;
    }
  }
  else
  {
    v27 = Block;
  }
  v28 = *(_DWORD *)(a1 + 4);
  v41 = 0;
  result = (*(int (__stdcall **)(int, int, void *, int, void *, _DWORD *, int *))(*(_DWORD *)v28 + 64))(
             v28,
             a2,
             v27,
             a4,
             a5,
             v35,
             &v41);
  if ( result >= 0 )
  {
    Blocka = operator new(0x8Cu);
    v42 = 0;
    v30 = v41;
    v31 = (v40 >> 1) & 1;
    *Blocka = &Direct3DDevice8::`vftable';
    Blocka[2] = a1;
    Blocka[3] = v30;
    Blocka[4] = 0;
    Blocka[5] = v31;
    Blocka[6] = 0;
    Blocka[7] = 0;
    Blocka[8] = 0;
    *((_BYTE *)Blocka + 36) = 0;
    memset(Blocka + 10, 0, 0x60u);
    Blocka[34] = 0;
    v45 = operator new(0x104u);
    LOBYTE(v42) = 1;
    *v45 = Blocka;
    `eh vector constructor iterator'(v45 + 1, 0x20u, 8u, (void (__thiscall *)(void *))sub_1001BC80, sub_1001BBE0);
    Blocka[1] = v45;
    DC = GetDC(0);
    v33 = ((unsigned __int16)GetDeviceCaps(DC, 38) >> 8) & 1;
    ReleaseDC(0, DC);
    v34 = a7;
    *((_BYTE *)Blocka + 36) = v33;
    v42 = -1;
    *v34 = Blocka;
    (*(void (__stdcall **)(int, int))(*(_DWORD *)v41 + 356))(v41, 2);
    return 0;
  }
  return result;
}
// 1004A9F0: using guessed type void *Direct3DDevice8::`vftable';
// 10053148: using guessed type int dword_10053148;

//----- (10007C40) --------------------------------------------------------
_BYTE *__userpurge sub_10007C40@<eax>(_BYTE *a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  _BYTE *v8; // eax
  bool v9; // al
  _BYTE *v10; // eax
  struct std::_Facet_base *v11; // edi
  void (__thiscall ***v12)(_DWORD, int); // eax
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v17; // [esp-4Ch] [ebp-58h]
  _DWORD v18[2]; // [esp-48h] [ebp-54h] BYREF
  int *v19; // [esp-40h] [ebp-4Ch]
  int v20[3]; // [esp-38h] [ebp-44h] BYREF
  bool v21; // [esp-2Ch] [ebp-38h]
  int v22; // [esp-28h] [ebp-34h]
  int v23; // [esp-24h] [ebp-30h] BYREF
  struct std::_Facet_base *v24; // [esp-20h] [ebp-2Ch]
  _BYTE *v25; // [esp-1Ch] [ebp-28h]
  int *v26; // [esp-14h] [ebp-20h]
  _DWORD *v27; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v29; // [esp-8h] [ebp-14h]
  int v30; // [esp-4h] [ebp-10h]
  int v31; // [esp+0h] [ebp-Ch]
  int v32; // [esp+4h] [ebp-8h]
  int v33; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v31 = a2;
  v32 = retaddr;
  v30 = -1;
  v29 = &loc_1003C70D;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v26 = &v33;
  v19 = &v33;
  LOBYTE(v4) = 0;
  v27 = v18;
  v25 = a1;
  v5 = *(_DWORD *)a1;
  v22 = 0;
  v20[2] = (int)a1;
  v6 = *(_DWORD *)&a1[*(_DWORD *)(v5 + 4) + 56];
  if ( v6 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
  v30 = 0;
  v7 = *(_DWORD *)a1;
  v8 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  if ( *((_DWORD *)v8 + 3) )
  {
    v9 = 0;
  }
  else
  {
    v10 = (_BYTE *)*((_DWORD *)v8 + 15);
    if ( !v10 || v10 == a1 )
    {
      v9 = 1;
    }
    else
    {
      sub_10002290(v10);
      v7 = *(_DWORD *)a1;
      v9 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] == 0;
    }
  }
  v21 = v9;
  v30 = 1;
  if ( v9 )
  {
    v11 = *(struct std::_Facet_base **)(*(_DWORD *)&a1[*(_DWORD *)(v7 + 4) + 48] + 4);
    v24 = v11;
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v11 + 4))(v11);
    LOBYTE(v30) = 2;
    v24 = sub_100066A0((int)&v23);
    if ( v11 )
    {
      v12 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v11 + 8))(v11);
      if ( v12 )
        (**v12)(v12, 1);
    }
    LOBYTE(v30) = 3;
    v13 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v14 = (int)&a1[v13];
    LOBYTE(v20[0]) = 0;
    v17 = *(_DWORD *)&a1[v13 + 56];
    LOBYTE(v13) = a1[v13 + 64];
    v4 = *(_BYTE *)sub_10008060(v24, (int)v20, v14, v13, a3, v20[0], v17) != 0 ? 4 : 0;
    v30 = 1;
  }
  sub_10001870(
    &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)],
    v4 | a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] | (*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56] != 0 ? 0 : 4),
    0);
  if ( !(unsigned __int8)j____uncaught_exception(v18[0], v18[1], v19) )
    sub_100023A0(a1);
  v30 = 5;
  v15 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
  if ( v15 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 8))(v15);
  return a1;
}
// 10007C40: could not find valid save-restore pair for ebp
// 1001BDB7: using guessed type int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD);

//----- (10007E10) --------------------------------------------------------
_BYTE *__userpurge sub_10007E10@<eax>(_BYTE *a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  _BYTE *v8; // eax
  bool v9; // al
  _BYTE *v10; // eax
  struct std::_Facet_base *v11; // edi
  struct std::_Facet_base *v12; // edx
  void (__thiscall ***v13)(_DWORD, int); // eax
  int v14; // eax
  int v15; // ecx
  int v16; // ecx
  _DWORD v18[2]; // [esp-40h] [ebp-4Ch] BYREF
  int *v19; // [esp-38h] [ebp-44h]
  _BYTE *v20; // [esp-30h] [ebp-3Ch]
  bool v21; // [esp-2Ch] [ebp-38h]
  int v22; // [esp-28h] [ebp-34h]
  _BYTE *v23; // [esp-24h] [ebp-30h]
  int v24; // [esp-20h] [ebp-2Ch] BYREF
  struct std::_Facet_base *v25; // [esp-1Ch] [ebp-28h]
  int *v26; // [esp-14h] [ebp-20h]
  _DWORD *v27; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v29; // [esp-8h] [ebp-14h]
  int v30; // [esp-4h] [ebp-10h]
  int v31; // [esp+0h] [ebp-Ch]
  int v32; // [esp+4h] [ebp-8h]
  int v33; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v31 = a2;
  v32 = retaddr;
  v30 = -1;
  v29 = &loc_1003C73D;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v26 = &v33;
  v19 = &v33;
  LOBYTE(v4) = 0;
  v27 = v18;
  v23 = a1;
  v5 = *(_DWORD *)a1;
  v22 = 0;
  v20 = a1;
  v6 = *(_DWORD *)&a1[*(_DWORD *)(v5 + 4) + 56];
  if ( v6 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
  v30 = 0;
  v7 = *(_DWORD *)a1;
  v8 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  if ( *((_DWORD *)v8 + 3) )
  {
    v9 = 0;
  }
  else
  {
    v10 = (_BYTE *)*((_DWORD *)v8 + 15);
    if ( !v10 || v10 == a1 )
    {
      v9 = 1;
    }
    else
    {
      sub_10002290(v10);
      v7 = *(_DWORD *)a1;
      v9 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] == 0;
    }
  }
  v21 = v9;
  v30 = 1;
  if ( v9 )
  {
    v11 = *(struct std::_Facet_base **)(*(_DWORD *)&a1[*(_DWORD *)(v7 + 4) + 48] + 4);
    v25 = v11;
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v11 + 4))(v11);
    LOBYTE(v30) = 2;
    v12 = sub_100066A0((int)&v24);
    v25 = v12;
    if ( v11 )
    {
      v13 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v11 + 8))(v11);
      if ( v13 )
        (**v13)(v13, 1);
      v12 = v25;
    }
    v14 = *(_DWORD *)a1;
    v15 = (int)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
    LOBYTE(v30) = 3;
    LOBYTE(v24) = 0;
    LOBYTE(v14) = *(_BYTE *)(v15 + 64);
    v4 = *(_BYTE *)sub_10008090(v12, (int)&v24, v15, v14, a3, v24, *(_DWORD *)(v15 + 56)) != 0 ? 4 : 0;
    v30 = 1;
  }
  sub_10001870(
    &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)],
    v4 | a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 12] | (*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56] != 0 ? 0 : 4),
    0);
  if ( !(unsigned __int8)j____uncaught_exception(v18[0], v18[1], v19) )
    sub_100023A0(a1);
  v30 = 5;
  v16 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
  if ( v16 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v16 + 8))(v16);
  return a1;
}
// 10007E10: could not find valid save-restore pair for ebp
// 1001BDB7: using guessed type int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD);

//----- (10007FE0) --------------------------------------------------------
void __thiscall sub_10007FE0(void **this)
{
  _DWORD *v2; // eax

  v2 = *this;
  if ( *this )
  {
    if ( (((_BYTE *)this[2] - (_BYTE *)v2) & 0xFFFFFFF0) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_1001D481(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (10008040) --------------------------------------------------------
void __thiscall sub_10008040(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
}

//----- (10008060) --------------------------------------------------------
int __thiscall sub_10008060(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  (*(void (__thiscall **)(void *, int, int, int, int, int, int))(*(_DWORD *)this + 12))(this, a2, a6, a7, a3, a4, a5);
  return a2;
}

//----- (10008090) --------------------------------------------------------
int __thiscall sub_10008090(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  (*(void (__thiscall **)(void *, int, int, int, int, int, int))(*(_DWORD *)this + 36))(this, a2, a6, a7, a3, a4, a5);
  return a2;
}

//----- (100080C0) --------------------------------------------------------
void __noreturn sub_100080C0()
{
  sub_1001C02E((int)"invalid vector subscript");
}
// 100080C0: using guessed type void __noreturn sub_100080C0();

//----- (100080D0) --------------------------------------------------------
_DWORD *__thiscall sub_100080D0(const void **this, _BYTE *Src, _DWORD *a3)
{
  int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // esi
  size_t v7; // esi
  void *v8; // eax
  _DWORD *v9; // edi
  _BYTE *v10; // eax
  const void *v11; // ecx
  void *v12; // eax
  _DWORD *result; // eax
  int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]
  _DWORD *v16; // [esp+10h] [ebp-4h]

  v15 = (Src - (_BYTE *)*this) >> 4;
  v4 = ((_BYTE *)this[1] - (_BYTE *)*this) >> 4;
  if ( v4 == 0xFFFFFFF )
    sub_10008240();
  v14 = v4 + 1;
  v5 = ((_BYTE *)this[2] - (_BYTE *)*this) >> 4;
  if ( v5 > 0xFFFFFFF - (v5 >> 1) )
    goto LABEL_22;
  v6 = v5 + (v5 >> 1);
  if ( v6 < v4 + 1 )
    v6 = v4 + 1;
  if ( v6 > 0xFFFFFFF )
    goto LABEL_22;
  v7 = 16 * v6;
  if ( v7 < 0x1000 )
  {
    if ( v7 )
      v9 = operator new(v7);
    else
      v9 = 0;
    goto LABEL_13;
  }
  if ( v7 + 35 <= v7 )
LABEL_22:
    sub_10001240();
  v8 = operator new(v7 + 35);
  if ( !v8 )
    goto LABEL_24;
  v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
  *(v9 - 1) = v8;
LABEL_13:
  v16 = &v9[4 * v15];
  *v16 = *a3;
  v16[1] = a3[1];
  v16[2] = a3[2];
  v16[3] = a3[3];
  v10 = this[1];
  v11 = *this;
  if ( Src == v10 )
  {
    memmove(v9, v11, v10 - (_BYTE *)v11);
  }
  else
  {
    memmove(v9, v11, Src - (_BYTE *)v11);
    memmove(v16 + 4, Src, (_BYTE *)this[1] - Src);
  }
  v12 = (void *)*this;
  if ( *this )
  {
    if ( (((_BYTE *)this[2] - (_BYTE *)v12) & 0xFFFFFFF0) < 0x1000 )
    {
LABEL_20:
      sub_1001D481(v12);
      goto LABEL_21;
    }
    if ( (unsigned int)v12 - *((_DWORD *)v12 - 1) - 4 <= 0x1F )
    {
      v12 = (void *)*((_DWORD *)v12 - 1);
      goto LABEL_20;
    }
LABEL_24:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_21:
  *this = v9;
  this[1] = &v9[4 * v14];
  result = v16;
  this[2] = &v9[v7 / 4];
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10008240) --------------------------------------------------------
void __noreturn sub_10008240()
{
  sub_1001C00E((int)"vector too long");
}
// 10008240: using guessed type void __noreturn sub_10008240();

//----- (10008250) --------------------------------------------------------
int __cdecl sub_10008250(va_list ArgList)
{
  char *Format; // ecx
  _DWORD *v2; // eax
  int result; // eax
  unsigned __int64 v4; // [esp-1Ch] [ebp-1Ch]
  const char *v5; // [esp-Ch] [ebp-Ch]

  v5 = Format;
  v2 = sub_10001080();
  HIDWORD(v4) = v2[1];
  LODWORD(v4) = *v2 | 2;
  result = __stdio_common_vsprintf(v4, 0, 0, v5, 0, ArgList);
  if ( result < 0 )
    return -1;
  return result;
}
// 1000825B: variable 'Format' is possibly undefined

//----- (10008290) --------------------------------------------------------
int sub_10008290(char *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_10008250(va);
}

//----- (100082B0) --------------------------------------------------------
void **__thiscall sub_100082B0(_DWORD *this, void **a2)
{
  int v2; // eax
  void *v3; // edx
  void **v4; // ecx
  char v5; // bl
  void *v6; // edx
  void *v7; // edx
  void *v9[5]; // [esp+8h] [ebp-40h] BYREF
  unsigned int v10; // [esp+1Ch] [ebp-2Ch]
  void *Block[5]; // [esp+20h] [ebp-28h] BYREF
  unsigned int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  int v14; // [esp+44h] [ebp-4h]

  v2 = this[1];
  v13 = 0;
  if ( v2 )
  {
    v3 = *(void **)(v2 + 24);
    if ( !v3 )
      v3 = (void *)(v2 + 28);
    memset(v9, 0, sizeof(v9));
    v10 = 0;
    v14 = 0;
    sub_10001C50(v9, v3, strlen((const char *)v3));
    v4 = v9;
    v5 = 5;
  }
  else
  {
    v12 = 15;
    memset(Block, 0, sizeof(Block));
    v4 = Block;
    v5 = 6;
  }
  *a2 = *v4;
  a2[1] = v4[1];
  a2[2] = v4[2];
  a2[3] = v4[3];
  a2[4] = v4[4];
  a2[5] = v4[5];
  v4[4] = 0;
  v4[5] = (void *)15;
  *(_BYTE *)v4 = 0;
  if ( (v5 & 2) != 0 )
  {
    v5 &= ~2u;
    if ( v12 >= 0x10 )
    {
      v6 = Block[0];
      if ( v12 + 1 >= 0x1000 )
      {
        v6 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v6 - 4) > 0x1F )
          goto LABEL_17;
      }
      sub_1001D481(v6);
    }
  }
  if ( (v5 & 1) != 0 && v10 >= 0x10 )
  {
    v7 = v9[0];
    if ( v10 + 1 < 0x1000 || (v7 = (void *)*((_DWORD *)v9[0] - 1), (unsigned int)(v9[0] - v7 - 4) <= 0x1F) )
    {
      sub_1001D481(v7);
      return a2;
    }
LABEL_17:
    _invalid_parameter_noinfo_noreturn();
  }
  return a2;
}

//----- (10008400) --------------------------------------------------------
int __cdecl sub_10008400(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 20) & 0xFFFFF1FF | 0x200;
  return result;
}

//----- (10008420) --------------------------------------------------------
int __cdecl sub_10008420(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 20) & 0xFFFFF1FF | 0x800;
  return result;
}

//----- (10008440) --------------------------------------------------------
int __cdecl sub_10008440(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 20) &= ~8u;
  return result;
}

//----- (10008450) --------------------------------------------------------
int __cdecl sub_10008450(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 20) |= 8u;
  return result;
}

//----- (10008460) --------------------------------------------------------
_DWORD *__fastcall sub_10008460(_DWORD *a1, int a2)
{
  unsigned int v2; // ebx
  _BYTE *v3; // esi
  unsigned int v5; // ebx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  _BYTE v10[11]; // [esp+21h] [ebp-Bh] BYREF

  v2 = a2;
  v3 = v10;
  *(_DWORD *)&v10[7] = a1;
  if ( a2 >= 0 )
  {
    do
    {
      --v3;
      v8 = -858993459 * v2;
      LOBYTE(v8) = 4 * (v2 / 0xA);
      v7 = v8 + v2 / 0xA;
      LOBYTE(v7) = 2 * v7;
      *v3 = v2 - v7 + 48;
      v2 /= 0xAu;
    }
    while ( v2 );
  }
  else
  {
    v5 = -a2;
    do
    {
      --v3;
      v6 = -858993459 * v5;
      LOBYTE(v6) = 4 * (v5 / 0xA);
      v7 = v6 + v5 / 0xA;
      LOBYTE(v7) = 2 * v7;
      *v3 = v5 - v7 + 48;
      v5 /= 0xAu;
    }
    while ( v5 );
    *--v3 = 45;
  }
  sub_10013920(a1, v3, v10, v7);
  return a1;
}

//----- (100084E0) --------------------------------------------------------
_DWORD *__fastcall sub_100084E0(_DWORD *a1, unsigned int a2)
{
  _BYTE *v3; // esi
  int v5; // eax
  int v6; // ecx
  _BYTE v8[11]; // [esp+21h] [ebp-Bh] BYREF

  v3 = v8;
  *(_DWORD *)&v8[7] = a1;
  do
  {
    --v3;
    v5 = -858993459 * a2;
    LOBYTE(v5) = 4 * (a2 / 0xA);
    v6 = v5 + a2 / 0xA;
    LOBYTE(v6) = 2 * v6;
    *v3 = a2 - v6 + 48;
    a2 /= 0xAu;
  }
  while ( a2 );
  sub_10013920(a1, v3, v8, v6);
  return a1;
}

//----- (10008530) --------------------------------------------------------
char *__cdecl sub_10008530(float a1)
{
  char *v1; // ecx
  char *v2; // esi
  double v3; // kr00_8
  char *v4; // ecx
  int v6; // [esp+28h] [ebp+8h]

  v2 = v1;
  v3 = a1;
  v6 = sub_10008290("%f", a1);
  sub_10005FF0(v2, v6, 0);
  v4 = v2;
  if ( *((_DWORD *)v2 + 5) >= 0x10u )
    v4 = *(char **)v2;
  sub_10002460(v4, v6 + 1, "%f", v3);
  return v2;
}
// 10008550: variable 'v1' is possibly undefined

//----- (100085E0) --------------------------------------------------------
_DWORD *__thiscall sub_100085E0(_DWORD *Block, char a2)
{
  *Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';

//----- (10008610) --------------------------------------------------------
_DWORD *__thiscall sub_10008610(_DWORD *Block, char a2)
{
  *Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';

//----- (10008640) --------------------------------------------------------
_DWORD *__thiscall sub_10008640(_DWORD *Block, char a2)
{
  *Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';

//----- (10008670) --------------------------------------------------------
_DWORD *__thiscall sub_10008670(_DWORD *Block, char a2)
{
  int v3; // esi
  void (__thiscall ***v4)(_DWORD, int); // ecx
  _DWORD *v5; // eax

  v3 = Block[5];
  *Block = &std::_Node_assert::`vftable';
  while ( v3 )
  {
    v4 = (void (__thiscall ***)(_DWORD, int))v3;
    v5 = (_DWORD *)(v3 + 12);
    v3 = *(_DWORD *)(v3 + 12);
    *v5 = 0;
    (**v4)(v4, 1);
  }
  *Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004C090: using guessed type void *std::_Node_assert::`vftable';

//----- (100086C0) --------------------------------------------------------
_DWORD *__thiscall sub_100086C0(_DWORD *Block, char a2)
{
  int v2; // edi
  _DWORD *v3; // eax
  int v4; // esi
  int v5; // ebx
  void (__thiscall ***v6)(_DWORD, int); // ecx
  _DWORD *v7; // eax
  _DWORD *v9; // [esp+4h] [ebp-4h]

  v2 = Block[6];
  v9 = Block;
  *Block = &std::_Node_if::`vftable';
  while ( v2 )
  {
    v3 = (_DWORD *)(v2 + 24);
    v4 = v2;
    v2 = *(_DWORD *)(v2 + 24);
    *v3 = 0;
    v5 = Block[5];
    if ( v4 != v5 )
    {
      do
      {
        if ( !v4 )
          break;
        v6 = (void (__thiscall ***)(_DWORD, int))v4;
        v7 = (_DWORD *)(v4 + 12);
        v4 = *(_DWORD *)(v4 + 12);
        *v7 = 0;
        (**v6)(v6, 1);
      }
      while ( v4 != v5 );
      Block = v9;
    }
  }
  *Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) == 0 )
    return Block;
  sub_1001D481(Block);
  return v9;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004C0DC: using guessed type void *std::_Node_if::`vftable';

//----- (10008740) --------------------------------------------------------
_DWORD *__thiscall sub_10008740(_DWORD *Block, char a2)
{
  *Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';

//----- (10008770) --------------------------------------------------------
int __fastcall sub_10008770(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  _DWORD *i; // edi
  int j; // esi

  result = (int)a2;
  for ( i = a1; i != a2; i = (_DWORD *)i[3] )
  {
    if ( !i )
      break;
    result = i[1] - 10;
    switch ( i[1] )
    {
      case 0xA:
      case 0xB:
        result = sub_10008770(0);
        break;
      case 0x10:
        if ( a3 )
          a3[9] = 0;
        for ( j = i[6]; j; j = *(_DWORD *)(j + 24) )
          result = sub_10008770(a3);
        break;
      case 0x12:
        if ( a3 )
        {
          a3[9] = 0;
          i[9] = 0;
        }
        else
        {
          a3 = i;
        }
        break;
      case 0x13:
        if ( a3 == (_DWORD *)i[5] )
        {
          if ( a3[9] == -1 )
            a3[9] = 1;
          a3 = 0;
        }
        break;
      default:
        continue;
    }
  }
  return result;
}

//----- (10008850) --------------------------------------------------------
int __stdcall sub_10008850(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004AC88;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_6:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_6;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (100088E0) --------------------------------------------------------
int __cdecl sub_100088E0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 4))(*(_DWORD *)(a1 + 12));
}

//----- (10008900) --------------------------------------------------------
int __stdcall sub_10008900(_DWORD **a1)
{
  void *v1; // esi
  int result; // eax
  int v3; // edi
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  _DWORD *v8; // edi
  _DWORD *v9; // esi
  void (__thiscall ***v10)(_DWORD, int); // ecx
  void *Block; // [esp+8h] [ebp-1Ch]
  _DWORD *v12; // [esp+Ch] [ebp-18h]
  _DWORD *v13; // [esp+14h] [ebp-10h]

  v1 = a1;
  result = (*(int (__stdcall **)(_DWORD *))(*a1[3] + 8))(a1[3]);
  v3 = result;
  if ( !result )
  {
    v4 = a1[1];
    *a1 = &Direct3DDevice8::`vftable';
    Block = v4;
    if ( v4 )
    {
      v5 = v4 + 1;
      v6 = v4 + 65;
      v12 = v5;
      v13 = v6;
      v7 = v5;
      if ( v5 != v6 )
      {
        do
        {
          v8 = (_DWORD *)v7[1];
          v9 = (_DWORD *)*v8;
          if ( (_DWORD *)*v8 != v8 )
          {
            do
            {
              v10 = (void (__thiscall ***)(_DWORD, int))v9[3];
              if ( v10 )
                (**v10)(v10, 1);
              v9 = (_DWORD *)*v9;
            }
            while ( v9 != v8 );
            v6 = v13;
          }
          v7 += 8;
        }
        while ( v7 != v6 );
        v1 = a1;
        v3 = 0;
        v5 = v12;
      }
      `eh vector destructor iterator'(v5, 0x20u, 8u, sub_1001BBE0);
      sub_1001D481(Block);
    }
    sub_1001D481(v1);
    return v3;
  }
  return result;
}
// 1004A9F0: using guessed type void *Direct3DDevice8::`vftable';

//----- (100089E0) --------------------------------------------------------
int __cdecl sub_100089E0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 12))(*(_DWORD *)(a1 + 12));
}

//----- (10008A00) --------------------------------------------------------
int __cdecl sub_10008A00(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 16))(*(_DWORD *)(a1 + 12));
}

//----- (10008A20) --------------------------------------------------------
int __stdcall sub_10008A20(int a1, int a2)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 12) + 20))(*(_DWORD *)(a1 + 12));
}

//----- (10008A40) --------------------------------------------------------
int __stdcall sub_10008A40(int a1, _DWORD *a2)
{
  if ( !a2 )
    return -2005530516;
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 8) + 4))(*(_DWORD *)(a1 + 8));
  *a2 = *(_DWORD *)(a1 + 8);
  return 0;
}

//----- (10008A70) --------------------------------------------------------
int __stdcall sub_10008A70(int a1, _DWORD *a2)
{
  int result; // eax
  unsigned int v3; // eax
  int v4[76]; // [esp+10h] [ebp-130h] BYREF

  if ( !a2 )
    return -2005530516;
  result = (*(int (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 12) + 28))(*(_DWORD *)(a1 + 12), v4);
  if ( result >= 0 )
  {
    v3 = v4[50];
    qmemcpy(a2, v4, 0xD4u);
    a2[3] |= 0x80000u;
    a2[9] |= 0x4000u;
    a2[34] &= ~0x100u;
    a2[51] = -65276;
    a2[49] = -130815;
    if ( v3 > 0x100 )
      v3 = 256;
    a2[50] = v3;
    return 0;
  }
  return result;
}

//----- (10008B10) --------------------------------------------------------
int __stdcall sub_10008B10(int a1, int a2)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, int))(**(_DWORD **)(a1 + 12) + 32))(*(_DWORD *)(a1 + 12), 0, a2);
}

//----- (10008B30) --------------------------------------------------------
int __cdecl sub_10008B30(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 36))(*(_DWORD *)(a1 + 12));
}

//----- (10008B50) --------------------------------------------------------
int __stdcall sub_10008B50(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    return (*(int (__stdcall **)(_DWORD, int, int, _DWORD))(**(_DWORD **)(a1 + 12) + 40))(
             *(_DWORD *)(a1 + 12),
             a2,
             a3,
             *(_DWORD *)(a4 + 12));
  else
    return -2005530516;
}

//----- (10008B80) --------------------------------------------------------
int __cdecl sub_10008B80(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 44))(*(_DWORD *)(a1 + 12));
}

//----- (10008BA0) --------------------------------------------------------
int __cdecl sub_10008BA0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 48))(*(_DWORD *)(a1 + 12));
}

//----- (10008BC0) --------------------------------------------------------
int __stdcall sub_10008BC0(_DWORD *Block, _DWORD *a2, _DWORD *a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _DWORD *v6; // edi
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _DWORD *v9; // esi
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _DWORD *v12; // ebx
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  int v15; // ecx
  int v16; // ecx
  int result; // eax
  _DWORD *v18; // esi
  int v19; // ecx
  int v20; // eax
  _DWORD v21[4]; // [esp+Ch] [ebp-58h] BYREF
  int v22; // [esp+1Ch] [ebp-48h]
  int v23; // [esp+20h] [ebp-44h]
  int v24; // [esp+2Ch] [ebp-38h]
  int v25; // [esp+34h] [ebp-30h]
  int v26; // [esp+44h] [ebp-20h] BYREF
  int v27; // [esp+48h] [ebp-1Ch]
  int v28; // [esp+54h] [ebp-10h] BYREF
  int v29; // [esp+60h] [ebp-4h]
  int savedregs; // [esp+64h] [ebp+0h] BYREF

  v3 = sub_10006250(&dword_10053148, "Redirecting '");
  v4 = sub_10006250(v3, "IDirect3DDevice8::CreateAdditionalSwapChain");
  v5 = sub_10006250(v4, "(");
  v6 = Block;
  v7 = sub_10007C40(v5, (int)&savedregs, (int)Block);
  v8 = sub_10006250(v7, ", ");
  v9 = a2;
  v10 = sub_10007C40(v8, (int)&savedregs, (int)a2);
  v11 = sub_10006250(v10, ", ");
  v12 = a3;
  v13 = sub_10007C40(v11, (int)&savedregs, (int)a3);
  v14 = sub_10006250(v13, ")' ...");
  sub_100064E0(v14);
  if ( !v9 || !v12 )
    return -2005530516;
  *v12 = 0;
  sub_1001BB20(v9, v21);
  if ( v22 )
  {
    v15 = v6[3];
    Block = 0;
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)v15 + 36))(v15, &v26);
    if ( !(*(int (__stdcall **)(_DWORD, int, int, _DWORD, int, int, _DWORD **))(**(_DWORD **)(v6[2] + 4) + 44))(
            *(_DWORD *)(v6[2] + 4),
            v26,
            v27,
            v21[2],
            v24,
            v22,
            &Block)
      && !(*(int (__stdcall **)(_DWORD, int, int, int, int, int, _DWORD **))(**(_DWORD **)(v6[2] + 4) + 44))(
            *(_DWORD *)(v6[2] + 4),
            v26,
            v27,
            v25,
            v24,
            v22,
            &Block) )
    {
      if ( Block )
        v23 = (int)Block - 1;
      else
        v23 = 0;
    }
  }
  v16 = v6[3];
  v28 = 0;
  result = (*(int (__stdcall **)(int, _DWORD *, int *))(*(_DWORD *)v16 + 52))(v16, v21, &v28);
  if ( result >= 0 )
  {
    v18 = operator new(0x10u);
    Block = v18;
    v29 = 0;
    v19 = v28;
    v18[1] = &AddressLookupTableObject::`vftable';
    LOBYTE(v29) = 1;
    *v18 = &Direct3DSwapChain8::`vftable';
    v18[1] = &Direct3DSwapChain8::`vftable';
    v18[2] = v6;
    v18[3] = v19;
    v20 = v6[1];
    a2 = (_DWORD *)v19;
    if ( v19 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v20 + 228), (unsigned __int8 *)&a2) = v18 + 1;
    *a3 = v18;
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C2C8: using guessed type void *Direct3DSwapChain8::`vftable';
// 1004C2D0: using guessed type void *Direct3DSwapChain8::`vftable';
// 10053148: using guessed type int dword_10053148;

//----- (10008D90) --------------------------------------------------------
int __stdcall sub_10008D90(_DWORD *a1, _DWORD *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  int v10; // eax
  int v11; // [esp+40h] [ebp-4Ch] BYREF
  int v12; // [esp+44h] [ebp-48h] BYREF
  int v13; // [esp+48h] [ebp-44h]
  int v14[4]; // [esp+54h] [ebp-38h] BYREF
  int v15; // [esp+64h] [ebp-28h]
  int v16; // [esp+68h] [ebp-24h]
  int v17; // [esp+74h] [ebp-18h]
  int v18; // [esp+7Ch] [ebp-10h]
  int savedregs; // [esp+8Ch] [ebp+0h] BYREF

  v2 = sub_10006250(&dword_10053148, "Redirecting '");
  v3 = sub_10006250(v2, "IDirect3DDevice8::Reset");
  v4 = sub_10006250(v3, "(");
  v5 = sub_10007C40(v4, (int)&savedregs, (int)a1);
  v6 = sub_10006250(v5, ", ");
  v7 = sub_10007C40(v6, (int)&savedregs, (int)a2);
  v8 = sub_10006250(v7, ")' ...");
  sub_100064E0(v8);
  if ( !a2 )
    return -2005530516;
  a1[8] = 0;
  sub_1001BB20(a2, v14);
  if ( v15 )
  {
    v10 = a1[3];
    v11 = 0;
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)v10 + 36))(v10, &v12);
    if ( !(*(int (__stdcall **)(_DWORD, int, int, int, int, int, int *))(**(_DWORD **)(a1[2] + 4) + 44))(
            *(_DWORD *)(a1[2] + 4),
            v12,
            v13,
            v14[2],
            v17,
            v15,
            &v11)
      && !(*(int (__stdcall **)(_DWORD, int, int, int, int, int, int *))(**(_DWORD **)(a1[2] + 4) + 44))(
            *(_DWORD *)(a1[2] + 4),
            v12,
            v13,
            v18,
            v17,
            v15,
            &v11) )
    {
      if ( v11 )
        v16 = v11 - 1;
      else
        v16 = 0;
    }
  }
  return (*(int (__stdcall **)(_DWORD, int *))(*(_DWORD *)a1[3] + 64))(a1[3], v14);
}
// 10053148: using guessed type int dword_10053148;

//----- (10008EC0) --------------------------------------------------------
int __cdecl sub_10008EC0(int a1, int a2, int a3, int a4, int a5)
{
  return (*(int (__cdecl **)(_DWORD, int, int, int, _DWORD))(**(_DWORD **)(a1 + 12) + 68))(
           *(_DWORD *)(a1 + 12),
           a2,
           a3,
           a4,
           0);
}

//----- (10008EE0) --------------------------------------------------------
int __userpurge sub_10008EE0@<eax>(int a1@<esi>, int a2, int a3, void *Block, _DWORD *a5)
{
  int result; // eax
  int v6; // esi
  int v7; // ecx
  int *v8; // esi
  int v9; // ebx
  _DWORD *v10; // edi
  int *v11; // edi
  int v12; // ecx
  _DWORD *v13; // ecx
  void *v14; // [esp-Ch] [ebp-24h]
  int *v16; // [esp+0h] [ebp-18h] BYREF
  int v17; // [esp+8h] [ebp-10h] BYREF
  int v18; // [esp+14h] [ebp-4h]

  if ( !a5 )
    return -2005530516;
  v6 = a2;
  v14 = Block;
  *a5 = 0;
  v7 = *(_DWORD *)(v6 + 12);
  v17 = 0;
  result = (*(int (__stdcall **)(int, _DWORD, int, void *, int *, int))(*(_DWORD *)v7 + 72))(v7, 0, a3, v14, &v17, a1);
  if ( result >= 0 )
  {
    v8 = *(int **)(v6 + 4);
    v9 = v17;
    a2 = v17;
    if ( v17 )
    {
      v11 = sub_10016580(
              v8 + 1,
              &v16,
              &a2,
              16777619
            * (HIBYTE(v17) ^ (16777619
                            * (BYTE2(v17) ^ (16777619 * (BYTE1(v17) ^ (16777619 * ((unsigned __int8)v17 ^ 0x811C9DC5))))))))[1];
      if ( !v11 )
        v11 = (int *)v8[2];
      if ( v11 == (int *)v8[2] )
      {
        v10 = operator new(0x10u);
        Block = v10;
        v18 = 0;
        v12 = *v8;
        v10[1] = &AddressLookupTableObject::`vftable';
        LOBYTE(v18) = 1;
        v10[2] = v12;
        *v10 = &Direct3DSurface8::`vftable';
        v10[1] = &Direct3DSurface8::`vftable';
        v10[3] = v9;
        v13 = (_DWORD *)(*(_DWORD *)(v12 + 4) + 4);
        a2 = v9;
        *(_DWORD *)sub_1001A560(v13, (unsigned __int8 *)&a2) = v10 + 1;
      }
      else
      {
        v10 = v11[3] != 0 ? (_DWORD *)(v11[3] - 4) : 0;
      }
    }
    else
    {
      v10 = 0;
    }
    *a5 = v10;
    return 0;
  }
  return result;
}
// 10008EE0: could not find valid save-restore pair for esi
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (10009020) --------------------------------------------------------
int __stdcall sub_10009020(int a1, int a2)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, int))(**(_DWORD **)(a1 + 12) + 76))(*(_DWORD *)(a1 + 12), 0, a2);
}

//----- (10009040) --------------------------------------------------------
int __stdcall sub_10009040(int a1, int a2, int a3)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, int, int))(**(_DWORD **)(a1 + 12) + 84))(*(_DWORD *)(a1 + 12), 0, a2, a3);
}

//----- (10009060) --------------------------------------------------------
int __stdcall sub_10009060(int a1, int a2)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, int))(**(_DWORD **)(a1 + 12) + 88))(*(_DWORD *)(a1 + 12), 0, a2);
}

//----- (10009080) --------------------------------------------------------
int __stdcall sub_10009080(int a1, int a2, int a3, int a4, int a5, int a6, void *Block, _DWORD *a8)
{
  _DWORD *v8; // edi
  int result; // eax
  bool v10; // zf
  int v11; // esi
  int v12; // ecx
  _DWORD *v13; // esi
  _DWORD *v14; // ecx
  int v15; // eax
  int v16[4]; // [esp+4h] [ebp-1Ch] BYREF
  int v17; // [esp+1Ch] [ebp-4h]

  v8 = a8;
  if ( !a8 )
    return -2005530516;
  v10 = Block == 0;
  *a8 = 0;
  if ( v10 )
  {
    (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 12) + 36))(*(_DWORD *)(a1 + 12), v16);
    v11 = a5;
    if ( (a5 & 0x200) != 0
      || (*(int (__stdcall **)(_DWORD, int, int, int, int, int, int))(**(_DWORD **)(*(_DWORD *)(a1 + 8) + 4) + 40))(
           *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4),
           v16[0],
           v16[1],
           22,
           1,
           3,
           a6) < 0 )
    {
      if ( v11 != 2 )
        v11 |= 0x200u;
    }
    else
    {
      v11 |= 1u;
    }
  }
  else
  {
    v11 = a5;
  }
  v12 = *(_DWORD *)(a1 + 12);
  a8 = 0;
  result = (*(int (__stdcall **)(int, int, int, int, int, int, void *, _DWORD **, _DWORD))(*(_DWORD *)v12 + 92))(
             v12,
             a2,
             a3,
             a4,
             v11,
             a6,
             Block,
             &a8,
             0);
  if ( result >= 0 )
  {
    v13 = operator new(0x10u);
    Block = v13;
    v17 = 0;
    v14 = a8;
    v13[1] = &AddressLookupTableObject::`vftable';
    LOBYTE(v17) = 1;
    *v13 = &Direct3DTexture8::`vftable';
    v13[1] = &Direct3DTexture8::`vftable';
    v13[2] = a1;
    v13[3] = v14;
    v15 = *(_DWORD *)(a1 + 4);
    a5 = (int)v14;
    if ( v14 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v15 + 36), (unsigned __int8 *)&a5) = v13 + 1;
    *v8 = v13;
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C318: using guessed type void *Direct3DTexture8::`vftable';
// 1004C330: using guessed type void *Direct3DTexture8::`vftable';

//----- (100091B0) --------------------------------------------------------
int __stdcall sub_100091B0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, void *Block, _DWORD *a9)
{
  _DWORD *v9; // edi
  int result; // eax
  int v11; // ecx
  int v12; // ecx
  _DWORD *v13; // esi
  _DWORD *v14; // ecx
  int v15; // eax
  int v16; // eax
  void *v17; // [esp-Ch] [ebp-24h]

  v9 = a9;
  if ( !a9 )
    return -2005530516;
  v11 = (int)a1;
  v17 = Block;
  *a9 = 0;
  v12 = *(_DWORD *)(v11 + 12);
  a9 = 0;
  result = (*(int (__stdcall **)(int, int, int, int, int, int, int, void *, _DWORD **, _DWORD))(*(_DWORD *)v12 + 96))(
             v12,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             v17,
             &a9,
             0);
  if ( result >= 0 )
  {
    v13 = operator new(0x10u);
    Block = v13;
    v14 = a9;
    v13[1] = &AddressLookupTableObject::`vftable';
    v15 = (int)a1;
    *v13 = &Direct3DVolumeTexture8::`vftable';
    v13[1] = &Direct3DVolumeTexture8::`vftable';
    v13[2] = v15;
    v13[3] = v14;
    v16 = *(_DWORD *)(v15 + 4);
    a1 = v14;
    if ( v14 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v16 + 68), (unsigned __int8 *)&a1) = v13 + 1;
    *v9 = v13;
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C308: using guessed type void *Direct3DVolumeTexture8::`vftable';
// 1004C390: using guessed type void *Direct3DVolumeTexture8::`vftable';

//----- (10009290) --------------------------------------------------------
int __stdcall sub_10009290(_DWORD *a1, int a2, int a3, int a4, int a5, void *Block, _DWORD *a7)
{
  _DWORD *v7; // edi
  int result; // eax
  int v9; // ecx
  int v10; // ecx
  _DWORD *v11; // esi
  _DWORD *v12; // ecx
  int v13; // eax
  int v14; // eax
  void *v15; // [esp-Ch] [ebp-24h]

  v7 = a7;
  if ( !a7 )
    return -2005530516;
  v9 = (int)a1;
  v15 = Block;
  *a7 = 0;
  v10 = *(_DWORD *)(v9 + 12);
  a7 = 0;
  result = (*(int (__stdcall **)(int, int, int, int, int, void *, _DWORD **, _DWORD))(*(_DWORD *)v10 + 100))(
             v10,
             a2,
             a3,
             a4,
             a5,
             v15,
             &a7,
             0);
  if ( result >= 0 )
  {
    v11 = operator new(0x10u);
    Block = v11;
    v12 = a7;
    v11[1] = &AddressLookupTableObject::`vftable';
    v13 = (int)a1;
    *v11 = &Direct3DCubeTexture8::`vftable';
    v11[1] = &Direct3DCubeTexture8::`vftable';
    v11[2] = v13;
    v11[3] = v12;
    v14 = *(_DWORD *)(v13 + 4);
    a1 = v12;
    if ( v12 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v14 + 100), (unsigned __int8 *)&a1) = v11 + 1;
    *v7 = v11;
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C310: using guessed type void *Direct3DCubeTexture8::`vftable';
// 1004C3F0: using guessed type void *Direct3DCubeTexture8::`vftable';

//----- (10009370) --------------------------------------------------------
int __stdcall sub_10009370(_DWORD *a1, int a2, int a3, int a4, void *Block, _DWORD *a6)
{
  _DWORD *v6; // edi
  int result; // eax
  int v8; // ecx
  int v9; // ecx
  _DWORD *v10; // esi
  _DWORD *v11; // ecx
  int v12; // eax
  int v13; // eax
  void *v14; // [esp-Ch] [ebp-24h]

  v6 = a6;
  if ( !a6 )
    return -2005530516;
  v8 = (int)a1;
  v14 = Block;
  *a6 = 0;
  v9 = *(_DWORD *)(v8 + 12);
  a6 = 0;
  result = (*(int (__stdcall **)(int, int, int, int, void *, _DWORD **, _DWORD))(*(_DWORD *)v9 + 104))(
             v9,
             a2,
             a3,
             a4,
             v14,
             &a6,
             0);
  if ( result >= 0 )
  {
    v10 = operator new(0x10u);
    Block = v10;
    v11 = a6;
    v10[1] = &AddressLookupTableObject::`vftable';
    v12 = (int)a1;
    *v10 = &Direct3DVertexBuffer8::`vftable';
    v10[1] = &Direct3DVertexBuffer8::`vftable';
    v10[2] = v12;
    v10[3] = v11;
    v13 = *(_DWORD *)(v12 + 4);
    a1 = v11;
    if ( v11 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v13 + 164), (unsigned __int8 *)&a1) = v10 + 1;
    *v6 = v10;
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C440: using guessed type void *Direct3DVertexBuffer8::`vftable';
// 1004C47C: using guessed type void *Direct3DVertexBuffer8::`vftable';

//----- (10009450) --------------------------------------------------------
int __stdcall sub_10009450(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  _DWORD *v6; // edi
  int result; // eax
  _DWORD *v8; // ecx
  int v9; // ecx
  _DWORD *v10; // esi
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  int v13; // eax
  _DWORD *v14; // [esp-Ch] [ebp-24h]

  v6 = a6;
  if ( !a6 )
    return -2005530516;
  v8 = a1;
  v14 = a5;
  *a6 = 0;
  v9 = v8[3];
  a6 = 0;
  result = (*(int (__stdcall **)(int, int, int, int, _DWORD *, _DWORD **, _DWORD))(*(_DWORD *)v9 + 108))(
             v9,
             a2,
             a3,
             a4,
             v14,
             &a6,
             0);
  if ( result >= 0 )
  {
    v10 = operator new(0x10u);
    a5 = v10;
    v11 = a6;
    v10[1] = &AddressLookupTableObject::`vftable';
    v12 = a1;
    *v10 = &Direct3DIndexBuffer8::`vftable';
    v10[1] = &Direct3DIndexBuffer8::`vftable';
    v10[2] = v12;
    v10[3] = v11;
    v13 = v12[1];
    a1 = v11;
    if ( v11 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v13 + 196), (unsigned __int8 *)&a1) = v10 + 1;
    *v6 = v10;
    return 0;
  }
  return result;
}
// 1004C214: using guessed type void *Direct3DIndexBuffer8::`vftable';
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C244: using guessed type void *Direct3DIndexBuffer8::`vftable';

//----- (10009530) --------------------------------------------------------
int __stdcall sub_10009530(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  int result; // eax
  int v8; // edx
  int v9; // esi
  int v10; // ecx
  _DWORD *v11; // edi
  _DWORD *v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15[4]; // [esp+4h] [ebp-20h] BYREF
  int v16; // [esp+14h] [ebp-10h] BYREF
  int v17; // [esp+20h] [ebp-4h]

  if ( !a7 )
    return -2005530516;
  v8 = 0;
  v9 = a5;
  *a7 = 0;
  v16 = 0;
  if ( v9 )
  {
    (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 12) + 36))(*(_DWORD *)(a1 + 12), v15);
    (*(void (__stdcall **)(_DWORD, int, int, int, _DWORD, int, int *))(**(_DWORD **)(*(_DWORD *)(a1 + 8) + 4) + 44))(
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4),
      v15[0],
      v15[1],
      a4,
      0,
      v9,
      &v16);
    if ( v16 )
      v8 = v16 - 1;
    else
      v8 = 0;
    v16 = v8;
  }
  v10 = *(_DWORD *)(a1 + 12);
  a5 = 0;
  result = (*(int (__stdcall **)(int, int, int, int, int, int, int, int *, _DWORD))(*(_DWORD *)v10 + 112))(
             v10,
             a2,
             a3,
             a4,
             v9,
             v8,
             a6,
             &a5,
             0);
  v11 = a7;
  if ( result >= 0 )
  {
    v12 = operator new(0x10u);
    a7 = v12;
    v17 = 0;
    v13 = a5;
    v12[1] = &AddressLookupTableObject::`vftable';
    LOBYTE(v17) = 1;
    *v12 = &Direct3DSurface8::`vftable';
    v12[1] = &Direct3DSurface8::`vftable';
    v12[2] = a1;
    v12[3] = v13;
    v14 = *(_DWORD *)(a1 + 4);
    a4 = v13;
    if ( v13 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v14 + 4), (unsigned __int8 *)&a4) = v12 + 1;
    *v11 = v12;
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (10009650) --------------------------------------------------------
int __stdcall sub_10009650(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int result; // eax
  int v7; // edx
  int v8; // esi
  int v9; // ecx
  _DWORD *v10; // edi
  _DWORD *v11; // esi
  int v12; // ecx
  int v13; // eax
  int v14; // [esp-14h] [ebp-38h]
  int v15[4]; // [esp+4h] [ebp-20h] BYREF
  int v16; // [esp+14h] [ebp-10h] BYREF
  int v17; // [esp+20h] [ebp-4h]

  if ( !a6 )
    return -2005530516;
  v7 = 0;
  v8 = a5;
  *a6 = 0;
  v16 = 0;
  if ( v8 )
  {
    (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 12) + 36))(*(_DWORD *)(a1 + 12), v15);
    (*(void (__stdcall **)(_DWORD, int, int, int, _DWORD, int, int *))(**(_DWORD **)(*(_DWORD *)(a1 + 8) + 4) + 44))(
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4),
      v15[0],
      v15[1],
      a4,
      0,
      v8,
      &v16);
    if ( v16 )
      v7 = v16 - 1;
    else
      v7 = 0;
    v16 = v7;
  }
  v9 = *(_DWORD *)(a1 + 12);
  v14 = *(_DWORD *)(a1 + 20);
  a5 = 0;
  result = (*(int (__stdcall **)(int, int, int, int, int, int, int, int *, _DWORD))(*(_DWORD *)v9 + 116))(
             v9,
             a2,
             a3,
             a4,
             v8,
             v7,
             v14,
             &a5,
             0);
  v10 = a6;
  if ( result >= 0 )
  {
    v11 = operator new(0x10u);
    a6 = v11;
    v17 = 0;
    v12 = a5;
    v11[1] = &AddressLookupTableObject::`vftable';
    LOBYTE(v17) = 1;
    *v11 = &Direct3DSurface8::`vftable';
    v11[1] = &Direct3DSurface8::`vftable';
    v11[2] = a1;
    v11[3] = v12;
    v13 = *(_DWORD *)(a1 + 4);
    a4 = v12;
    if ( v12 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v13 + 4), (unsigned __int8 *)&a4) = v11 + 1;
    *v10 = v11;
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (10009770) --------------------------------------------------------
int __stdcall sub_10009770(int a1, void *Block, int a3, int a4, _DWORD *a5)
{
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  int v14; // esi
  _BYTE *v15; // eax
  _BYTE *v16; // eax
  _DWORD *v17; // edi
  _BYTE *v18; // eax
  _BYTE *v19; // eax
  _BYTE *v21; // eax
  int v22; // ecx
  int v23; // edi
  _BYTE *v24; // eax
  _BYTE *v25; // eax
  _BYTE *v26; // eax
  _DWORD *v27; // esi
  int v28; // ecx
  int v29; // eax
  int v30; // [esp+Ch] [ebp-10h] BYREF
  int v31; // [esp+18h] [ebp-4h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v5 = sub_10006250(&dword_10053148, "Redirecting '");
  v6 = sub_10006250(v5, "IDirect3DDevice8::CreateImageSurface");
  v7 = sub_10006250(v6, "(");
  v8 = sub_10007C40(v7, (int)&savedregs, a1);
  v9 = sub_10006250(v8, ", ");
  v10 = sub_100042E0(v9, (int)&savedregs, (int)Block);
  v11 = sub_10006250(v10, ", ");
  v12 = sub_100042E0(v11, (int)&savedregs, a3);
  v13 = sub_10006250(v12, ", ");
  v14 = a4;
  v15 = sub_10007E10(v13, (int)&savedregs, a4);
  v16 = sub_10006250(v15, ", ");
  v17 = a5;
  v18 = sub_10007C40(v16, (int)&savedregs, (int)a5);
  v19 = sub_10006250(v18, ")' ...");
  sub_100064E0(v19);
  if ( !v17 )
    return -2005530516;
  *v17 = 0;
  if ( v14 == 20 )
  {
    v21 = sub_10006250(&dword_10053148, "> Replacing format 'D3DFMT_R8G8B8' with 'D3DFMT_X8R8G8B8' ...");
    sub_100064E0(v21);
    v14 = 22;
  }
  v22 = *(_DWORD *)(a1 + 12);
  v30 = 0;
  v23 = (*(int (__stdcall **)(int, void *, int, int, int, int *, _DWORD))(*(_DWORD *)v22 + 144))(
          v22,
          Block,
          a3,
          v14,
          2,
          &v30,
          0);
  if ( v23 >= 0
    || (*(int (__stdcall **)(_DWORD, void *, int, int, int, int *, _DWORD))(**(_DWORD **)(a1 + 12) + 144))(
         *(_DWORD *)(a1 + 12),
         Block,
         a3,
         v14,
         3,
         &v30,
         0) >= 0 )
  {
    v27 = operator new(0x10u);
    v31 = 0;
    v28 = v30;
    v27[1] = &AddressLookupTableObject::`vftable';
    LOBYTE(v31) = 1;
    *v27 = &Direct3DSurface8::`vftable';
    v27[1] = &Direct3DSurface8::`vftable';
    v27[2] = a1;
    v27[3] = v28;
    v29 = *(_DWORD *)(a1 + 4);
    a3 = v28;
    if ( v28 )
      *(_DWORD *)sub_1001A560((_DWORD *)(v29 + 4), (unsigned __int8 *)&a3) = v27 + 1;
    *a5 = v27;
    return 0;
  }
  else
  {
    v24 = sub_10006250(&dword_10053148, "> 'IDirect3DDevice9::CreateOffscreenPlainSurface' failed with error code ");
    *(_DWORD *)&v24[*(_DWORD *)(*(_DWORD *)v24 + 4) + 20] = *(_DWORD *)&v24[*(_DWORD *)(*(_DWORD *)v24 + 4) + 20] & 0xFFFFF1FF | 0x800;
    v25 = sub_10011CA0(v24, v23);
    *(_DWORD *)&v25[*(_DWORD *)(*(_DWORD *)v25 + 4) + 20] = *(_DWORD *)&v25[*(_DWORD *)(*(_DWORD *)v25 + 4) + 20] & 0xFFFFF1FF | 0x200;
    v26 = sub_10006250(v25, "!");
    sub_100064E0(v26);
    return v23;
  }
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';
// 10053148: using guessed type int dword_10053148;

//----- (100099A0) --------------------------------------------------------
int __stdcall sub_100099A0(int a1, int a2, int *a3, unsigned int a4, int a5, int a6)
{
  int *v6; // ecx
  int *v7; // esi
  int v8; // ecx
  int v9; // edx
  int v10; // edi
  int v11; // ebx
  int v12; // ecx
  int v13; // eax
  int v14; // ebx
  _BYTE *v15; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  _BYTE *v19; // eax
  _BYTE *v20; // eax
  _BYTE *v21; // eax
  _BYTE *v22; // eax
  _BYTE *v23; // eax
  _BYTE *v24; // eax
  _BYTE *v25; // eax
  _BYTE *v26; // eax
  _BYTE *v27; // eax
  _BYTE *v28; // eax
  _BYTE *v29; // eax
  _BYTE *v30; // eax
  _BYTE *v31; // eax
  _BYTE *v32; // eax
  _BYTE *v33; // eax
  _BYTE *v34; // eax
  _BYTE *v35; // eax
  _BYTE *v36; // eax
  _BYTE *v37; // eax
  _BYTE *v38; // eax
  _BYTE *v39; // eax
  int v41; // [esp+30h] [ebp-78h]
  unsigned int v42; // [esp+34h] [ebp-74h]
  int *v43; // [esp+38h] [ebp-70h]
  int v44[2]; // [esp+40h] [ebp-68h] BYREF
  int v45[4]; // [esp+48h] [ebp-60h] BYREF
  int v46[2]; // [esp+58h] [ebp-50h] BYREF
  int v47; // [esp+60h] [ebp-48h]
  int v48; // [esp+64h] [ebp-44h]
  int v49[3]; // [esp+68h] [ebp-40h] BYREF
  int v50; // [esp+74h] [ebp-34h]
  int v51; // [esp+78h] [ebp-30h]
  int v52; // [esp+80h] [ebp-28h]
  int v53; // [esp+84h] [ebp-24h]
  int v54[3]; // [esp+88h] [ebp-20h] BYREF
  int v55; // [esp+94h] [ebp-14h]
  int v56; // [esp+98h] [ebp-10h]
  int v57; // [esp+A0h] [ebp-8h]
  int v58; // [esp+A4h] [ebp-4h]
  int savedregs; // [esp+A8h] [ebp+0h] BYREF

  if ( !a2 )
    return -2005530516;
  if ( !a5 )
    return -2005530516;
  if ( a2 == a5 )
    return -2005530516;
  (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a2 + 12) + 48))(*(_DWORD *)(a2 + 12), v49);
  (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a5 + 12) + 48))(*(_DWORD *)(a5 + 12), v54);
  if ( v49[0] != v54[0] )
    return -2005530516;
  v41 = -2005530516;
  if ( !a4 )
    a4 = 1;
  v6 = a3;
  v7 = a3;
  v42 = 0;
  v43 = a3;
  do
  {
    if ( v6 )
    {
      v8 = *v7;
      v9 = v7[1];
      v10 = v7[2];
      v11 = v7[3];
    }
    else
    {
      v10 = v52;
      v8 = 0;
      v11 = v53;
      v9 = 0;
    }
    v45[3] = v11;
    v45[1] = v9;
    v45[2] = v10;
    v45[0] = v8;
    if ( a6 )
    {
      v46[0] = *(_DWORD *)(a6 + 8 * v42);
      v47 = v10 + v46[0] - v8;
      v7 = v43;
      v12 = *(_DWORD *)(a6 + 8 * v42 + 4);
      v48 = v11 + v12 - v9;
      v13 = v46[0];
    }
    else
    {
      v13 = v8;
      v47 = v10;
      v46[0] = v8;
      v12 = v9;
      v48 = v11;
    }
    v46[1] = v12;
    if ( v50 == 1 || v55 )
    {
      v14 = -2005530516;
      if ( !dword_10053128
        || ((int (__stdcall *)(_DWORD, _DWORD, int *, _DWORD, _DWORD, int *, int, _DWORD))dword_10053128)(
             *(_DWORD *)(a5 + 12),
             0,
             v46,
             *(_DWORD *)(a2 + 12),
             0,
             v45,
             1,
             0) < 0 )
      {
        goto LABEL_22;
      }
      v14 = 0;
      v41 = 0;
    }
    else
    {
      if ( v50 )
      {
        if ( v50 == 2 )
        {
          v44[0] = v13;
          v44[1] = v12;
          v14 = (*(int (__stdcall **)(_DWORD, _DWORD, int *, _DWORD, int *))(**(_DWORD **)(a1 + 12) + 120))(
                  *(_DWORD *)(a1 + 12),
                  *(_DWORD *)(a2 + 12),
                  v45,
                  *(_DWORD *)(a5 + 12),
                  v44);
          v41 = v14;
        }
        else
        {
          v14 = v41;
        }
      }
      else
      {
        v14 = (*(int (__stdcall **)(_DWORD, _DWORD, int *, _DWORD, int *, _DWORD))(**(_DWORD **)(a1 + 12) + 136))(
                *(_DWORD *)(a1 + 12),
                *(_DWORD *)(a2 + 12),
                v45,
                *(_DWORD *)(a5 + 12),
                v46,
                0);
        v41 = v14;
      }
      if ( v14 < 0 )
      {
LABEL_22:
        v15 = sub_10006250(&dword_10053148, "Failed to translate 'IDirect3DDevice8::CopyRects' call from '[");
        v16 = sub_100042E0(v15, (int)&savedregs, v52);
        v17 = sub_10006250(v16, "x");
        v18 = sub_100042E0(v17, (int)&savedregs, v53);
        v19 = sub_10006250(v18, ", ");
        v20 = sub_10007E10(v19, (int)&savedregs, v49[0]);
        v21 = sub_10006250(v20, ", ");
        v22 = sub_10007E10(v21, (int)&savedregs, v51);
        v23 = sub_10006250(v22, ", ");
        v24 = sub_100042E0(v23, (int)&savedregs, v49[2]);
        v25 = sub_10006250(v24, ", ");
        v26 = sub_10007E10(v25, (int)&savedregs, v50);
        v27 = sub_10006250(v26, "]' to '[");
        v28 = sub_100042E0(v27, (int)&savedregs, v57);
        v29 = sub_10006250(v28, "x");
        v30 = sub_100042E0(v29, (int)&savedregs, v58);
        v31 = sub_10006250(v30, ", ");
        v32 = sub_10007E10(v31, (int)&savedregs, v54[0]);
        v33 = sub_10006250(v32, ", ");
        v34 = sub_10007E10(v33, (int)&savedregs, v56);
        v35 = sub_10006250(v34, ", ");
        v36 = sub_100042E0(v35, (int)&savedregs, v54[2]);
        v37 = sub_10006250(v36, ", ");
        v38 = sub_10007E10(v37, (int)&savedregs, v55);
        v39 = sub_10006250(v38, "]'!");
        sub_100064E0(v39);
        return v14;
      }
    }
    v7 += 4;
    v6 = a3;
    ++v42;
    v43 = v7;
  }
  while ( v42 < a4 );
  return v14;
}
// 10053128: using guessed type int dword_10053128;
// 10053148: using guessed type int dword_10053148;

//----- (10009CF0) --------------------------------------------------------
int __stdcall sub_10009CF0(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // esi
  int v4; // eax

  if ( a2
    && a3
    && (v3 = (*(int (__stdcall **)(_DWORD *))(*a2 + 40))(a2), v3 == (*(int (__stdcall **)(_DWORD *))(*a3 + 40))(a3))
    && ((v4 = (*(int (__stdcall **)(_DWORD *))(*a2 + 40))(a2) - 3) == 0 || (unsigned int)(v4 - 1) <= 1) )
  {
    return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(a1 + 12) + 124))(
             *(_DWORD *)(a1 + 12),
             a2[3],
             a3[3]);
  }
  else
  {
    return -2005530516;
  }
}

//----- (10009D50) --------------------------------------------------------
int __stdcall sub_10009D50(int a1, int a2)
{
  if ( a2 )
    return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(a1 + 12) + 132))(
             *(_DWORD *)(a1 + 12),
             0,
             *(_DWORD *)(a2 + 12));
  else
    return -2005530516;
}

//----- (10009D80) --------------------------------------------------------
int __stdcall sub_10009D80(int a1, int a2, int a3)
{
  int result; // eax
  int *v4; // eax
  int v5; // ecx

  if ( a2 )
  {
    result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(a1 + 12) + 148))(
               *(_DWORD *)(a1 + 12),
               0,
               *(_DWORD *)(a2 + 12));
    if ( result < 0 )
      return result;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 12);
  }
  v4 = *(int **)(a1 + 12);
  v5 = *v4;
  if ( !a3 )
  {
    (*(void (__stdcall **)(int *, _DWORD))(v5 + 156))(v4, 0);
    return 0;
  }
  result = (*(int (__stdcall **)(int *, _DWORD))(v5 + 156))(v4, *(_DWORD *)(a3 + 12));
  if ( result >= 0 )
    return 0;
  return result;
}

//----- (10009DE0) --------------------------------------------------------
int __userpurge sub_10009DE0@<eax>(int a1@<esi>, int a2, int **a3)
{
  int result; // eax
  int v4; // esi
  int v5; // ebx
  int *v6; // esi
  int *v7; // edi
  int *v8; // edi
  int v9; // ecx
  _DWORD *v10; // ecx
  int *v12[3]; // [esp+0h] [ebp-1Ch] BYREF
  int v13; // [esp+Ch] [ebp-10h] BYREF
  int v14; // [esp+18h] [ebp-4h]

  if ( !a3 )
    return -2005530516;
  v4 = a2;
  v13 = 0;
  result = (*(int (__stdcall **)(_DWORD, _DWORD, int *, int))(**(_DWORD **)(a2 + 12) + 152))(
             *(_DWORD *)(a2 + 12),
             0,
             &v13,
             a1);
  if ( result >= 0 )
  {
    v5 = v13;
    *(_DWORD *)(v4 + 32) = v13;
    v6 = *(int **)(v4 + 4);
    a2 = v5;
    if ( v5 )
    {
      v8 = sub_10016580(
             v6 + 1,
             v12,
             &a2,
             16777619
           * (HIBYTE(v13) ^ (16777619
                           * (BYTE2(v13) ^ (16777619 * (BYTE1(v5) ^ (16777619 * ((unsigned __int8)v5 ^ 0x811C9DC5))))))))[1];
      if ( !v8 )
        v8 = (int *)v6[2];
      if ( v8 == (int *)v6[2] )
      {
        v7 = (int *)operator new(0x10u);
        v12[2] = v7;
        v14 = 0;
        v9 = *v6;
        v7[1] = (int)&AddressLookupTableObject::`vftable';
        LOBYTE(v14) = 1;
        v7[2] = v9;
        *v7 = (int)&Direct3DSurface8::`vftable';
        v7[1] = (int)&Direct3DSurface8::`vftable';
        v7[3] = v5;
        v10 = (_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        a2 = v5;
        *(_DWORD *)sub_1001A560(v10, (unsigned __int8 *)&a2) = v7 + 1;
      }
      else
      {
        v7 = v8[3] != 0 ? (int *)(v8[3] - 4) : 0;
      }
    }
    else
    {
      v7 = 0;
    }
    *a3 = v7;
    return 0;
  }
  return result;
}
// 10009DE0: could not find valid save-restore pair for esi
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (10009F20) --------------------------------------------------------
int __userpurge sub_10009F20@<eax>(int a1@<esi>, int a2, int **a3)
{
  int result; // eax
  int v4; // esi
  int *v5; // esi
  int v6; // ebx
  int *v7; // edi
  int *v8; // edi
  int v9; // ecx
  _DWORD *v10; // ecx
  int *v12[3]; // [esp+0h] [ebp-1Ch] BYREF
  int v13; // [esp+Ch] [ebp-10h] BYREF
  int v14; // [esp+18h] [ebp-4h]

  if ( !a3 )
    return -2005530516;
  v4 = a2;
  v13 = 0;
  result = (*(int (__stdcall **)(_DWORD, int *, int))(**(_DWORD **)(a2 + 12) + 160))(*(_DWORD *)(a2 + 12), &v13, a1);
  if ( result >= 0 )
  {
    v5 = *(int **)(v4 + 4);
    v6 = v13;
    a2 = v13;
    if ( v13 )
    {
      v8 = sub_10016580(
             v5 + 1,
             v12,
             &a2,
             16777619
           * (HIBYTE(v13) ^ (16777619
                           * (BYTE2(v13) ^ (16777619 * (BYTE1(v13) ^ (16777619 * ((unsigned __int8)v13 ^ 0x811C9DC5))))))))[1];
      if ( !v8 )
        v8 = (int *)v5[2];
      if ( v8 == (int *)v5[2] )
      {
        v7 = (int *)operator new(0x10u);
        v12[2] = v7;
        v14 = 0;
        v9 = *v5;
        v7[1] = (int)&AddressLookupTableObject::`vftable';
        LOBYTE(v14) = 1;
        v7[2] = v9;
        *v7 = (int)&Direct3DSurface8::`vftable';
        v7[1] = (int)&Direct3DSurface8::`vftable';
        v7[3] = v6;
        v10 = (_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        a2 = v6;
        *(_DWORD *)sub_1001A560(v10, (unsigned __int8 *)&a2) = v7 + 1;
      }
      else
      {
        v7 = v8[3] != 0 ? (int *)(v8[3] - 4) : 0;
      }
    }
    else
    {
      v7 = 0;
    }
    *a3 = v7;
    return 0;
  }
  return result;
}
// 10009F20: could not find valid save-restore pair for esi
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (1000A060) --------------------------------------------------------
_DWORD *__thiscall sub_1000A060(_DWORD *this)
{
  __int64 perf_frequency; // kr08_8
  __int64 perf_counter; // rax
  _DWORD *result; // eax
  __int64 v5; // rax
  __int64 v6; // rcx
  unsigned int v8; // [esp+10h] [ebp-8h]

  perf_frequency = _Query_perf_frequency();
  perf_counter = _Query_perf_counter();
  if ( perf_frequency == 10000000 )
  {
    *this = 1000000000;
    this[1] = 100 * HIDWORD(perf_counter);
    return this;
  }
  else
  {
    v6 = perf_counter % perf_frequency;
    v5 = perf_counter / perf_frequency;
    v8 = v5;
    result = this;
    *(_QWORD *)this = 1000000000 * __PAIR64__(HIDWORD(v5), v8) + 1000000000 * v6 / perf_frequency;
  }
  return result;
}

//----- (1000A110) --------------------------------------------------------
int __stdcall sub_1000A110(int a1)
{
  int *v1; // eax
  int v2; // ecx
  int v4; // [esp+0h] [ebp-8h] BYREF

  v1 = sub_1000A060(&v4);
  v2 = *v1;
  dword_10053134 = v1[1];
  dword_10053130 = v2;
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 12) + 164))(*(_DWORD *)(a1 + 12));
}
// 10053130: using guessed type int dword_10053130;
// 10053134: using guessed type int dword_10053134;

//----- (1000A150) --------------------------------------------------------
int __stdcall sub_1000A150(int a1)
{
  __int64 v1; // kr10_8
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // kr18_8
  int v5[6]; // [esp+18h] [ebp-18h] BYREF

  v1 = *(_QWORD *)sub_1000A060(v5) - qword_10053130;
  v5[3] = v1;
  v5[0] = 103079215 * HIDWORD(v1);
  v2 = ((446676599 * (unsigned __int64)(unsigned int)v1) >> 32) + 446676599i64 * HIDWORD(v1);
  v3 = ((103079215i64 * (unsigned int)v1 + (unsigned __int64)(unsigned int)v2) >> 32) + HIDWORD(v2);
  sub_100010C0(
    (int)"Frame: %llu us\n",
    (v3 + 103079215i64 * HIDWORD(v1) + ((v1 - (v3 + 103079215i64 * HIDWORD(v1))) >> 1)) >> 9);
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 12) + 168))(*(_DWORD *)(a1 + 12));
}
// 10053130: using guessed type __int64 qword_10053130;

//----- (1000A220) --------------------------------------------------------
int __stdcall sub_1000A220(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return (*(int (__stdcall **)(_DWORD, int, int, int, int, int, int))(**(_DWORD **)(a1 + 12) + 172))(
           *(_DWORD *)(a1 + 12),
           a2,
           a3,
           a4,
           a5,
           a6,
           a7);
}

//----- (1000A250) --------------------------------------------------------
int __cdecl sub_1000A250(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 176))(*(_DWORD *)(a1 + 12));
}

//----- (1000A270) --------------------------------------------------------
int __cdecl sub_1000A270(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 180))(*(_DWORD *)(a1 + 12));
}

//----- (1000A290) --------------------------------------------------------
int __cdecl sub_1000A290(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 184))(*(_DWORD *)(a1 + 12));
}

//----- (1000A2B0) --------------------------------------------------------
int __stdcall sub_1000A2B0(int a1, int a2)
{
  int v2; // ecx
  char v4[24]; // [esp+8h] [ebp-20h] BYREF
  unsigned int v5; // [esp+20h] [ebp-8h]
  unsigned int v6; // [esp+24h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 32);
  if ( v2
    && (*(int (__stdcall **)(int, char *))(*(_DWORD *)v2 + 48))(v2, v4) >= 0
    && (*(_DWORD *)(a2 + 12) > v6 || *(_DWORD *)(a2 + 8) > v5) )
  {
    return -2005530516;
  }
  else
  {
    return (*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(a1 + 12) + 188))(*(_DWORD *)(a1 + 12), a2);
  }
}
// 1000A2B0: using guessed type char var_20[24];

//----- (1000A310) --------------------------------------------------------
int __cdecl sub_1000A310(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 192))(*(_DWORD *)(a1 + 12));
}

//----- (1000A330) --------------------------------------------------------
int __cdecl sub_1000A330(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 196))(*(_DWORD *)(a1 + 12));
}

//----- (1000A350) --------------------------------------------------------
int __cdecl sub_1000A350(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 200))(*(_DWORD *)(a1 + 12));
}

//----- (1000A370) --------------------------------------------------------
int __cdecl sub_1000A370(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 204))(*(_DWORD *)(a1 + 12));
}

//----- (1000A390) --------------------------------------------------------
int __cdecl sub_1000A390(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 208))(*(_DWORD *)(a1 + 12));
}

//----- (1000A3B0) --------------------------------------------------------
int __cdecl sub_1000A3B0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 212))(*(_DWORD *)(a1 + 12));
}

//----- (1000A3D0) --------------------------------------------------------
int __cdecl sub_1000A3D0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 216))(*(_DWORD *)(a1 + 12));
}

//----- (1000A3F0) --------------------------------------------------------
int __stdcall sub_1000A3F0(int a1, unsigned int a2, _DWORD *a3)
{
  _DWORD *v3; // ecx

  if ( !a3 || a2 >= 6 )
    return -2005530516;
  v3 = (_DWORD *)(a1 + 16 * a2);
  v3[10] = *a3;
  v3[11] = a3[1];
  v3[12] = a3[2];
  v3[13] = a3[3];
  return 0;
}

//----- (1000A430) --------------------------------------------------------
int __stdcall sub_1000A430(int a1, unsigned int a2, _DWORD *a3)
{
  _DWORD *v3; // ecx

  if ( !a3 || a2 >= 6 )
    return -2005530516;
  v3 = (_DWORD *)(a1 + 16 * a2);
  *a3 = v3[10];
  a3[1] = v3[11];
  a3[2] = v3[12];
  a3[3] = v3[13];
  return 0;
}

//----- (1000A470) --------------------------------------------------------
int __stdcall sub_1000A470(int a1, int a2, float a3)
{
  int v3; // edx
  int result; // eax
  float v5; // [esp+14h] [ebp+10h]

  (*(void (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 228))(*(_DWORD *)(a1 + 12), 38, 0xFFFFFF);
  (*(void (__stdcall **)(_DWORD, int, _DWORD))(**(_DWORD **)(a1 + 12) + 228))(*(_DWORD *)(a1 + 12), 28, 0);
  v3 = a2;
  switch ( a2 )
  {
    case 10:
    case 153:
    case 164:
      result = 0;
      break;
    case 30:
      result = -2005530516;
      break;
    case 40:
      result = (*(int (__stdcall **)(_DWORD, int, float))(**(_DWORD **)(a1 + 12) + 228))(
                 *(_DWORD *)(a1 + 12),
                 176,
                 COERCE_FLOAT(LODWORD(a3)));
      break;
    case 47:
      v5 = (float)LODWORD(a3);
      v3 = 195;
      a3 = v5 * -0.0000049999999;
      goto LABEL_9;
    case 152:
      result = (*(int (__stdcall **)(_DWORD, int, float))(**(_DWORD **)(a1 + 12) + 228))(
                 *(_DWORD *)(a1 + 12),
                 a2,
                 COERCE_FLOAT(LODWORD(a3)));
      if ( result >= 0 )
        *(float *)(a1 + 136) = a3;
      break;
    default:
LABEL_9:
      result = (*(int (__stdcall **)(_DWORD, int, float))(**(_DWORD **)(a1 + 12) + 228))(
                 *(_DWORD *)(a1 + 12),
                 v3,
                 COERCE_FLOAT(LODWORD(a3)));
      break;
  }
  return result;
}

//----- (1000A5F0) --------------------------------------------------------
int __stdcall sub_1000A5F0(int a1, int a2, float *a3)
{
  int result; // eax

  if ( !a3 )
    return -2005530516;
  *a3 = 0.0;
  switch ( a2 )
  {
    case 10:
      result = 0;
      break;
    case 30:
      return -2005530516;
    case 40:
      result = (*(int (__stdcall **)(_DWORD, int, float *))(**(_DWORD **)(a1 + 12) + 232))(
                 *(_DWORD *)(a1 + 12),
                 176,
                 a3);
      break;
    case 47:
      result = (*(int (__stdcall **)(_DWORD, int, float *))(**(_DWORD **)(a1 + 12) + 232))(
                 *(_DWORD *)(a1 + 12),
                 195,
                 a3);
      *(_DWORD *)a3 = (__int64)(*a3 * -500000.0);
      break;
    case 153:
      *(_DWORD *)a3 = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 12) + 312))(*(_DWORD *)(a1 + 12));
      result = 0;
      break;
    case 164:
      *(_DWORD *)a3 = 1;
      result = 0;
      break;
    default:
      result = (*(int (__stdcall **)(_DWORD, int, float *))(**(_DWORD **)(a1 + 12) + 232))(*(_DWORD *)(a1 + 12), a2, a3);
      break;
  }
  return result;
}

//----- (1000A7A0) --------------------------------------------------------
int __cdecl sub_1000A7A0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 240))(*(_DWORD *)(a1 + 12));
}

//----- (1000A7C0) --------------------------------------------------------
int __stdcall sub_1000A7C0(int a1, int a2)
{
  if ( a2 )
    return (*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(a1 + 12) + 244))(*(_DWORD *)(a1 + 12), a2);
  else
    return -2005530516;
}

//----- (1000A7F0) --------------------------------------------------------
int __stdcall sub_1000A7F0(int a1, int a2)
{
  if ( a2 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)a2 + 20))(a2);
  else
    return -2005530516;
}

//----- (1000A810) --------------------------------------------------------
int __stdcall sub_1000A810(int a1, int a2)
{
  if ( a2 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)a2 + 16))(a2);
  else
    return -2005530516;
}

//----- (1000A830) --------------------------------------------------------
int __stdcall sub_1000A830(int a1, int a2)
{
  if ( !a2 )
    return -2005530516;
  (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 8))(a2);
  return 0;
}

//----- (1000A850) --------------------------------------------------------
int __stdcall sub_1000A850(int a1, int a2, int a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v3 = sub_10006250(&dword_10053148, "Redirecting '");
  v4 = sub_10006250(v3, "IDirect3DDevice8::CreateStateBlock");
  v5 = sub_10006250(v4, "(");
  v6 = sub_10007E10(v5, (int)&savedregs, a2);
  v7 = sub_10006250(v6, ", ");
  v8 = sub_10007C40(v7, (int)&savedregs, a3);
  v9 = sub_10006250(v8, ")' ...");
  sub_100064E0(v9);
  if ( a3 )
    return (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 236))(*(_DWORD *)(a1 + 12), a2, a3);
  else
    return -2005530516;
}
// 10053148: using guessed type int dword_10053148;

//----- (1000A8E0) --------------------------------------------------------
int __cdecl sub_1000A8E0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 248))(*(_DWORD *)(a1 + 12));
}

//----- (1000A900) --------------------------------------------------------
int __cdecl sub_1000A900(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 252))(*(_DWORD *)(a1 + 12));
}

//----- (1000A920) --------------------------------------------------------
int __stdcall sub_1000A920(_DWORD *a1, void *a2, _DWORD *a3)
{
  _DWORD *v3; // ebx
  _DWORD *v4; // esi
  int v5; // ecx
  int result; // eax
  int v7; // eax
  int v8; // eax
  int *v9; // esi
  int *v10; // edi
  _DWORD *v11; // edi
  int v12; // ecx
  _DWORD *v13; // esi
  void *v14; // eax
  _DWORD *v15; // ecx
  int *v16; // esi
  int v17; // ecx
  int *v18; // esi
  int v19; // ecx
  int *v20[2]; // [esp+Ch] [ebp-28h] BYREF
  int *v21; // [esp+14h] [ebp-20h] BYREF
  void *v22; // [esp+18h] [ebp-1Ch]
  void *v23; // [esp+1Ch] [ebp-18h] BYREF
  void *Block; // [esp+20h] [ebp-14h] BYREF
  void *v25; // [esp+24h] [ebp-10h] BYREF
  int v26; // [esp+30h] [ebp-4h]

  v3 = a3;
  if ( a3 )
  {
    v4 = a1;
    *a3 = 0;
    v5 = v4[3];
    a3 = 0;
    result = (*(int (__stdcall **)(int, void *, _DWORD **))(*(_DWORD *)v5 + 256))(v5, a2, &a3);
    if ( result < 0 )
      return result;
    if ( !a3 )
      return 0;
    v25 = 0;
    a1 = 0;
    a2 = 0;
    v7 = (*(int (__stdcall **)(_DWORD *))(*a3 + 40))(a3) - 3;
    if ( !v7 )
    {
      (*(void (__stdcall **)(_DWORD *, void *, void **))*a3)(a3, &unk_1004C0E0, &v25);
      v18 = (int *)v4[1];
      Block = v25;
      v23 = v25;
      if ( v25 )
      {
        v10 = sub_10016580(
                v18 + 9,
                v20,
                &v23,
                16777619
              * (HIBYTE(v25) ^ (16777619
                              * (BYTE2(v25) ^ (16777619 * (BYTE1(v25) ^ (16777619 * ((unsigned __int8)v25 ^ 0x811C9DC5))))))))[1];
        if ( !v10 )
          v10 = (int *)v18[10];
        if ( v10 == (int *)v18[10] )
        {
          v11 = operator new(0x10u);
          v22 = v11;
          v26 = 0;
          v19 = *v18;
          v13 = v11 + 1;
          v11[1] = &AddressLookupTableObject::`vftable';
          LOBYTE(v26) = 1;
          v14 = Block;
          v11[2] = v19;
          *v11 = &Direct3DTexture8::`vftable';
          v11[1] = &Direct3DTexture8::`vftable';
          v11[3] = v14;
          v15 = (_DWORD *)(*(_DWORD *)(v19 + 4) + 36);
          goto LABEL_24;
        }
        goto LABEL_22;
      }
      goto LABEL_18;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      (*(void (__stdcall **)(_DWORD *, void *, void **))*a3)(a3, &unk_1004C0F0, &a2);
      v16 = (int *)v4[1];
      Block = a2;
      v23 = a2;
      if ( a2 )
      {
        v10 = sub_10016580(
                v16 + 17,
                v20,
                &v23,
                16777619
              * (HIBYTE(a2) ^ (16777619
                             * (BYTE2(a2) ^ (16777619 * (BYTE1(a2) ^ (16777619 * ((unsigned __int8)a2 ^ 0x811C9DC5))))))))[1];
        if ( !v10 )
          v10 = (int *)v16[18];
        if ( v10 == (int *)v16[18] )
        {
          v11 = operator new(0x10u);
          v22 = v11;
          v26 = 2;
          v17 = *v16;
          v13 = v11 + 1;
          v11[1] = &AddressLookupTableObject::`vftable';
          LOBYTE(v26) = 3;
          v14 = Block;
          v11[2] = v17;
          *v11 = &Direct3DVolumeTexture8::`vftable';
          v11[1] = &Direct3DVolumeTexture8::`vftable';
          v11[3] = v14;
          v15 = (_DWORD *)(*(_DWORD *)(v17 + 4) + 68);
          goto LABEL_24;
        }
LABEL_22:
        result = 0;
        *v3 = v10[3] != 0 ? v10[3] - 4 : 0;
        return result;
      }
LABEL_18:
      result = 0;
      *v3 = 0;
      return result;
    }
    if ( v8 == 1 )
    {
      (*(void (__stdcall **)(_DWORD *, void *, _DWORD **))*a3)(a3, &unk_1004AB74, &a1);
      v9 = (int *)v4[1];
      v23 = a1;
      Block = a1;
      if ( a1 )
      {
        v10 = sub_10016580(
                v9 + 25,
                &v21,
                &Block,
                16777619
              * (HIBYTE(a1) ^ (16777619
                             * (BYTE2(a1) ^ (16777619 * (BYTE1(a1) ^ (16777619 * ((unsigned __int8)a1 ^ 0x811C9DC5))))))))[1];
        if ( !v10 )
          v10 = (int *)v9[26];
        if ( v10 == (int *)v9[26] )
        {
          v11 = operator new(0x10u);
          Block = v11;
          v26 = 4;
          v12 = *v9;
          v13 = v11 + 1;
          v11[1] = &AddressLookupTableObject::`vftable';
          LOBYTE(v26) = 5;
          v14 = v23;
          v11[2] = v12;
          *v11 = &Direct3DCubeTexture8::`vftable';
          v11[1] = &Direct3DCubeTexture8::`vftable';
          v11[3] = v14;
          v15 = (_DWORD *)(*(_DWORD *)(v12 + 4) + 100);
LABEL_24:
          v23 = v14;
          *(_DWORD *)sub_1001A560(v15, (unsigned __int8 *)&v23) = v13;
          *v3 = v11;
          return 0;
        }
        goto LABEL_22;
      }
      goto LABEL_18;
    }
  }
  return -2005530516;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C308: using guessed type void *Direct3DVolumeTexture8::`vftable';
// 1004C310: using guessed type void *Direct3DCubeTexture8::`vftable';
// 1004C318: using guessed type void *Direct3DTexture8::`vftable';
// 1004C330: using guessed type void *Direct3DTexture8::`vftable';
// 1004C390: using guessed type void *Direct3DVolumeTexture8::`vftable';
// 1004C3F0: using guessed type void *Direct3DCubeTexture8::`vftable';

//----- (1000AC60) --------------------------------------------------------
int __stdcall sub_1000AC60(int a1, int a2, _DWORD *a3)
{
  int v4; // eax

  if ( !a3 )
    return (*(int (__stdcall **)(_DWORD, int, _DWORD))(**(_DWORD **)(a1 + 12) + 260))(*(_DWORD *)(a1 + 12), a2, 0);
  v4 = (*(int (__stdcall **)(_DWORD *))(*a3 + 40))(a3) - 3;
  if ( v4 && (unsigned int)(v4 - 1) >= 2 )
    return -2005530516;
  else
    return (*(int (__stdcall **)(_DWORD, int, _DWORD))(**(_DWORD **)(a1 + 12) + 260))(*(_DWORD *)(a1 + 12), a2, a3[3]);
}

//----- (1000ACC0) --------------------------------------------------------
int __cdecl sub_1000ACC0(int a1, int a2, int a3)
{
  int result; // eax

  switch ( a3 )
  {
    case 13:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 1);
      break;
    case 14:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 2);
      break;
    case 15:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 4);
      break;
    case 16:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 5);
      break;
    case 17:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 6);
      break;
    case 18:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 7);
      break;
    case 19:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 8);
      break;
    case 20:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 9);
      break;
    case 21:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 10);
      break;
    case 25:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 272))(*(_DWORD *)(a1 + 12), a2, 3);
      break;
    default:
      result = (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 264))(*(_DWORD *)(a1 + 12));
      break;
  }
  return result;
}

//----- (1000AE20) --------------------------------------------------------
int __cdecl sub_1000AE20(int a1, int a2, int a3)
{
  int result; // eax

  switch ( a3 )
  {
    case 13:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 1);
      break;
    case 14:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 2);
      break;
    case 15:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 4);
      break;
    case 16:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 5);
      break;
    case 17:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 6);
      break;
    case 18:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 7);
      break;
    case 19:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 8);
      break;
    case 20:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 9);
      break;
    case 21:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 10);
      break;
    case 25:
      result = (*(int (__cdecl **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 276))(*(_DWORD *)(a1 + 12), a2, 3);
      break;
    default:
      result = (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 268))(*(_DWORD *)(a1 + 12));
      break;
  }
  return result;
}

//----- (1000AF80) --------------------------------------------------------
int __cdecl sub_1000AF80(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 280))(*(_DWORD *)(a1 + 12));
}

//----- (1000AFA0) --------------------------------------------------------
int __stdcall sub_1000AFA0(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v4 = sub_10006250(&dword_10053148, "Redirecting '");
  v5 = sub_10006250(v4, "IDirect3DDevice8::GetInfo");
  v6 = sub_10006250(v5, "(");
  v7 = sub_10007C40(v6, (int)&savedregs, a1);
  v8 = sub_10006250(v7, ", ");
  v9 = sub_100042E0(v8, (int)&savedregs, a2);
  v10 = sub_10006250(v9, ", ");
  v11 = sub_10007C40(v10, (int)&savedregs, a3);
  v12 = sub_10006250(v11, ", ");
  v13 = sub_100042E0(v12, (int)&savedregs, a4);
  v14 = sub_10006250(v13, ")' ...");
  sub_100064E0(v14);
  return 1;
}
// 10053148: using guessed type int dword_10053148;

//----- (1000B040) --------------------------------------------------------
int __stdcall sub_1000B040(int a1, int a2, int a3)
{
  if ( a3 )
    return (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 284))(*(_DWORD *)(a1 + 12), a2, a3);
  else
    return -2005530516;
}

//----- (1000B070) --------------------------------------------------------
int __stdcall sub_1000B070(int a1, int a2, int a3)
{
  if ( a3 )
    return (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(a1 + 12) + 288))(*(_DWORD *)(a1 + 12), a2, a3);
  else
    return -2005530516;
}

//----- (1000B0A0) --------------------------------------------------------
int __stdcall sub_1000B0A0(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 36) )
    return (*(int (__thiscall **)(int, _DWORD, int))(**(_DWORD **)(a1 + 12) + 292))(a1, *(_DWORD *)(a1 + 12), a2);
  else
    return -2005530516;
}

//----- (1000B0D0) --------------------------------------------------------
int __stdcall sub_1000B0D0(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 36) )
    return (*(int (__thiscall **)(int, _DWORD, int))(**(_DWORD **)(a1 + 12) + 296))(a1, *(_DWORD *)(a1 + 12), a2);
  else
    return -2005530516;
}

//----- (1000B100) --------------------------------------------------------
int __cdecl sub_1000B100(int a1)
{
  sub_100119B0((char *)a1);
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 324))(*(_DWORD *)(a1 + 12));
}

//----- (1000B120) --------------------------------------------------------
int __stdcall sub_1000B120(int a1, int a2, int a3, int a4, int a5, int a6)
{
  sub_100119B0((char *)a1);
  return (*(int (__stdcall **)(_DWORD, int, _DWORD, int, int, int, int))(**(_DWORD **)(a1 + 12) + 328))(
           *(_DWORD *)(a1 + 12),
           a2,
           *(_DWORD *)(a1 + 16),
           a3,
           a4,
           a5,
           a6);
}

//----- (1000B160) --------------------------------------------------------
int __cdecl sub_1000B160(int a1)
{
  sub_100119B0((char *)a1);
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 332))(*(_DWORD *)(a1 + 12));
}

//----- (1000B180) --------------------------------------------------------
int __cdecl sub_1000B180(int a1)
{
  sub_100119B0((char *)a1);
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 336))(*(_DWORD *)(a1 + 12));
}

//----- (1000B1A0) --------------------------------------------------------
int __stdcall sub_1000B1A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a5 )
    return (*(int (__stdcall **)(_DWORD, int, int, int, _DWORD, _DWORD, int))(**(_DWORD **)(a1 + 12) + 340))(
             *(_DWORD *)(a1 + 12),
             a2,
             a3,
             a4,
             *(_DWORD *)(a5 + 12),
             0,
             a6);
  else
    return -2005530516;
}

//----- (1000B1E0) --------------------------------------------------------
int __userpurge sub_1000B1E0@<eax>(int a1@<esi>, int a2, int a3, unsigned int a4, unsigned int *a5, int a6)
{
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _DWORD *v11; // edi
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  unsigned int *v16; // ebx
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  _BYTE *v19; // eax
  _BYTE *v20; // eax
  unsigned int v21; // ebx
  _BYTE *v22; // eax
  unsigned int v23; // edx
  int v24; // esi
  __int16 v25; // si
  int v26; // edx
  int v27; // ecx
  __int16 v28; // si
  int v29; // ecx
  int v30; // esi
  int v31; // edx
  char v32; // cl
  unsigned int v33; // eax
  int v34; // eax
  float *v35; // esi
  char *v36; // ebx
  char *v37; // edi
  char *v38; // esi
  const void **v39; // eax
  void **v40; // eax
  void **v41; // eax
  void **v42; // eax
  void **v43; // eax
  void **v44; // eax
  void **v45; // eax
  void **v46; // eax
  void **v47; // eax
  void **v48; // eax
  void **v49; // eax
  bool v50; // zf
  int *v51; // esi
  _BYTE *v52; // eax
  int v53; // edi
  size_t v54; // esi
  void *v55; // eax
  _BYTE *v56; // eax
  _BYTE *v57; // eax
  _BYTE *v58; // eax
  _BYTE *v59; // eax
  int v60; // edi
  _BYTE *v61; // eax
  int v62; // ecx
  size_t v63; // edi
  unsigned int i; // esi
  _BYTE *v65; // eax
  _BYTE *v66; // eax
  const char *v67; // edx
  unsigned __int8 v68; // al
  void **v69; // eax
  const void **v70; // eax
  char *v71; // eax
  void **v72; // eax
  unsigned int v73; // eax
  _DWORD *v74; // eax
  int v75; // ebx
  _DWORD *v76; // eax
  unsigned int v77; // esi
  unsigned int j; // ebx
  const void **v79; // eax
  void **v80; // eax
  void **v81; // eax
  void **v82; // eax
  char *v83; // eax
  unsigned int v84; // eax
  const void **v85; // eax
  void **v86; // eax
  void **v87; // eax
  void **v88; // eax
  char *v89; // eax
  unsigned int k; // ebx
  const void **v91; // eax
  void **v92; // eax
  void **v93; // eax
  void **v94; // eax
  char *v95; // eax
  int v96; // ecx
  int *v97; // eax
  _DWORD *v98; // eax
  int v99; // ecx
  int *v100; // eax
  _DWORD *v101; // eax
  int v102; // ecx
  int *v103; // eax
  void **v104; // eax
  int v105; // ebx
  void **v106; // esi
  _BYTE *v107; // edx
  void *v108; // edx
  void (__thiscall ***v109)(_DWORD, int); // eax
  int v110; // ecx
  int v111; // ebx
  char *p_Block; // edx
  char *v113; // eax
  _BYTE *v114; // edx
  _BYTE *v115; // edx
  unsigned int v116; // ebx
  int v117; // esi
  void (__thiscall ***v118)(_DWORD, int); // ecx
  _DWORD *v119; // eax
  void (__thiscall ***v120)(_DWORD, int); // eax
  int v121; // ecx
  unsigned int v122; // ebx
  char *v123; // edx
  char *v124; // eax
  _BYTE *v125; // edx
  int v126; // ecx
  int *v127; // eax
  _DWORD *v128; // eax
  int v129; // ecx
  int *v130; // eax
  char v131; // al
  char v132; // bl
  int v133; // ecx
  unsigned int v134; // edi
  char *v135; // esi
  unsigned int v136; // ebx
  int v137; // ebx
  const void **v138; // eax
  void *v139; // esi
  unsigned int v140; // edx
  unsigned int v141; // ecx
  char *v142; // eax
  void *v143; // ecx
  _BYTE *v144; // eax
  void *v145; // edx
  unsigned int v146; // eax
  char *v147; // esi
  unsigned int v148; // ebx
  int v149; // ecx
  _BYTE *v150; // esi
  unsigned int v151; // ebx
  int v152; // ebx
  const void **v153; // eax
  int v154; // ebx
  int v155; // ecx
  char *p_Src; // eax
  char *v157; // esi
  void **v158; // edx
  int v159; // eax
  int v160; // ecx
  unsigned int v161; // eax
  int v162; // ebx
  int v163; // ecx
  void **v164; // eax
  char *v165; // esi
  void **v166; // ecx
  int v167; // ebx
  void *v168; // edx
  _BYTE *v169; // edx
  _BYTE *v170; // edx
  void *v171; // edx
  void *v172; // edx
  void *v173; // ecx
  char *v174; // eax
  char *v175; // ecx
  int v176; // ecx
  void (__thiscall ***v177)(_DWORD, int); // eax
  char *v178; // esi
  unsigned int v179; // ebx
  int v180; // ecx
  _BYTE *v181; // esi
  unsigned int v182; // ebx
  int v183; // ecx
  char *v184; // esi
  unsigned int v185; // ebx
  int v186; // ebx
  const void **v187; // eax
  int v188; // ebx
  int v189; // ecx
  char *v190; // eax
  char *v191; // esi
  void **v192; // edx
  int v193; // eax
  int v194; // ecx
  unsigned int v195; // eax
  int v196; // ebx
  int v197; // ecx
  char *v198; // eax
  char *v199; // esi
  void **v200; // edx
  void *v201; // eax
  void *v202; // ecx
  unsigned int v203; // eax
  int v204; // ebx
  int v205; // ecx
  void **v206; // eax
  char *v207; // esi
  void **v208; // edx
  int v209; // ebx
  void *v210; // eax
  void *v211; // ecx
  unsigned int v212; // eax
  void *v213; // ecx
  char *v214; // eax
  int v215; // ebx
  char *v216; // edx
  char *v217; // eax
  void *v218; // edx
  void (__thiscall ***v219)(_DWORD, int); // eax
  void *v220; // edx
  void *v221; // edx
  void *v222; // edx
  _BYTE *v223; // edx
  _BYTE *v224; // edx
  _BYTE *v225; // edx
  void *v226; // edx
  void *v227; // edx
  void *v228; // edx
  void *v229; // eax
  int v230; // ebx
  int v231; // ecx
  char *v232; // eax
  char *v233; // esi
  void **v234; // ecx
  void *v235; // ecx
  char *v236; // eax
  _DWORD *v237; // eax
  void *v238; // edx
  int v239; // esi
  void (__thiscall ***v240)(_DWORD, int); // ecx
  _DWORD *v241; // eax
  void (__thiscall ***v242)(_DWORD, int); // eax
  _BYTE *v243; // edx
  _BYTE *v244; // edx
  _BYTE *v245; // edx
  int v246; // ecx
  char *v247; // ecx
  int v248; // ebx
  int v249; // ecx
  char *v250; // ecx
  char v251; // al
  void (__thiscall ***v252)(_DWORD, int); // eax
  int v253; // esi
  void (__thiscall ***v254)(_DWORD, int); // ecx
  _DWORD *v255; // eax
  void (__thiscall ***v256)(_DWORD, int); // eax
  int v257; // ecx
  char *v258; // ecx
  void (__thiscall ***v259)(_DWORD, int); // eax
  int v260; // ecx
  char *v261; // ecx
  void (__thiscall ***v262)(_DWORD, int); // eax
  int v263; // ecx
  char *v264; // ecx
  char v265; // al
  int v266; // esi
  void (__thiscall ***v267)(_DWORD, int); // ecx
  _DWORD *v268; // eax
  void (__thiscall ***v269)(_DWORD, int); // eax
  int v270; // ecx
  char *v271; // ecx
  char v272; // al
  int v273; // esi
  void (__thiscall ***v274)(_DWORD, int); // ecx
  _DWORD *v275; // eax
  void (__thiscall ***v276)(_DWORD, int); // eax
  int v277; // ecx
  char *v278; // edx
  char *v279; // eax
  _BYTE *v280; // edx
  _BYTE *v281; // edx
  int v282; // esi
  void (__thiscall ***v283)(_DWORD, int); // ecx
  _DWORD *v284; // eax
  void (__thiscall ***v285)(_DWORD, int); // eax
  _BYTE *v286; // eax
  _BYTE *v287; // eax
  _BYTE *v288; // eax
  void *v289; // edx
  _BYTE *v290; // eax
  void *v291; // eax
  unsigned int v292; // ebx
  int v293; // edi
  int (__stdcall *v294)(int, int, unsigned int); // esi
  int v295; // eax
  void *v296; // edx
  _BYTE *v297; // eax
  _BYTE *v298; // eax
  _BYTE *v299; // eax
  _BYTE *v300; // eax
  _BYTE *v301; // eax
  _BYTE *v302; // esi
  const char *v303; // eax
  _BYTE *v304; // eax
  _BYTE *v305; // eax
  _BYTE *v306; // eax
  _BYTE *v307; // eax
  void *v308; // edx
  char *v309; // eax
  char *v310; // eax
  char *v311; // eax
  char *v312; // eax
  _BYTE *v313; // eax
  char *v314; // eax
  char *v315; // eax
  char *v316; // eax
  char *v317; // eax
  char *v318; // eax
  _BYTE *v319; // eax
  _BYTE *v320; // eax
  _BYTE *v321; // eax
  _BYTE *v322; // eax
  void *v323; // edx
  int v326[32]; // [esp+10h] [ebp-3A0h]
  int v327[64]; // [esp+90h] [ebp-320h] BYREF
  void *v328[4]; // [esp+190h] [ebp-220h] BYREF
  int v329; // [esp+1A0h] [ebp-210h]
  unsigned int v330; // [esp+1A4h] [ebp-20Ch]
  void *v331[5]; // [esp+1A8h] [ebp-208h] BYREF
  unsigned int v332; // [esp+1BCh] [ebp-1F4h]
  void *v333[5]; // [esp+1C0h] [ebp-1F0h] BYREF
  unsigned int v334; // [esp+1D4h] [ebp-1DCh]
  int v335[5]; // [esp+1D8h] [ebp-1D8h] BYREF
  char v336[7]; // [esp+1EDh] [ebp-1C3h] BYREF
  int v337; // [esp+1F4h] [ebp-1BCh]
  int v338; // [esp+1F8h] [ebp-1B8h]
  void *v339[5]; // [esp+1FCh] [ebp-1B4h] BYREF
  unsigned int v340; // [esp+210h] [ebp-1A0h]
  void *v341[5]; // [esp+214h] [ebp-19Ch] BYREF
  unsigned int v342; // [esp+228h] [ebp-188h]
  void *v343[4]; // [esp+22Ch] [ebp-184h] BYREF
  int v344; // [esp+23Ch] [ebp-174h]
  unsigned int v345; // [esp+240h] [ebp-170h]
  void *v346[5]; // [esp+244h] [ebp-16Ch] BYREF
  unsigned int v347; // [esp+258h] [ebp-158h]
  void *v348[5]; // [esp+25Ch] [ebp-154h] BYREF
  unsigned int v349; // [esp+270h] [ebp-140h]
  void *v350; // [esp+274h] [ebp-13Ch] BYREF
  void *v351; // [esp+278h] [ebp-138h]
  void *v352; // [esp+27Ch] [ebp-134h]
  const void *v353; // [esp+280h] [ebp-130h]
  unsigned int v354; // [esp+284h] [ebp-12Ch]
  unsigned int v355; // [esp+288h] [ebp-128h]
  int v356; // [esp+28Ch] [ebp-124h]
  void *v357[4]; // [esp+290h] [ebp-120h] BYREF
  int v358; // [esp+2A0h] [ebp-110h]
  unsigned int v359; // [esp+2A4h] [ebp-10Ch]
  void *Src; // [esp+2A8h] [ebp-108h] BYREF
  const void *v361; // [esp+2ACh] [ebp-104h]
  const void *v362; // [esp+2B0h] [ebp-100h]
  const void *v363; // [esp+2B4h] [ebp-FCh]
  char *v364; // [esp+2B8h] [ebp-F8h]
  unsigned int v365; // [esp+2BCh] [ebp-F4h]
  int v366; // [esp+2C0h] [ebp-F0h]
  int v367; // [esp+2C4h] [ebp-ECh] BYREF
  void *v368[4]; // [esp+2C8h] [ebp-E8h] BYREF
  int v369; // [esp+2D8h] [ebp-D8h]
  unsigned int v370; // [esp+2DCh] [ebp-D4h]
  int v371; // [esp+2E0h] [ebp-D0h]
  void *v372; // [esp+2E4h] [ebp-CCh] BYREF
  void *v373; // [esp+2E8h] [ebp-C8h]
  void *v374; // [esp+2ECh] [ebp-C4h]
  void *v375; // [esp+2F0h] [ebp-C0h]
  size_t v376; // [esp+2F4h] [ebp-BCh]
  unsigned int v377; // [esp+2F8h] [ebp-B8h]
  int v378; // [esp+2FCh] [ebp-B4h]
  int v379; // [esp+300h] [ebp-B0h] BYREF
  struct std::_Facet_base *v380[3]; // [esp+304h] [ebp-ACh] BYREF
  int v381; // [esp+310h] [ebp-A0h]
  _BYTE v382[3]; // [esp+315h] [ebp-9Bh] BYREF
  void *v383[4]; // [esp+318h] [ebp-98h] BYREF
  int v384; // [esp+328h] [ebp-88h]
  unsigned int v385; // [esp+32Ch] [ebp-84h]
  float *v386; // [esp+330h] [ebp-80h] BYREF
  char v387; // [esp+337h] [ebp-79h]
  int v388; // [esp+338h] [ebp-78h]
  int v389; // [esp+33Ch] [ebp-74h] BYREF
  int v390; // [esp+340h] [ebp-70h]
  void *v391; // [esp+344h] [ebp-6Ch] BYREF
  void *v392; // [esp+348h] [ebp-68h]
  void *v393; // [esp+34Ch] [ebp-64h]
  int v394; // [esp+350h] [ebp-60h]
  int v395; // [esp+354h] [ebp-5Ch]
  unsigned int v396; // [esp+358h] [ebp-58h]
  int v397; // [esp+35Ch] [ebp-54h] BYREF
  struct std::_Facet_base *v398[3]; // [esp+360h] [ebp-50h] BYREF
  int v399; // [esp+36Ch] [ebp-44h]
  void *v400; // [esp+370h] [ebp-40h] BYREF
  void *v401; // [esp+374h] [ebp-3Ch]
  void *v402; // [esp+378h] [ebp-38h]
  void *v403; // [esp+37Ch] [ebp-34h]
  unsigned int v404; // [esp+380h] [ebp-30h]
  unsigned int v405; // [esp+384h] [ebp-2Ch]
  int v406; // [esp+388h] [ebp-28h]
  void *Block; // [esp+38Ch] [ebp-24h] BYREF
  void *v408; // [esp+390h] [ebp-20h]
  void *v409; // [esp+394h] [ebp-1Ch]
  void *v410; // [esp+398h] [ebp-18h]
  unsigned int v411; // [esp+39Ch] [ebp-14h]
  unsigned int v412; // [esp+3A0h] [ebp-10h]
  int v413; // [esp+3ACh] [ebp-4h]
  int savedregs; // [esp+3B0h] [ebp+0h] BYREF

  v406 = 0;
  v390 = 0;
  v6 = sub_10006250(&dword_10053148, "Redirecting '");
  v7 = sub_10006250(v6, "IDirect3DDevice8::CreateVertexShader");
  v8 = sub_10006250(v7, "(");
  v9 = sub_10007C40(v8, (int)&savedregs, a2);
  v10 = sub_10006250(v9, ", ");
  v11 = (_DWORD *)a3;
  v12 = sub_10007C40(v10, (int)&savedregs, a3);
  v13 = sub_10006250(v12, ", ");
  v14 = sub_10007C40(v13, (int)&savedregs, a4);
  v15 = sub_10006250(v14, ", ");
  v16 = a5;
  v17 = sub_10007C40(v15, (int)&savedregs, (int)a5);
  v18 = sub_10006250(v17, ", ");
  v19 = sub_100042E0(v18, (int)&savedregs, a6);
  v20 = sub_10006250(v19, ")' ...");
  sub_100064E0(v20);
  if ( !v11 || !v16 )
    return -2005530516;
  *v16 = 0;
  v21 = 0;
  v389 = 0;
  sub_10004570(v328);
  v413 = 0;
  v388 = 0;
  a6 = 0;
  v22 = sub_10006250(&dword_10053148, "> Translating vertex declaration ...");
  sub_100064E0(v22);
  do
  {
    v23 = *v11;
    v24 = *v11 >> 29;
    if ( *v11 == -1 )
      break;
    switch ( v24 )
    {
      case 1:
        v388 = *v11 & 0xF;
        a6 = 0;
        break;
      case 2:
        if ( (v23 & 0x10000000) != 0 )
        {
          a6 += 4 * (HIWORD(v23) & 0xF);
        }
        else
        {
          v25 = a6;
          v26 = *v11 & 0x1F;
          v27 = HIWORD(*v11) & 0xF;
          LOWORD(v327[2 * v21]) = v388;
          HIWORD(v327[2 * v21]) = v25;
          BYTE1(v327[2 * v21 + 1]) = 0;
          v326[v21] = v26;
          LOBYTE(v327[2 * v21 + 1]) = byte_1004C0AC[2 * v27];
          v28 = (unsigned __int8)byte_1004C0AD[2 * v27] + v25;
          BYTE2(v327[2 * v21 + 1]) = byte_1004AC98[2 * v26];
          HIBYTE(v327[2 * v21++ + 1]) = byte_1004AC99[2 * v26];
          LOWORD(a6) = v28;
          v389 = v21;
        }
        break;
      case 3:
        if ( (v23 & 0x10000000) != 0 )
        {
          LOWORD(v327[2 * v21 + 1]) = 1041;
          v327[2 * v21] = 0;
        }
        else
        {
          v29 = 0;
          LOWORD(v327[2 * v21]) = v388;
          v30 = (v23 >> 20) & 0xF;
          HIWORD(v327[2 * v21]) = a6;
          if ( v21 )
          {
            while ( BYTE2(v327[2 * v29 + 1]) != byte_1004AC98[2 * v30]
                 || HIBYTE(v327[2 * v29 + 1]) != byte_1004AC99[2 * v30] )
            {
              if ( ++v29 >= v21 )
              {
                LOWORD(v327[2 * v21 + 1]) = 770;
                goto LABEL_21;
              }
            }
            LOWORD(v327[2 * v21]) = v327[2 * v29];
            HIWORD(v327[2 * v21]) = HIWORD(v327[2 * v29]);
          }
          LOWORD(v327[2 * v21 + 1]) = 770;
        }
LABEL_21:
        v31 = v23 & 0xF;
        v326[v21] = v31;
        v32 = byte_1004AC98[2 * v31];
        HIBYTE(v327[2 * v21 + 1]) = byte_1004AC99[2 * v31];
        BYTE2(v327[2 * v21 + 1]) = v32;
        BYTE1(v327[2 * v21++ + 1]) &= (v32 == 2) - 1;
        v389 = v21;
        break;
      case 4:
        v33 = *v11;
        v390 = *v11 & 0x7F;
        v34 = 4 * ((v33 >> 25) & 0xF);
        v378 = v34;
        if ( v34 )
        {
          v35 = (float *)(v11 + 3);
          v386 = (float *)(v11 + 3);
          v371 = ((unsigned int)(v34 - 1) >> 2) + 1;
          do
          {
            v356 = (int)sub_10008530(v35[1]);
            LOBYTE(v413) = 1;
            v36 = sub_10008530(*v35);
            LOBYTE(v413) = 2;
            v37 = sub_10008530(*(v35 - 1));
            LOBYTE(v413) = 3;
            v38 = sub_10008530(*(v35 - 2));
            LOBYTE(v413) = 4;
            v39 = (const void **)sub_100084E0(v343, v390);
            LOBYTE(v413) = 5;
            v40 = (void **)sub_10012620((const void **)v357, "    def c", v39);
            LOBYTE(v413) = 6;
            v41 = sub_100126F0(&v391, v40, ", ");
            LOBYTE(v413) = 7;
            v42 = sub_10012870(v333, v41, v38);
            LOBYTE(v413) = 8;
            v43 = sub_100126F0(v331, v42, ", ");
            LOBYTE(v413) = 9;
            v44 = sub_10012870(&v350, v43, v37);
            LOBYTE(v413) = 10;
            v45 = sub_100126F0(v341, v44, ", ");
            LOBYTE(v413) = 11;
            v46 = sub_10012870(v339, v45, v36);
            LOBYTE(v413) = 12;
            v47 = sub_100126F0(v346, v46, ", ");
            LOBYTE(v413) = 13;
            v48 = sub_10012870(v383, v47, (_DWORD *)v356);
            LOBYTE(v413) = 14;
            v49 = sub_100126F0(v348, v48, " /* vertex declaration constant */\n");
            LOBYTE(v413) = 15;
            sub_10001950(v328, v49);
            sub_100019D0(v348);
            sub_100019D0(v383);
            sub_100019D0(v346);
            sub_100019D0(v339);
            sub_100019D0(v341);
            sub_100019D0(&v350);
            sub_100019D0(v331);
            sub_100019D0(v333);
            sub_100019D0(&v391);
            sub_100019D0(v357);
            sub_100019D0(v343);
            sub_100019D0(v368);
            sub_100019D0(&v400);
            sub_100019D0(&Src);
            LOBYTE(v413) = 0;
            sub_100019D0(&v372);
            ++v390;
            v35 = v386 + 4;
            v50 = v371-- == 1;
            v386 += 4;
          }
          while ( !v50 );
          v21 = v389;
          v34 = v378;
          v11 = (_DWORD *)a3;
        }
        v11 += v34;
        break;
      default:
        v65 = sub_10006250(&dword_10053148, "> Failed because token type '");
        v66 = sub_100042E0(v65, (int)&savedregs, v24);
        v67 = "' is not supported!";
        goto LABEL_373;
    }
    a3 = (int)++v11;
  }
  while ( v21 < 0x20 );
  v51 = (int *)a4;
  v366 = 255;
  v367 = 17;
  v327[2 * v21] = 255;
  v327[2 * v21 + 1] = 17;
  if ( v51 )
  {
    v52 = sub_10006250(
            &dword_10053148,
            "> Disassembling shader and translating assembly to Direct3D 9 compatible code ...");
    sub_100064E0(v52);
    if ( (unsigned int)*v51 < 0xFFFE0100 || (unsigned int)*v51 > 0xFFFE0101 )
    {
      v314 = sub_10006250(&dword_10053148, "> Failed because of version mismatch ('");
      v315 = sub_10011E50(v314, (void (__cdecl *)(char *))sub_10008450);
      v316 = sub_10011E50(v315, (void (__cdecl *)(char *))sub_10008420);
      v317 = sub_100042E0(v316, (int)&savedregs, *v51);
      v318 = sub_10011E50(v317, (void (__cdecl *)(char *))sub_10008400);
      v66 = sub_10011E50(v318, (void (__cdecl *)(char *))sub_10008440);
      v67 = "')! Only 'vs_1_x' shaders are supported.";
LABEL_373:
      v319 = sub_10006250(v66, v67);
      sub_100064E0(v319);
      v53 = -2005530516;
      goto LABEL_380;
    }
    v389 = 0;
    v386 = 0;
    v388 = 0;
    if ( dword_10053120 )
    {
      v53 = dword_10053120(v51, 0, 0, &v389);
      if ( v53 >= 0 )
      {
        v54 = (*(int (__stdcall **)(int, int))(*(_DWORD *)v389 + 16))(v389, a1) - 1;
        v55 = (void *)(*(int (__stdcall **)(int))(*(_DWORD *)v389 + 12))(v389);
        sub_10001A90(&Block, v55, v54);
        LOBYTE(v413) = 16;
        v56 = sub_10006250(&dword_10053148, "> Dumping original shader assembly:");
        v57 = sub_100064E0(v56);
        v58 = sub_100064E0(v57);
        v59 = sub_10001C30(v58, &Block);
        sub_100064E0(v59);
        v60 = sub_10011EF0(&Block, "vs_1_", 0);
        if ( *sub_10011F60(&Block, v60 + 5) == 48 )
        {
          v61 = sub_10006250(&dword_10053148, "> Replacing version 'vs_1_0' with 'vs_1_1' ...");
          sub_100064E0(v61);
          sub_10011F80((const void **)&Block, v60, v62, "vs_1_1");
        }
        v63 = v60 + 7;
        for ( i = 0; i < v21; ++i )
        {
          sub_10001A20(v368, "    ");
          LOBYTE(v413) = 17;
          switch ( BYTE2(v327[2 * i + 1]) )
          {
            case 0:
              sub_10011FD0(v368, "dcl_position");
              break;
            case 1:
              sub_10011FD0(v368, "dcl_blendweight");
              break;
            case 2:
              sub_10011FD0(v368, "dcl_blendindices");
              break;
            case 3:
              sub_10011FD0(v368, "dcl_normal");
              break;
            case 4:
              sub_10011FD0(v368, "dcl_psize");
              break;
            case 5:
              sub_10011FD0(v368, "dcl_texcoord");
              break;
            case 0xA:
              sub_10011FD0(v368, "dcl_color");
              break;
            default:
              break;
          }
          v68 = HIBYTE(v327[2 * i + 1]);
          if ( v68 )
          {
            v69 = (void **)sub_10008460(v348, v68);
            LOBYTE(v413) = 18;
            sub_10001950(v368, v69);
            LOBYTE(v413) = 17;
            sub_100019D0(v348);
          }
          v70 = (const void **)sub_100084E0(v346, v326[i]);
          LOBYTE(v413) = 19;
          v71 = (char *)sub_10012620((const void **)v383, " v", v70);
          LOBYTE(v413) = 20;
          v72 = (void **)sub_10012890(v348, v71);
          LOBYTE(v413) = 21;
          sub_10001950(v368, v72);
          sub_100019D0(v348);
          sub_100019D0(v383);
          LOBYTE(v413) = 17;
          sub_100019D0(v346);
          sub_10011FB0((const void **)&Block, v63, (char *)v368);
          v63 += v369;
          LOBYTE(v413) = 16;
          sub_100019D0(v368);
        }
        sub_10011FB0((const void **)&Block, v63, (char *)v328);
        v73 = sub_10011EF0(&Block, "instruction", 0);
        if ( v73 <= 2 || v73 >= v411 )
        {
          v75 = v406;
          v77 = 0;
        }
        else
        {
          v74 = sub_10011E70(&Block, v348, v73 - 4, 4u);
          v75 = 1;
          v406 = 1;
          v76 = sub_10001940(v74);
          v77 = sub_10027E6A((int)v76, 0, 10);
        }
        if ( (v75 & 1) != 0 )
        {
          v406 = v75 & 0xFFFFFFFE;
          sub_100019D0(v348);
        }
        for ( j = 0; j < 8; ++j )
        {
          v79 = (const void **)sub_100084E0(v348, j);
          LOBYTE(v413) = 22;
          sub_10012620((const void **)v383, "oT", v79);
          LOBYTE(v413) = 24;
          sub_100019D0(v348);
          if ( sub_10011F30(&Block, (int)v383, 0) != -1 && v77 < 0x80 )
          {
            ++v77;
            v80 = (void **)sub_100125C0(&v350, "    mov ", v383);
            LOBYTE(v413) = 25;
            v81 = sub_100126F0(v341, v80, ", c0 /* initialize output register ");
            LOBYTE(v413) = 26;
            v82 = sub_100127B0(v339, (int)v81, v383);
            LOBYTE(v413) = 27;
            v83 = (char *)sub_100126F0(v346, v82, " */\n");
            LOBYTE(v413) = 28;
            sub_10011FB0((const void **)&Block, v63 + v329, v83);
            sub_100019D0(v346);
            sub_100019D0(v339);
            sub_100019D0(v341);
            sub_100019D0(&v350);
          }
          LOBYTE(v413) = 16;
          sub_100019D0(v383);
        }
        v84 = 0;
        a3 = 0;
        do
        {
          v85 = (const void **)sub_100084E0(v348, v84);
          LOBYTE(v413) = 29;
          sub_10012620((const void **)v383, "oD", v85);
          LOBYTE(v413) = 31;
          sub_100019D0(v348);
          if ( sub_10011F30(&Block, (int)v383, 0) != -1 && v77 < 0x80 )
          {
            ++v77;
            v86 = (void **)sub_100125C0(&v350, "    mov ", v383);
            LOBYTE(v413) = 32;
            v87 = sub_100126F0(v341, v86, ", c0 /* initialize output register ");
            LOBYTE(v413) = 33;
            v88 = sub_100127B0(v339, (int)v87, v383);
            LOBYTE(v413) = 34;
            v89 = (char *)sub_100126F0(v346, v88, " */\n");
            LOBYTE(v413) = 35;
            sub_10011FB0((const void **)&Block, v63 + v329, v89);
            sub_100019D0(v346);
            sub_100019D0(v339);
            sub_100019D0(v341);
            sub_100019D0(&v350);
          }
          LOBYTE(v413) = 16;
          sub_100019D0(v383);
          v84 = a3 + 1;
          a3 = v84;
        }
        while ( v84 < 2 );
        for ( k = 0; k < 0xC; ++k )
        {
          v91 = (const void **)sub_100084E0(v348, k);
          LOBYTE(v413) = 36;
          sub_10012620((const void **)v383, "r", v91);
          LOBYTE(v413) = 38;
          sub_100019D0(v348);
          if ( sub_10011F30(&Block, (int)v383, 0) != -1 && v77 < 0x80 )
          {
            ++v77;
            v92 = (void **)sub_100125C0(&v350, "    mov ", v383);
            LOBYTE(v413) = 39;
            v93 = sub_100126F0(v341, v92, ", c0 /* initialize register ");
            LOBYTE(v413) = 40;
            v94 = sub_100127B0(v339, (int)v93, v383);
            LOBYTE(v413) = 41;
            v95 = (char *)sub_100126F0(v346, v94, " */\n");
            LOBYTE(v413) = 42;
            sub_10011FB0((const void **)&Block, v63 + v329, v95);
            sub_100019D0(v346);
            sub_100019D0(v339);
            sub_100019D0(v341);
            sub_100019D0(&v350);
          }
          LOBYTE(v413) = 16;
          sub_100019D0(v383);
        }
        a4 = v77;
        v97 = (int *)sub_10011C30((int)&v379, "    \\/\\/ vs\\.1\\.1\\n((?! ).+\\n)+", v96);
        LOBYTE(v413) = 43;
        v98 = (_DWORD *)sub_10012920((int)v348, (char *)&Block, v97, &unk_1004A353, 0);
        sub_10005F60(&Block, v98);
        sub_100019D0(v348);
        LOBYTE(v413) = 16;
        sub_10011BD0(&v379);
        v100 = (int *)sub_10011C30((int)&v379, "([^\\n]\\n)[\\s]*#line [0123456789]+.*\\n", v99);
        LOBYTE(v413) = 44;
        v101 = (_DWORD *)sub_10012920((int)v348, (char *)&Block, v100, "$1", 0);
        sub_10005F60(&Block, v101);
        sub_100019D0(v348);
        LOBYTE(v413) = 16;
        sub_10011BD0(&v379);
        v103 = (int *)sub_10011C30((int)&v379, "(oFog|oPts)\\.x", v102);
        LOBYTE(v413) = 45;
        v104 = (void **)sub_10012920((int)v383, (char *)&Block, v103, "$1 /* removed swizzle */", 0);
        v105 = v406;
        v106 = v104;
        if ( &Block != v104 )
        {
          if ( v412 >= 0x10 )
          {
            v107 = Block;
            if ( v412 + 1 >= 0x1000 )
            {
              v107 = (_BYTE *)*((_DWORD *)Block - 1);
              if ( (unsigned int)((_BYTE *)Block - v107 - 4) > 0x1F )
LABEL_386:
                _invalid_parameter_noinfo_noreturn();
            }
            sub_1001D481(v107);
          }
          v411 = 0;
          v412 = 15;
          LOBYTE(Block) = 0;
          Block = *v106;
          v408 = v106[1];
          v409 = v106[2];
          v410 = v106[3];
          v411 = (unsigned int)v106[4];
          v412 = (unsigned int)v106[5];
          v106[4] = 0;
          v106[5] = (void *)15;
          *(_BYTE *)v106 = 0;
        }
        if ( v385 >= 0x10 )
        {
          v108 = v383[0];
          if ( v385 + 1 >= 0x1000 )
          {
            v108 = (void *)*((_DWORD *)v383[0] - 1);
            if ( (unsigned int)(v383[0] - v108 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_1001D481(v108);
        }
        v384 = 0;
        v385 = 15;
        LOBYTE(v383[0]) = 0;
        LOBYTE(v413) = 16;
        sub_100121B0(&v379);
        if ( v381 )
        {
          v109 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v381 + 8))(v381);
          if ( v109 )
            (**v109)(v109, 1);
        }
        v397 = 0;
        sub_10012060(v398);
        LOBYTE(v413) = 46;
        sub_10012B50(&v397, (int)"(add|sub|mul|min|max) (oFog|oPts), ([cr][0-9]+), (.+)\\n", (int)"", v110);
        v405 = 15;
        v111 = v105 | 0x40000000;
        v400 = 0;
        v401 = 0;
        v402 = 0;
        v403 = 0;
        v404 = 0;
        v390 = v111;
        v391 = 0;
        v392 = 0;
        v393 = 0;
        v394 = 0;
        v395 = 0;
        LOBYTE(v413) = 49;
        v396 = 15;
        v391 = operator new(0x30u);
        v395 = 36;
        v396 = 47;
        strcpy((char *)v391, "$1 $2, $3.x /* added swizzle */, $4\n");
        LOBYTE(v413) = 50;
        if ( v412 < 0x10 )
        {
          v113 = (char *)&Block + v411;
          p_Block = (char *)&Block;
        }
        else
        {
          p_Block = (char *)Block;
          v113 = (char *)Block + v411;
        }
        sub_10014950((void ***)&a3, p_Block, &v400, v113, &v397, (char *)&v391, 0);
        LOBYTE(v413) = 48;
        if ( v396 >= 0x10 )
        {
          v114 = v391;
          if ( v396 + 1 >= 0x1000 )
          {
            v114 = (_BYTE *)*((_DWORD *)v391 - 1);
            if ( (unsigned int)((_BYTE *)v391 - v114 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_1001D481(v114);
        }
        if ( v412 >= 0x10 )
        {
          v115 = Block;
          if ( v412 + 1 >= 0x1000 )
          {
            v115 = (_BYTE *)*((_DWORD *)Block - 1);
            if ( (unsigned int)((_BYTE *)Block - v115 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_1001D481(v115);
        }
        v116 = v111 & 0xBFFFFFFF;
        Block = v400;
        v408 = v401;
        v409 = v402;
        v410 = v403;
        v411 = v404;
        LOBYTE(v413) = 16;
        v412 = v405;
        v404 = 0;
        v405 = 15;
        LOBYTE(v400) = 0;
        if ( v397 )
        {
          if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v397 + 32), 0xFFFFFFFF) )
          {
            v117 = v397;
            while ( v117 )
            {
              v118 = (void (__thiscall ***)(_DWORD, int))v117;
              v119 = (_DWORD *)(v117 + 12);
              v117 = *(_DWORD *)(v117 + 12);
              *v119 = 0;
              (**v118)(v118, 1);
            }
          }
        }
        v397 = 0;
        if ( v399 )
        {
          v120 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
          if ( v120 )
            (**v120)(v120, 1);
        }
        v379 = 0;
        sub_10012060(v380);
        LOBYTE(v413) = 51;
        sub_10012B50(&v379, (int)"(add|sub|mul|min|max) (oFog|oPts), (.+), ([cr][0-9]+)\\n", (int)"", v121);
        v359 = 15;
        v122 = v116 | 0x80000000;
        memset(v357, 0, sizeof(v357));
        v358 = 0;
        v390 = v122;
        v391 = 0;
        v392 = 0;
        v393 = 0;
        v394 = 0;
        v395 = 0;
        LOBYTE(v413) = 54;
        v396 = 15;
        v391 = operator new(0x30u);
        v395 = 36;
        v396 = 47;
        strcpy((char *)v391, "$1 $2, $3, $4.x /* added swizzle */\n");
        LOBYTE(v413) = 55;
        if ( v412 < 0x10 )
        {
          v124 = (char *)&Block + v411;
          v123 = (char *)&Block;
        }
        else
        {
          v123 = (char *)Block;
          v124 = (char *)Block + v411;
        }
        sub_10014950((void ***)&a3, v123, v357, v124, &v379, (char *)&v391, 0);
        LOBYTE(v413) = 53;
        if ( v396 >= 0x10 )
        {
          v125 = v391;
          if ( v396 + 1 >= 0x1000 )
          {
            v125 = (_BYTE *)*((_DWORD *)v391 - 1);
            if ( (unsigned int)((_BYTE *)v391 - v125 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_1001D481(v125);
        }
        sub_10005F60(&Block, v357);
        v406 = v122 & 0x7FFFFFFF;
        sub_100019D0(v357);
        LOBYTE(v413) = 16;
        sub_10011BD0(&v379);
        v127 = (int *)sub_10011C30((int)&v397, "(mov|mad) (oFog|oPts)(.*), (-?)([crv][0-9]+(?![\\.0-9]))", v126);
        LOBYTE(v413) = 56;
        v128 = (_DWORD *)sub_10012920(
                           (int)v348,
                           (char *)&Block,
                           v127,
                           "$1 $2$3, $4$5.x /* select single component */",
                           0);
        sub_10005F60(&Block, v128);
        sub_100019D0(v348);
        LOBYTE(v413) = 16;
        sub_10011BD0(&v397);
        v130 = (int *)sub_10011C30((int)v335, "m.x.", v129);
        LOBYTE(v413) = 57;
        v131 = sub_10012A20((int *)&Block, v130);
        LOBYTE(v413) = 16;
        v132 = v131;
        sub_10011BD0(v335);
        if ( v132 )
        {
          v134 = 0;
          while ( 1 )
          {
            v135 = v336;
            v136 = v134;
            do
            {
              --v135;
              LOBYTE(v133) = 10 * (v136 / 0xA);
              *v135 = v136 % 0xA + 48;
              v136 /= 0xAu;
            }
            while ( v136 );
            v137 = v406;
            sub_10013920(v383, v135, v336, v133);
            LOBYTE(v413) = 58;
            v138 = sub_10012380((const void **)v383, 0, "r", 1u);
            v406 = v137 | 0x38000000;
            v139 = (void *)*v138;
            v140 = (unsigned int)v138[4];
            v351 = (void *)v138[1];
            v352 = (void *)v138[2];
            v353 = v138[3];
            v141 = (unsigned int)v138[5];
            v138[4] = 0;
            v138[5] = (const void *)15;
            HIBYTE(a3) = v141 >= 0x10;
            *(_BYTE *)v138 = 0;
            v142 = (char *)&v350;
            v350 = v139;
            v354 = v140;
            a6 = v141;
            v355 = v141;
            if ( v141 >= 0x10 )
              v142 = (char *)v139;
            v143 = &Block;
            if ( v412 >= 0x10 )
              v143 = Block;
            v378 = sub_10012CA0((int)v143, v411, 0, v142, v140);
            if ( HIBYTE(a3) )
            {
              v144 = v139;
              if ( (unsigned int)(a6 + 1) >= 0x1000 )
              {
                v139 = (void *)*((_DWORD *)v139 - 1);
                if ( (unsigned int)(v144 - (_BYTE *)v139 - 4) > 0x1F )
                  goto LABEL_386;
              }
              sub_1001D481(v139);
            }
            LOBYTE(v413) = 16;
            v133 = v385;
            if ( v385 >= 0x10 )
            {
              v145 = v383[0];
              if ( v385 + 1 >= 0x1000 )
              {
                v145 = (void *)*((_DWORD *)v383[0] - 1);
                if ( (unsigned int)(v383[0] - v145 - 4) > 0x1F )
                  goto LABEL_386;
              }
              sub_1001D481(v145);
            }
            if ( v378 != -1 && ++v134 < 0xC )
              continue;
            v146 = 0;
            a6 = 0;
            while ( 1 )
            {
              v147 = v336;
              v148 = v146;
              do
              {
                --v147;
                LOBYTE(v133) = 10 * (v148 / 0xA);
                *v147 = v148 % 0xA + 48;
                v148 /= 0xAu;
              }
              while ( v148 );
              sub_10013920(v339, v147, v336, v133);
              v406 |= 0x600000u;
              LOBYTE(v413) = 59;
              v150 = v382;
              v151 = a6;
              do
              {
                --v150;
                LOBYTE(v149) = 10 * (v151 / 0xA);
                *v150 = v151 % 0xA + 48;
                v151 /= 0xAu;
              }
              while ( v151 );
              v152 = v406;
              sub_10013920(v341, v150, v382, v149);
              LOBYTE(v413) = 60;
              v153 = sub_10012380((const void **)v341, 0, "(m.x.) (r", 9u);
              v154 = v152 | 0x1C0000;
              Src = 0;
              v361 = 0;
              v362 = 0;
              v363 = 0;
              v364 = 0;
              v365 = 0;
              Src = (void *)*v153;
              v361 = v153[1];
              v362 = v153[2];
              v363 = v153[3];
              v364 = (char *)v153[4];
              v365 = (unsigned int)v153[5];
              v153[4] = 0;
              v153[5] = (const void *)15;
              *(_BYTE *)v153 = 0;
              LOBYTE(v413) = 61;
              v155 = (int)v364;
              if ( v365 - (unsigned int)v364 < 9 )
              {
                LOBYTE(v378) = 0;
                v158 = sub_10001D90(&Src, 9u, v378, "), ((-?)r", 9u);
              }
              else
              {
                v364 += 9;
                p_Src = (char *)&Src;
                if ( v365 >= 0x10 )
                  p_Src = (char *)Src;
                v157 = &p_Src[v155];
                memmove(&p_Src[v155], "), ((-?)r", 9u);
                v157[9] = 0;
                v158 = &Src;
              }
              v159 = (int)v158[4];
              v391 = *v158;
              v392 = v158[1];
              v393 = v158[2];
              v160 = (int)v158[3];
              v395 = v159;
              v161 = (unsigned int)v158[5];
              v394 = v160;
              v396 = v161;
              v158[4] = 0;
              v158[5] = (void *)15;
              *(_BYTE *)v158 = 0;
              LOBYTE(v413) = 62;
              sub_10013570(v343, a3, &v391, v339);
              v162 = v154 | 0x30000;
              LOBYTE(v413) = 63;
              v163 = v344;
              if ( v345 - v344 < 0x15 )
              {
                LOBYTE(v356) = 0;
                v166 = sub_10001D90(v343, 0x15u, v356, "([\\.xyzw]*))(?![0-9])", 0x15u);
              }
              else
              {
                v344 += 21;
                v164 = v343;
                if ( v345 >= 0x10 )
                  v164 = (void **)v343[0];
                v165 = (char *)v164 + v163;
                memmove((char *)v164 + v163, "([\\.xyzw]*))(?![0-9])", 0x15u);
                v165[21] = 0;
                v166 = v343;
              }
              v167 = v162 | 0x800000;
              v372 = 0;
              v373 = 0;
              v374 = 0;
              v375 = 0;
              v376 = 0;
              v377 = 0;
              v372 = *v166;
              v373 = v166[1];
              v374 = v166[2];
              v375 = v166[3];
              v376 = (size_t)v166[4];
              v377 = (unsigned int)v166[5];
              v166[4] = 0;
              v166[5] = (void *)15;
              *(_BYTE *)v166 = 0;
              v406 = v167;
              LOBYTE(v413) = 65;
              if ( v345 >= 0x10 )
              {
                v168 = v343[0];
                if ( v345 + 1 >= 0x1000 )
                {
                  v168 = (void *)*((_DWORD *)v343[0] - 1);
                  if ( (unsigned int)(v343[0] - v168 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v168);
              }
              v344 = 0;
              v345 = 15;
              LOBYTE(v343[0]) = 0;
              LOBYTE(v413) = 66;
              if ( v396 >= 0x10 )
              {
                v169 = v391;
                if ( v396 + 1 >= 0x1000 )
                {
                  v169 = (_BYTE *)*((_DWORD *)v391 - 1);
                  if ( (unsigned int)((_BYTE *)v391 - v169 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v169);
              }
              LOBYTE(v413) = 67;
              if ( v365 >= 0x10 )
              {
                v170 = Src;
                if ( v365 + 1 >= 0x1000 )
                {
                  v170 = (_BYTE *)*((_DWORD *)Src - 1);
                  if ( (unsigned int)((_BYTE *)Src - v170 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v170);
              }
              v364 = 0;
              v365 = 15;
              LOBYTE(Src) = 0;
              LOBYTE(v413) = 68;
              if ( v342 >= 0x10 )
              {
                v171 = v341[0];
                if ( v342 + 1 >= 0x1000 )
                {
                  v171 = (void *)*((_DWORD *)v341[0] - 1);
                  if ( (unsigned int)(v341[0] - v171 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v171);
              }
              v341[4] = 0;
              v342 = 15;
              LOBYTE(v341[0]) = 0;
              LOBYTE(v413) = 69;
              if ( v340 >= 0x10 )
              {
                v172 = v339[0];
                if ( v340 + 1 >= 0x1000 )
                {
                  v172 = (void *)*((_DWORD *)v339[0] - 1);
                  if ( (unsigned int)(v339[0] - v172 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v172);
              }
              v339[4] = 0;
              v340 = 15;
              LOBYTE(v339[0]) = 0;
              while ( 1 )
              {
                v397 = 0;
                sub_10012060(v398);
                LOBYTE(v413) = 70;
                if ( v377 < 0x10 )
                {
                  v174 = (char *)&v372 + v376;
                  v173 = &v372;
                }
                else
                {
                  v173 = v372;
                  v174 = (char *)v372 + v376;
                }
                sub_10012B50(&v397, (int)v173, (int)v174, (int)v173);
                LOBYTE(v413) = 71;
                v175 = (char *)&Block;
                if ( v412 >= 0x10 )
                  v175 = (char *)Block;
                HIBYTE(a3) = sub_10013A70((int)v175, &v175[v411], 0, &v397, 0x10u, (int)v175);
                LOBYTE(v413) = 69;
                sub_100121B0(&v397);
                v176 = v399;
                if ( v399 )
                {
                  v177 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
                  if ( v177 )
                    (**v177)(v177, 1);
                }
                if ( !HIBYTE(a3) )
                  goto LABEL_273;
                if ( v134 >= 0xC || a4 >= 0x80 )
                  break;
                v178 = v336;
                ++a4;
                v179 = v134;
                do
                {
                  --v178;
                  LOBYTE(v176) = 10 * (v179 / 0xA);
                  *v178 = v179 % 0xA + 48;
                  v179 /= 0xAu;
                }
                while ( v179 );
                sub_10013920(v348, v178, v336, v176);
                v406 |= 0x180u;
                LOBYTE(v413) = 72;
                v181 = v382;
                v182 = v134;
                do
                {
                  --v181;
                  LOBYTE(v180) = 10 * (v182 / 0xA);
                  *v181 = v182 % 0xA + 48;
                  v182 /= 0xAu;
                }
                while ( v182 );
                sub_10013920(v383, v181, v382, v180);
                v406 |= 0x60u;
                LOBYTE(v413) = 73;
                v184 = v336;
                v185 = v134;
                do
                {
                  --v184;
                  LOBYTE(v183) = 10 * (v185 / 0xA);
                  *v184 = v185 % 0xA + 48;
                  v185 /= 0xAu;
                }
                while ( v185 );
                sub_10013920(v346, v184, v336, v183);
                v186 = v406 | 0x18;
                LOBYTE(v413) = 74;
                v187 = sub_10012380((const void **)v346, 0, "mov r", 5u);
                v188 = v186 | 0x800;
                v400 = 0;
                v401 = 0;
                v402 = 0;
                v403 = 0;
                v404 = 0;
                v405 = 0;
                v400 = (void *)*v187;
                v401 = (void *)v187[1];
                v402 = (void *)v187[2];
                v403 = (void *)v187[3];
                v404 = (unsigned int)v187[4];
                v405 = (unsigned int)v187[5];
                v187[4] = 0;
                v187[5] = (const void *)15;
                *(_BYTE *)v187 = 0;
                LOBYTE(v413) = 75;
                v189 = v404;
                if ( v405 - v404 < 0x24 )
                {
                  LOBYTE(v371) = 0;
                  v192 = sub_10001D90(&v400, 0x24u, v371, ", $2 /* added line */\n    $1 $2, $4r", 0x24u);
                }
                else
                {
                  v404 += 36;
                  v190 = (char *)&v400;
                  if ( v405 >= 0x10 )
                    v190 = (char *)v400;
                  v191 = &v190[v189];
                  memmove(&v190[v189], ", $2 /* added line */\n    $1 $2, $4r", 0x24u);
                  v191[36] = 0;
                  v192 = &v400;
                }
                v193 = (int)v192[4];
                v350 = *v192;
                v351 = v192[1];
                v352 = v192[2];
                v194 = (int)v192[3];
                v354 = v193;
                v195 = (unsigned int)v192[5];
                v353 = (const void *)v194;
                v355 = v195;
                v192[4] = 0;
                v192[5] = (void *)15;
                *(_BYTE *)v192 = 0;
                LOBYTE(v413) = 76;
                sub_10013570(&v391, a3, &v350, v383);
                v196 = v188 | 0x3000;
                LOBYTE(v413) = 77;
                v197 = v395;
                if ( v396 - v395 < 0x15 )
                {
                  LOBYTE(v338) = 0;
                  v200 = sub_10001D90(&v391, 0x15u, v338, "$5 /* changed $3 to r", 0x15u);
                }
                else
                {
                  v395 += 21;
                  v198 = (char *)&v391;
                  if ( v396 >= 0x10 )
                    v198 = (char *)v391;
                  v199 = &v198[v197];
                  memmove(&v198[v197], "$5 /* changed $3 to r", 0x15u);
                  v199[21] = 0;
                  v200 = &v391;
                }
                v201 = v200[4];
                v331[0] = *v200;
                v331[1] = v200[1];
                v331[2] = v200[2];
                v202 = v200[3];
                v331[4] = v201;
                v203 = (unsigned int)v200[5];
                v331[3] = v202;
                v332 = v203;
                v200[4] = 0;
                v200[5] = (void *)15;
                *(_BYTE *)v200 = 0;
                LOBYTE(v413) = 78;
                sub_10013570(v357, a3, v331, v348);
                v204 = v196 | 0x600;
                LOBYTE(v413) = 79;
                v205 = v358;
                if ( v359 - v358 < 3 )
                {
                  LOBYTE(v337) = 0;
                  v208 = sub_10001D90(v357, 3u, v337, " */", 3u);
                }
                else
                {
                  v358 += 3;
                  v206 = v357;
                  if ( v359 >= 0x10 )
                    v206 = (void **)v357[0];
                  v207 = (char *)v206 + v205;
                  memmove((char *)v206 + v205, " */", 3u);
                  v207[3] = 0;
                  v208 = v357;
                }
                v209 = v204 | 0x8000;
                v210 = v208[4];
                v333[0] = *v208;
                v333[1] = v208[1];
                v333[2] = v208[2];
                v211 = v208[3];
                v333[4] = v210;
                v212 = (unsigned int)v208[5];
                v333[3] = v211;
                v334 = v212;
                v208[4] = 0;
                v208[5] = (void *)15;
                *(_BYTE *)v208 = 0;
                LOBYTE(v413) = 80;
                v397 = 0;
                sub_10012060(v398);
                LOBYTE(v413) = 81;
                if ( v377 < 0x10 )
                {
                  v214 = (char *)&v372 + v376;
                  v213 = &v372;
                }
                else
                {
                  v213 = v372;
                  v214 = (char *)v372 + v376;
                }
                sub_10012B50(&v397, (int)v213, (int)v214, (int)v213);
                LOBYTE(v413) = 83;
                v370 = 15;
                memset(v368, 0, sizeof(v368));
                v215 = v209 | 0x4000;
                v369 = 0;
                v390 = v215;
                if ( v412 < 0x10 )
                {
                  v217 = (char *)&Block + v411;
                  v216 = (char *)&Block;
                }
                else
                {
                  v216 = (char *)Block;
                  v217 = (char *)Block + v411;
                }
                sub_10014950((void ***)&v367, v216, v368, v217, &v397, (char *)v333, 4096);
                sub_10005F60(&Block, v368);
                v167 = v215 & 0xFFFFBFFF;
                LOBYTE(v413) = 82;
                v406 = v167;
                if ( v370 >= 0x10 )
                {
                  v218 = v368[0];
                  if ( v370 + 1 >= 0x1000 )
                  {
                    v218 = (void *)*((_DWORD *)v368[0] - 1);
                    if ( (unsigned int)(v368[0] - v218 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v218);
                }
                v369 = 0;
                v370 = 15;
                LOBYTE(v368[0]) = 0;
                sub_100121B0(&v397);
                if ( v399 )
                {
                  v219 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
                  if ( v219 )
                    (**v219)(v219, 1);
                }
                LOBYTE(v413) = 79;
                if ( v334 >= 0x10 )
                {
                  v220 = v333[0];
                  if ( v334 + 1 >= 0x1000 )
                  {
                    v220 = (void *)*((_DWORD *)v333[0] - 1);
                    if ( (unsigned int)(v333[0] - v220 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v220);
                }
                LOBYTE(v413) = 78;
                if ( v359 >= 0x10 )
                {
                  v221 = v357[0];
                  if ( v359 + 1 >= 0x1000 )
                  {
                    v221 = (void *)*((_DWORD *)v357[0] - 1);
                    if ( (unsigned int)(v357[0] - v221 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v221);
                }
                LOBYTE(v413) = 77;
                v358 = 0;
                v359 = 15;
                LOBYTE(v357[0]) = 0;
                if ( v332 >= 0x10 )
                {
                  v222 = v331[0];
                  if ( v332 + 1 >= 0x1000 )
                  {
                    v222 = (void *)*((_DWORD *)v331[0] - 1);
                    if ( (unsigned int)(v331[0] - v222 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v222);
                }
                LOBYTE(v413) = 76;
                if ( v396 >= 0x10 )
                {
                  v223 = v391;
                  if ( v396 + 1 >= 0x1000 )
                  {
                    v223 = (_BYTE *)*((_DWORD *)v391 - 1);
                    if ( (unsigned int)((_BYTE *)v391 - v223 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v223);
                }
                LOBYTE(v413) = 75;
                v395 = 0;
                v396 = 15;
                LOBYTE(v391) = 0;
                if ( v355 >= 0x10 )
                {
                  v224 = v350;
                  if ( v355 + 1 >= 0x1000 )
                  {
                    v224 = (_BYTE *)*((_DWORD *)v350 - 1);
                    if ( (unsigned int)((_BYTE *)v350 - v224 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v224);
                }
                LOBYTE(v413) = 74;
                if ( v405 >= 0x10 )
                {
                  v225 = v400;
                  if ( v405 + 1 >= 0x1000 )
                  {
                    v225 = (_BYTE *)*((_DWORD *)v400 - 1);
                    if ( (unsigned int)((_BYTE *)v400 - v225 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v225);
                }
                LOBYTE(v413) = 73;
                v404 = 0;
                v405 = 15;
                LOBYTE(v400) = 0;
                if ( v347 >= 0x10 )
                {
                  v226 = v346[0];
                  if ( v347 + 1 >= 0x1000 )
                  {
                    v226 = (void *)*((_DWORD *)v346[0] - 1);
                    if ( (unsigned int)(v346[0] - v226 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v226);
                }
                LOBYTE(v413) = 72;
                v346[4] = 0;
                v347 = 15;
                LOBYTE(v346[0]) = 0;
                if ( v385 >= 0x10 )
                {
                  v227 = v383[0];
                  if ( v385 + 1 >= 0x1000 )
                  {
                    v227 = (void *)*((_DWORD *)v383[0] - 1);
                    if ( (unsigned int)(v383[0] - v227 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v227);
                }
                LOBYTE(v413) = 69;
                v384 = 0;
                v385 = 15;
                LOBYTE(v383[0]) = 0;
                if ( v349 >= 0x10 )
                {
                  v228 = v348[0];
                  if ( v349 + 1 >= 0x1000 )
                  {
                    v228 = (void *)*((_DWORD *)v348[0] - 1);
                    if ( (unsigned int)(v348[0] - v228 - 4) > 0x1F )
                      goto LABEL_386;
                  }
                  sub_1001D481(v228);
                }
              }
              if ( 0x7FFFFFFF - v376 < 3 )
                sub_100012E0();
              v229 = &v372;
              if ( v377 >= 0x10 )
                v229 = v372;
              sub_100137A0(&v391, a3, v376, "(.*", 3u, v229, v376);
              v230 = v167 | 0x2000000;
              LOBYTE(v413) = 84;
              v231 = v395;
              if ( v396 - v395 < 3 )
              {
                v336[3] = 0;
                v234 = sub_10001D90(&v391, 3u, *(int *)&v336[3], ".*)", 3u);
              }
              else
              {
                v395 += 3;
                v232 = (char *)&v391;
                if ( v396 >= 0x10 )
                  v232 = (char *)v391;
                v233 = &v232[v231];
                memmove(&v232[v231], ".*)", 3u);
                v233[3] = 0;
                v234 = &v391;
              }
              v167 = v230 | 0x1000000;
              v400 = 0;
              v401 = 0;
              v402 = 0;
              v403 = 0;
              v404 = 0;
              v405 = 0;
              v400 = *v234;
              v401 = v234[1];
              v402 = v234[2];
              v403 = v234[3];
              v404 = (unsigned int)v234[4];
              v405 = (unsigned int)v234[5];
              v234[4] = 0;
              v234[5] = (void *)15;
              *(_BYTE *)v234 = 0;
              v406 = v167;
              LOBYTE(v413) = 85;
              v397 = 0;
              sub_10012060(v398);
              LOBYTE(v413) = 86;
              if ( v405 < 0x10 )
              {
                v236 = (char *)&v400 + v404;
                v235 = &v400;
              }
              else
              {
                v235 = v400;
                v236 = (char *)v400 + v404;
              }
              sub_10012B50(&v397, (int)v235, (int)v236, (int)v235);
              LOBYTE(v413) = 87;
              v237 = (_DWORD *)sub_10012920((int)v383, (char *)&Block, &v397, "/*$1*/ /* disabled this line */", 0);
              sub_10005F60(&Block, v237);
              if ( v385 >= 0x10 )
              {
                v238 = v383[0];
                if ( v385 + 1 >= 0x1000 )
                {
                  v238 = (void *)*((_DWORD *)v383[0] - 1);
                  if ( (unsigned int)(v383[0] - v238 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v238);
              }
              v384 = 0;
              v385 = 15;
              LOBYTE(v383[0]) = 0;
              if ( v397 )
              {
                if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v397 + 32), 0xFFFFFFFF) )
                {
                  v239 = v397;
                  while ( v239 )
                  {
                    v240 = (void (__thiscall ***)(_DWORD, int))v239;
                    v241 = (_DWORD *)(v239 + 12);
                    v239 = *(_DWORD *)(v239 + 12);
                    *v241 = 0;
                    (**v240)(v240, 1);
                  }
                }
              }
              v397 = 0;
              if ( v399 )
              {
                v242 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
                if ( v242 )
                  (**v242)(v242, 1);
              }
              LOBYTE(v413) = 84;
              if ( v405 >= 0x10 )
              {
                v243 = v400;
                if ( v405 + 1 >= 0x1000 )
                {
                  v243 = (_BYTE *)*((_DWORD *)v400 - 1);
                  if ( (unsigned int)((_BYTE *)v400 - v243 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v243);
              }
              LOBYTE(v413) = 69;
              v404 = 0;
              v405 = 15;
              LOBYTE(v400) = 0;
              if ( v396 >= 0x10 )
              {
                v244 = v391;
                if ( v396 + 1 >= 0x1000 )
                {
                  v244 = (_BYTE *)*((_DWORD *)v391 - 1);
                  if ( (unsigned int)((_BYTE *)v391 - v244 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v244);
              }
LABEL_273:
              LOBYTE(v413) = 16;
              v133 = v377;
              if ( v377 >= 0x10 )
              {
                v245 = v372;
                if ( v377 + 1 >= 0x1000 )
                {
                  v245 = (_BYTE *)*((_DWORD *)v372 - 1);
                  if ( (unsigned int)((_BYTE *)v372 - v245 - 4) > 0x1F )
                    goto LABEL_386;
                }
                sub_1001D481(v245);
              }
              v146 = a6 + 1;
              a6 = v146;
              if ( v146 >= 0xC )
                goto LABEL_280;
            }
          }
        }
        v167 = v406;
LABEL_280:
        v397 = 0;
        sub_10012060(v398);
        LOBYTE(v413) = 88;
        sub_10012B50(&v397, (int)"    ([a-z2-4]*) oPos\\.", (int)"", v246);
        LOBYTE(v413) = 89;
        v247 = (char *)&Block;
        v248 = v167 | 2;
        v390 = v248;
        if ( v412 >= 0x10 )
          v247 = (char *)Block;
        if ( !sub_10013A70((int)v247, &v247[v411], 0, &v397, 0x10u, (int)v247) )
          goto LABEL_286;
        v379 = 0;
        sub_10012060(v380);
        v413 = 90;
        sub_10012B50(&v379, (int)"    ([a-z2-4]*) oPos,", (int)"", v249);
        v413 = 91;
        v250 = (char *)&Block;
        v248 |= 4u;
        v390 = v248;
        if ( v412 >= 0x10 )
          v250 = (char *)Block;
        v251 = sub_10013A70((int)v250, &v250[v411], 0, &v379, 0x10u, (int)v250);
        HIBYTE(a3) = 1;
        if ( v251 )
LABEL_286:
          HIBYTE(a3) = 0;
        if ( (v248 & 4) != 0 )
        {
          v248 &= ~4u;
          sub_100121B0(&v379);
          if ( v381 )
          {
            v252 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v381 + 8))(v381);
            if ( v252 )
              (**v252)(v252, 1);
          }
        }
        v413 = 16;
        if ( (v248 & 2) != 0 )
        {
          v248 &= ~2u;
          if ( v397 )
          {
            if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v397 + 32), 0xFFFFFFFF) )
            {
              v253 = v397;
              while ( v253 )
              {
                v254 = (void (__thiscall ***)(_DWORD, int))v253;
                v255 = (_DWORD *)(v253 + 12);
                v253 = *(_DWORD *)(v253 + 12);
                *v255 = 0;
                (**v254)(v254, 1);
              }
            }
          }
          v397 = 0;
          if ( v399 )
          {
            v256 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
            if ( v256 )
              (**v256)(v256, 1);
          }
        }
        if ( HIBYTE(a3) )
        {
          v379 = 0;
          sub_10012060(v380);
          LOBYTE(v413) = 92;
          sub_10012B50(&v379, (int)"    ([a-z2-4]*) oPos\\.[y|z|w]*x", (int)"", v257);
          LOBYTE(v413) = 93;
          v258 = (char *)&Block;
          if ( v412 >= 0x10 )
            v258 = (char *)Block;
          HIBYTE(a3) = sub_10013A70((int)v258, &v258[v411], 0, &v379, 0x10u, (int)v258);
          LOBYTE(v413) = 16;
          sub_100121B0(&v379);
          if ( v381 )
          {
            v259 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v381 + 8))(v381);
            if ( v259 )
              (**v259)(v259, 1);
          }
          v379 = 0;
          sub_10012060(v380);
          LOBYTE(v413) = 94;
          sub_10012B50(&v379, (int)"    ([a-z2-4]*) oPos\\.[x|z|w]*y", (int)"", v260);
          LOBYTE(v413) = 95;
          v261 = (char *)&Block;
          if ( v412 >= 0x10 )
            v261 = (char *)Block;
          HIBYTE(a4) = sub_10013A70((int)v261, &v261[v411], 0, &v379, 0x10u, (int)v261);
          LOBYTE(v413) = 16;
          sub_100121B0(&v379);
          if ( v381 )
          {
            v262 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v381 + 8))(v381);
            if ( v262 )
              (**v262)(v262, 1);
          }
          v397 = 0;
          sub_10012060(v398);
          LOBYTE(v413) = 96;
          sub_10012B50(&v397, (int)"    ([a-z2-4]*) oPos\\.[x|y|w]*z", (int)"", v263);
          LOBYTE(v413) = 97;
          v264 = (char *)&Block;
          if ( v412 >= 0x10 )
            v264 = (char *)Block;
          v265 = sub_10013A70((int)v264, &v264[v411], 0, &v397, 0x10u, (int)v264);
          LOBYTE(v413) = 16;
          HIBYTE(a6) = v265;
          if ( v397 )
          {
            if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v397 + 32), 0xFFFFFFFF) )
            {
              v266 = v397;
              while ( v266 )
              {
                v267 = (void (__thiscall ***)(_DWORD, int))v266;
                v268 = (_DWORD *)(v266 + 12);
                v266 = *(_DWORD *)(v266 + 12);
                *v268 = 0;
                (**v267)(v267, 1);
              }
            }
          }
          v397 = 0;
          if ( v399 )
          {
            v269 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
            if ( v269 )
              (**v269)(v269, 1);
          }
          v397 = 0;
          sub_10012060(v398);
          LOBYTE(v413) = 98;
          sub_10012B50(&v397, (int)"    ([a-z2-4]*) oPos\\.[x|y|z]*w", (int)"", v270);
          LOBYTE(v413) = 99;
          v271 = (char *)&Block;
          if ( v412 >= 0x10 )
            v271 = (char *)Block;
          v272 = sub_10013A70((int)v271, &v271[v411], 0, &v397, 0x10u, (int)v271);
          LOBYTE(v413) = 16;
          v387 = v272;
          if ( v397 )
          {
            if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v397 + 32), 0xFFFFFFFF) )
            {
              v273 = v397;
              while ( v273 )
              {
                v274 = (void (__thiscall ***)(_DWORD, int))v273;
                v275 = (_DWORD *)(v273 + 12);
                v273 = *(_DWORD *)(v273 + 12);
                *v275 = 0;
                (**v274)(v274, 1);
              }
            }
          }
          v397 = 0;
          if ( v399 )
          {
            v276 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
            if ( v276 )
              (**v276)(v276, 1);
          }
          if ( !HIBYTE(a3) || !HIBYTE(a4) || !HIBYTE(a6) || !v387 )
          {
            v397 = 0;
            sub_10012060(v398);
            LOBYTE(v413) = 100;
            sub_10012B50(&v397, (int)"    ([a-z2-4]*) (oPos\\.[x|y|z|w]*,) ([^\\n]*)\\n", (int)"", v277);
            v405 = 15;
            v400 = 0;
            v401 = 0;
            v402 = 0;
            v403 = 0;
            v404 = 0;
            v390 = v248 | 0x4000000;
            v391 = 0;
            v392 = 0;
            v393 = 0;
            v394 = 0;
            v395 = 0;
            LOBYTE(v413) = 103;
            v396 = 15;
            v391 = operator new(0x30u);
            v395 = 44;
            v396 = 47;
            strcpy((char *)v391, "    $1 oPos, $3 /* removed oPos swizzles */\n");
            LOBYTE(v413) = 104;
            if ( v412 < 0x10 )
            {
              v279 = (char *)&Block + v411;
              v278 = (char *)&Block;
            }
            else
            {
              v278 = (char *)Block;
              v279 = (char *)Block + v411;
            }
            sub_10014950((void ***)&a3, v278, &v400, v279, &v397, (char *)&v391, 0);
            LOBYTE(v413) = 102;
            if ( v396 >= 0x10 )
            {
              v280 = v391;
              if ( v396 + 1 >= 0x1000 )
              {
                v280 = (_BYTE *)*((_DWORD *)v391 - 1);
                if ( (unsigned int)((_BYTE *)v391 - v280 - 4) > 0x1F )
                  _invalid_parameter_noinfo_noreturn();
              }
              sub_1001D481(v280);
            }
            if ( v412 >= 0x10 )
            {
              v281 = Block;
              if ( v412 + 1 >= 0x1000 )
              {
                v281 = (_BYTE *)*((_DWORD *)Block - 1);
                if ( (unsigned int)((_BYTE *)Block - v281 - 4) > 0x1F )
                  _invalid_parameter_noinfo_noreturn();
              }
              sub_1001D481(v281);
            }
            Block = v400;
            v408 = v401;
            v409 = v402;
            v410 = v403;
            v411 = v404;
            v412 = v405;
            LOBYTE(v413) = 16;
            v404 = 0;
            v405 = 15;
            LOBYTE(v400) = 0;
            if ( v397 )
            {
              if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v397 + 32), 0xFFFFFFFF) )
              {
                v282 = v397;
                while ( v282 )
                {
                  v283 = (void (__thiscall ***)(_DWORD, int))v282;
                  v284 = (_DWORD *)(v282 + 12);
                  v282 = *(_DWORD *)(v282 + 12);
                  *v284 = 0;
                  (**v283)(v283, 1);
                }
              }
            }
            v397 = 0;
            if ( v399 )
            {
              v285 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v399 + 8))(v399);
              if ( v285 )
                (**v285)(v285, 1);
            }
          }
        }
        v286 = sub_10006250(&dword_10053148, "> Dumping translated shader assembly:");
        v287 = sub_100064E0(v286);
        v288 = sub_100064E0(v287);
        v289 = &Block;
        if ( v412 >= 0x10 )
          v289 = Block;
        v290 = sub_10001EF0(v288, (int)v289, v411);
        sub_100064E0(v290);
        if ( dword_10053124 )
        {
          v291 = &Block;
          if ( v412 >= 0x10 )
            v291 = Block;
          v53 = dword_10053124(v291, v411, 0, 0, 0, &v386);
          (*(void (__stdcall **)(int))(*(_DWORD *)v389 + 8))(v389);
          if ( v53 >= 0 )
          {
            v292 = (unsigned int)operator new(8u);
            *(_DWORD *)v292 = 0;
            *(_DWORD *)(v292 + 4) = 0;
            v293 = *(_DWORD *)(a2 + 12);
            v294 = *(int (__stdcall **)(int, int, unsigned int))(*(_DWORD *)v293 + 364);
            v295 = (*(int (__stdcall **)(float *))(*(_DWORD *)v386 + 12))(v386);
            v53 = v294(v293, v295, v292);
            (*(void (__stdcall **)(float *))(*(_DWORD *)v386 + 8))(v386);
            LOBYTE(v413) = 0;
            if ( v412 < 0x10 )
              goto LABEL_360;
            v296 = Block;
            if ( v412 + 1 < 0x1000
              || (v296 = (void *)*((_DWORD *)Block - 1), (unsigned int)((_BYTE *)Block - (_BYTE *)v296 - 4) <= 0x1F) )
            {
              sub_1001D481(v296);
LABEL_360:
              v411 = 0;
              v412 = 15;
              LOBYTE(Block) = 0;
              if ( v53 < 0 )
              {
                v297 = sub_10006250(&dword_10053148, "> 'IDirect3DDevice9::CreateVertexShader' failed with error code ");
                *(_DWORD *)&v297[*(_DWORD *)(*(_DWORD *)v297 + 4) + 20] = *(_DWORD *)&v297[*(_DWORD *)(*(_DWORD *)v297 + 4)
                                                                                         + 20] & 0xFFFFF1FF | 0x800;
                v298 = sub_10011CA0(v297, v53);
                *(_DWORD *)&v298[*(_DWORD *)(*(_DWORD *)v298 + 4) + 20] = *(_DWORD *)&v298[*(_DWORD *)(*(_DWORD *)v298 + 4)
                                                                                         + 20] & 0xFFFFF1FF | 0x200;
                v299 = sub_10006250(v298, "!");
                sub_100064E0(v299);
LABEL_379:
                sub_1001D481((void *)v292);
                goto LABEL_380;
              }
              goto LABEL_375;
            }
LABEL_394:
            _invalid_parameter_noinfo_noreturn();
          }
        }
        else
        {
          v53 = -2005530516;
          (*(void (__cdecl **)(int))(*(_DWORD *)v389 + 8))(v389);
        }
        if ( v388 )
        {
          v300 = sub_10006250(&dword_10053148, "> Failed to reassemble shader:");
          v301 = sub_100064E0(v300);
          v302 = sub_100064E0(v301);
          v303 = (const char *)(*(int (__stdcall **)(int))(*(_DWORD *)v388 + 12))(v388);
          v304 = sub_10006250(v302, v303);
          sub_100064E0(v304);
          (*(void (__stdcall **)(int))(*(_DWORD *)v388 + 8))(v388);
        }
        else
        {
          v305 = sub_10006250(&dword_10053148, "> Failed to reassemble shader with error code ");
          *(_DWORD *)&v305[*(_DWORD *)(*(_DWORD *)v305 + 4) + 20] = *(_DWORD *)&v305[*(_DWORD *)(*(_DWORD *)v305 + 4)
                                                                                   + 20] & 0xFFFFF1FF | 0x800;
          v306 = sub_10011CA0(v305, v53);
          *(_DWORD *)&v306[*(_DWORD *)(*(_DWORD *)v306 + 4) + 20] = *(_DWORD *)&v306[*(_DWORD *)(*(_DWORD *)v306 + 4)
                                                                                   + 20] & 0xFFFFF1FF | 0x200;
          v307 = sub_10006250(v306, "!");
          sub_100064E0(v307);
        }
        if ( v412 < 0x10 )
          goto LABEL_380;
        v308 = Block;
        if ( v412 + 1 < 0x1000
          || (v308 = (void *)*((_DWORD *)Block - 1), (unsigned int)((_BYTE *)Block - (_BYTE *)v308 - 4) <= 0x1F) )
        {
          sub_1001D481(v308);
          goto LABEL_380;
        }
        goto LABEL_394;
      }
    }
    else
    {
      v53 = -2005530516;
    }
    v309 = sub_10006250(&dword_10053148, "> Failed to disassemble shader with error code ");
    v310 = sub_10011E50(v309, (void (__cdecl *)(char *))sub_10008420);
    v311 = sub_10011CA0(v310, v53);
    v312 = sub_10011E50(v311, (void (__cdecl *)(char *))sub_10008400);
    v313 = sub_10006250(v312, "!");
    sub_100064E0(v313);
    goto LABEL_380;
  }
  v292 = (unsigned int)operator new(8u);
  *(_DWORD *)v292 = 0;
  *(_DWORD *)(v292 + 4) = 0;
LABEL_375:
  v53 = (*(int (__stdcall **)(_DWORD, int *, unsigned int))(**(_DWORD **)(a2 + 12) + 344))(
          *(_DWORD *)(a2 + 12),
          v327,
          v292 + 4);
  if ( v53 < 0 )
  {
    v320 = sub_10006250(&dword_10053148, "> 'IDirect3DDevice9::CreateVertexDeclaration' failed with error code ");
    *(_DWORD *)&v320[*(_DWORD *)(*(_DWORD *)v320 + 4) + 20] = *(_DWORD *)&v320[*(_DWORD *)(*(_DWORD *)v320 + 4) + 20] & 0xFFFFF1FF | 0x800;
    v321 = sub_10011CA0(v320, v53);
    *(_DWORD *)&v321[*(_DWORD *)(*(_DWORD *)v321 + 4) + 20] = *(_DWORD *)&v321[*(_DWORD *)(*(_DWORD *)v321 + 4) + 20] & 0xFFFFF1FF | 0x200;
    v322 = sub_10006250(v321, "!");
    sub_100064E0(v322);
    if ( *(_DWORD *)v292 )
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)v292 + 8))(*(_DWORD *)v292);
    goto LABEL_379;
  }
  *a5 = (v292 >> 1) | 0x80000000;
LABEL_380:
  if ( v330 >= 0x10 )
  {
    v323 = v328[0];
    if ( v330 + 1 >= 0x1000 )
    {
      v323 = (void *)*((_DWORD *)v328[0] - 1);
      if ( (unsigned int)(v328[0] - v323 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v323);
  }
  return v53;
}
// 10053120: invalid function type '?' has been ignored
// 10053124: invalid function type '?' has been ignored
// 1000B1E0: could not find valid save-restore pair for esi
// 1000DD74: conditional instruction was optimized away because edi.4<0
// 1000B82C: variable 'v62' is possibly undefined
// 1000BD83: variable 'v96' is possibly undefined
// 1000BDD4: variable 'v99' is possibly undefined
// 1000BE25: variable 'v102' is possibly undefined
// 1000BF6F: variable 'v110' is possibly undefined
// 1000C142: variable 'v121' is possibly undefined
// 1000C276: variable 'v126' is possibly undefined
// 1000C2C4: variable 'v129' is possibly undefined
// 1000C33D: variable 'v133' is possibly undefined
// 1000C4F8: variable 'v149' is possibly undefined
// 1000C9E4: variable 'v176' is possibly undefined
// 1000CA32: variable 'v180' is possibly undefined
// 1000CA79: variable 'v183' is possibly undefined
// 1000D43E: variable 'v246' is possibly undefined
// 1000D4A1: variable 'v249' is possibly undefined
// 1000D5AC: variable 'v257' is possibly undefined
// 1000D634: variable 'v260' is possibly undefined
// 1000D6B3: variable 'v263' is possibly undefined
// 1000D759: variable 'v270' is possibly undefined
// 1000D819: variable 'v277' is possibly undefined
// 100012E0: using guessed type void __noreturn sub_100012E0(void);
// 10053120: using guessed type int (__stdcall *dword_10053120)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10053124: using guessed type int (__stdcall *dword_10053124)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10053148: using guessed type int dword_10053148;
// 1000B1E0: using guessed type int var_3A0[32];
// 1000B1E0: using guessed type float *var_80;
// 1000B1E0: using guessed type int var_1D8[5];

//----- (1000DE50) --------------------------------------------------------
int __stdcall sub_1000DE50(int a1, int a2)
{
  int *v2; // ecx
  int v3; // eax
  int result; // eax
  int v5; // esi

  v2 = *(int **)(a1 + 12);
  v3 = *v2;
  if ( a2 < 0 )
  {
    v5 = (*(int (__stdcall **)(int *, _DWORD))(v3 + 368))(v2, *(_DWORD *)(2 * a2));
    (*(void (__stdcall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 12) + 348))(
      *(_DWORD *)(a1 + 12),
      *(_DWORD *)(2 * a2 + 4));
    result = v5;
    *(_DWORD *)(a1 + 24) = a2;
  }
  else
  {
    (*(void (__stdcall **)(int *, _DWORD))(v3 + 368))(v2, 0);
    result = (*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(a1 + 12) + 356))(*(_DWORD *)(a1 + 12), a2);
    *(_DWORD *)(a1 + 24) = 0;
  }
  return result;
}

//----- (1000DEB0) --------------------------------------------------------
int __stdcall sub_1000DEB0(int a1, _DWORD *a2)
{
  int v3; // eax

  if ( !a2 )
    return -2005530516;
  v3 = *(_DWORD *)(a1 + 24);
  if ( !v3 )
    return (*(int (__stdcall **)(_DWORD, _DWORD *))(**(_DWORD **)(a1 + 12) + 360))(*(_DWORD *)(a1 + 12), a2);
  *a2 = v3;
  return 0;
}

//----- (1000DEF0) --------------------------------------------------------
int __stdcall sub_1000DEF0(_DWORD *a1, int a2)
{
  int v3; // ecx
  int v4; // ecx

  if ( a2 >= 0 )
    return -2005530516;
  if ( a1[6] == a2 )
    (*(void (__stdcall **)(_DWORD *, _DWORD))(*a1 + 304))(a1, 0);
  v3 = *(_DWORD *)(2 * a2);
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  v4 = *(_DWORD *)(2 * a2 + 4);
  if ( v4 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v4 + 8))(*(_DWORD *)(2 * a2 + 4));
  sub_1001D481((void *)(2 * a2));
  return 0;
}

//----- (1000DF50) --------------------------------------------------------
int __cdecl sub_1000DF50(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 376))(*(_DWORD *)(a1 + 12));
}

//----- (1000DF70) --------------------------------------------------------
int __cdecl sub_1000DF70(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 380))(*(_DWORD *)(a1 + 12));
}

//----- (1000DF90) --------------------------------------------------------
int __stdcall sub_1000DF90(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v4 = sub_10006250(&dword_10053148, "Redirecting '");
  v5 = sub_10006250(v4, "IDirect3DDevice8::GetVertexShaderDeclaration");
  v6 = sub_10006250(v5, "(");
  v7 = sub_10007C40(v6, (int)&savedregs, a1);
  v8 = sub_10006250(v7, ", ");
  v9 = sub_100042E0(v8, (int)&savedregs, a2);
  v10 = sub_10006250(v9, ", ");
  v11 = sub_10007C40(v10, (int)&savedregs, a3);
  v12 = sub_10006250(v11, ", ");
  v13 = sub_10007C40(v12, (int)&savedregs, a4);
  v14 = sub_10006250(v13, ")' ...");
  sub_100064E0(v14);
  v15 = sub_10006250(&dword_10053148, "> 'IDirect3DDevice8::GetVertexShaderDeclaration' is not implemented!");
  sub_100064E0(v15);
  return -2005530516;
}
// 10053148: using guessed type int dword_10053148;

//----- (1000E050) --------------------------------------------------------
int __stdcall sub_1000E050(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  int v15; // esi
  _BYTE *v16; // eax
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v4 = sub_10006250(&dword_10053148, "Redirecting '");
  v5 = sub_10006250(v4, "IDirect3DDevice8::GetVertexShaderFunction");
  v6 = sub_10006250(v5, "(");
  v7 = sub_10007C40(v6, (int)&savedregs, a1);
  v8 = sub_10006250(v7, ", ");
  v9 = sub_100042E0(v8, (int)&savedregs, a2);
  v10 = sub_10006250(v9, ", ");
  v11 = sub_10007C40(v10, (int)&savedregs, a3);
  v12 = sub_10006250(v11, ", ");
  v13 = sub_10007C40(v12, (int)&savedregs, a4);
  v14 = sub_10006250(v13, ")' ...");
  sub_100064E0(v14);
  if ( a2 >= 0 )
    return -2005530516;
  v15 = *(_DWORD *)(2 * a2);
  if ( !v15 )
    return -2005530516;
  v16 = sub_10006250(&dword_10053148, "> Returning translated shader byte code.");
  sub_100064E0(v16);
  return (*(int (__stdcall **)(int, int, int))(*(_DWORD *)v15 + 16))(v15, a3, a4);
}
// 10053148: using guessed type int dword_10053148;

//----- (1000E130) --------------------------------------------------------
int __stdcall sub_1000E130(int a1, int a2, int a3, int a4)
{
  if ( a3 )
    return (*(int (__stdcall **)(_DWORD, int, _DWORD, _DWORD, int))(**(_DWORD **)(a1 + 12) + 400))(
             *(_DWORD *)(a1 + 12),
             a2,
             *(_DWORD *)(a3 + 12),
             0,
             a4);
  else
    return -2005530516;
}

//----- (1000E170) --------------------------------------------------------
int __stdcall sub_1000E170(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // ebx
  int result; // eax
  _DWORD *v6; // esi
  int v7; // ecx
  int *v8; // esi
  int *v9; // edi
  _DWORD *v10; // edi
  int v11; // ecx
  _DWORD *v12; // eax
  int v13; // ecx
  _DWORD *v14; // [esp-8h] [ebp-24h]
  int *v15; // [esp+4h] [ebp-18h] BYREF
  int v16; // [esp+Ch] [ebp-10h] BYREF
  int v17; // [esp+18h] [ebp-4h]

  v4 = a3;
  if ( !a3 )
    return -2005530516;
  v14 = a4;
  v6 = a1;
  *a3 = 0;
  v7 = v6[3];
  v16 = 0;
  a3 = 0;
  result = (*(int (__stdcall **)(int, _DWORD *, _DWORD **, int *, _DWORD *))(*(_DWORD *)v7 + 404))(
             v7,
             a2,
             &a3,
             &v16,
             v14);
  if ( result >= 0 )
  {
    a4 = a3;
    if ( a3 )
    {
      v8 = (int *)v6[1];
      a1 = a3;
      v9 = sub_10016580(
             v8 + 41,
             &v15,
             &a1,
             16777619
           * (HIBYTE(a3) ^ (16777619
                          * (BYTE2(a3) ^ (16777619 * (BYTE1(a3) ^ (16777619 * ((unsigned __int8)a3 ^ 0x811C9DC5))))))))[1];
      if ( !v9 )
        v9 = (int *)v8[42];
      if ( v9 == (int *)v8[42] )
      {
        v10 = operator new(0x10u);
        a2 = v10;
        v17 = 0;
        v11 = *v8;
        v10[1] = &AddressLookupTableObject::`vftable';
        LOBYTE(v17) = 1;
        v12 = a4;
        v10[2] = v11;
        v10[3] = v12;
        *v10 = &Direct3DVertexBuffer8::`vftable';
        v10[1] = &Direct3DVertexBuffer8::`vftable';
        v13 = *(_DWORD *)(v11 + 4);
        a1 = v12;
        *(_DWORD *)sub_1001A560((_DWORD *)(v13 + 164), (unsigned __int8 *)&a1) = v10 + 1;
      }
      else
      {
        v10 = v9[3] != 0 ? (_DWORD *)(v9[3] - 4) : 0;
      }
      *v4 = v10;
    }
    return 0;
  }
  return result;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C440: using guessed type void *Direct3DVertexBuffer8::`vftable';
// 1004C47C: using guessed type void *Direct3DVertexBuffer8::`vftable';

//----- (1000E2D0) --------------------------------------------------------
int __stdcall sub_1000E2D0(int a1, int a2, unsigned int a3)
{
  if ( !a2 || a3 > 0x7FFFFFFF )
    return -2005530516;
  *(_DWORD *)(a1 + 16) = a3;
  return (*(int (__stdcall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 12) + 416))(
           *(_DWORD *)(a1 + 12),
           *(_DWORD *)(a2 + 12));
}

//----- (1000E310) --------------------------------------------------------
int __stdcall sub_1000E310(_DWORD *a1, int **a2, int **a3)
{
  int **v3; // ebx
  int result; // eax
  int **v5; // ecx
  int v7; // ecx
  int *v8; // esi
  int *v9; // edi
  int *v10; // edi
  int v11; // ecx
  int v12; // ecx
  int *v13[3]; // [esp+4h] [ebp-18h] BYREF
  int v14; // [esp+18h] [ebp-4h]
  int **v15; // [esp+24h] [ebp+8h]

  v3 = a2;
  if ( !a2 )
    return -2005530516;
  v5 = a3;
  *a2 = 0;
  if ( v5 )
    *v5 = (int *)a1[4];
  v7 = a1[3];
  a2 = 0;
  result = (*(int (__stdcall **)(int, int ***))(*(_DWORD *)v7 + 420))(v7, &a2);
  if ( result >= 0 )
  {
    v15 = a2;
    if ( a2 )
    {
      v8 = (int *)a1[1];
      a3 = a2;
      v9 = sub_10016580(
             v8 + 49,
             v13,
             &a3,
             16777619
           * (HIBYTE(a2) ^ (16777619
                          * (BYTE2(a2) ^ (16777619 * (BYTE1(a2) ^ (16777619 * ((unsigned __int8)a2 ^ 0x811C9DC5))))))))[1];
      if ( !v9 )
        v9 = (int *)v8[50];
      if ( v9 == (int *)v8[50] )
      {
        v10 = (int *)operator new(0x10u);
        v13[2] = v10;
        v14 = 0;
        v11 = *v8;
        v10[1] = (int)&AddressLookupTableObject::`vftable';
        LOBYTE(v14) = 1;
        v10[2] = v11;
        v10[3] = (int)v15;
        *v10 = (int)&Direct3DIndexBuffer8::`vftable';
        v10[1] = (int)&Direct3DIndexBuffer8::`vftable';
        v12 = *(_DWORD *)(v11 + 4);
        a3 = v15;
        *(_DWORD *)sub_1001A560((_DWORD *)(v12 + 196), (unsigned __int8 *)&a3) = v10 + 1;
      }
      else
      {
        v10 = v9[3] != 0 ? (int *)(v9[3] - 4) : 0;
      }
      *v3 = v10;
    }
    return 0;
  }
  return result;
}
// 1004C214: using guessed type void *Direct3DIndexBuffer8::`vftable';
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C244: using guessed type void *Direct3DIndexBuffer8::`vftable';

//----- (1000E470) --------------------------------------------------------
int __stdcall sub_1000E470(int a1, int a2, int a3)
{
  unsigned int v3; // ebx
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  int *v9; // edi
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _DWORD *v12; // esi
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  int v16; // esi
  size_t v17; // esi
  void *v18; // eax
  int v19; // esi
  _BYTE *v20; // eax
  int v21; // ecx
  unsigned int v22; // eax
  int v23; // ecx
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  size_t v26; // esi
  int *v27; // eax
  _DWORD *v28; // eax
  int v29; // ecx
  int *v30; // eax
  _DWORD *v31; // eax
  int v32; // ecx
  int *v33; // eax
  _DWORD *v34; // eax
  int v35; // ecx
  void **v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ebx
  void **v40; // edx
  char *v41; // eax
  char *v42; // edx
  _BYTE *v43; // edx
  const void **v44; // eax
  int v45; // ebx
  size_t v46; // ecx
  char *v47; // eax
  void **v48; // ecx
  int v49; // ebx
  _BYTE *v50; // edx
  unsigned int v51; // ebx
  _BYTE *v52; // edx
  void (__thiscall ***v53)(_DWORD, int); // eax
  void *p_Src; // ecx
  void **v55; // edi
  size_t v56; // esi
  unsigned int v57; // eax
  void **v58; // eax
  void **v59; // edx
  void *v60; // esi
  int v61; // ebx
  void **i; // ecx
  int v63; // ecx
  unsigned int v64; // edi
  void *v65; // ecx
  size_t v66; // esi
  int v67; // eax
  size_t v68; // eax
  size_t v69; // esi
  char *v70; // eax
  _BYTE *v71; // edx
  int v72; // ecx
  int v73; // esi
  void (__thiscall ***v74)(_DWORD, int); // ecx
  _DWORD *v75; // eax
  void (__thiscall ***v76)(_DWORD, int); // eax
  int v77; // ecx
  int v78; // esi
  void (__thiscall ***v79)(_DWORD, int); // ecx
  _DWORD *v80; // eax
  void (__thiscall ***v81)(_DWORD, int); // eax
  char *v82; // eax
  void **v83; // ecx
  int v84; // ecx
  int v85; // ebx
  void **v86; // edx
  char *v87; // eax
  char *v88; // edx
  _BYTE *v89; // edx
  void *v90; // edx
  int v91; // ecx
  void (__thiscall ***v92)(_DWORD, int); // eax
  unsigned int v93; // esi
  int *v94; // eax
  _DWORD *v95; // eax
  void *v96; // edx
  _BYTE *v97; // edx
  _BYTE *v98; // edx
  int *v99; // eax
  unsigned int v100; // ebx
  int v101; // ecx
  int *v102; // eax
  int v103; // ecx
  int *v104; // eax
  char v105; // al
  unsigned int v106; // esi
  const void **v107; // eax
  void **v108; // eax
  void **v109; // eax
  size_t v110; // edi
  unsigned int v111; // eax
  const void **v112; // eax
  _BYTE *v113; // esi
  size_t v114; // ecx
  int v115; // ebx
  const void **v116; // eax
  void *v117; // edx
  unsigned int v118; // esi
  unsigned int v119; // ecx
  char *v120; // eax
  void **v121; // ecx
  int v122; // ecx
  char *v123; // esi
  size_t v124; // ebx
  unsigned int v125; // ebx
  const void **v126; // eax
  unsigned int v127; // edi
  void *v128; // esi
  size_t v129; // edx
  int v130; // ecx
  char *v131; // eax
  void **v132; // ecx
  _BYTE *v133; // eax
  _BYTE *v134; // edx
  void *v135; // edx
  _BYTE *v136; // edx
  const void **v137; // eax
  char *v138; // esi
  int *v139; // eax
  void **v140; // eax
  unsigned int v141; // edi
  void **v142; // ecx
  void **v143; // edx
  unsigned int v144; // esi
  char *v145; // edi
  _BYTE *v146; // edx
  unsigned int v148; // edi
  size_t v149; // ecx
  void **v150; // eax
  _BYTE *v151; // edx
  void **p_Buf; // edi
  size_t v153; // esi
  _BYTE *v154; // edx
  _BYTE *v156; // edx
  unsigned int v157; // edx
  int v158; // ecx
  void **v159; // ecx
  char v160; // al
  int v161; // esi
  void (__thiscall ***v162)(_DWORD, int); // ecx
  _DWORD *v163; // eax
  void (__thiscall ***v164)(_DWORD, int); // eax
  size_t v165; // esi
  void **v166; // ecx
  int v167; // ecx
  int *v168; // eax
  void **v169; // eax
  void **v170; // eax
  void **v171; // eax
  _DWORD *v172; // eax
  unsigned int v173; // eax
  size_t v174; // esi
  int *v175; // eax
  char v176; // al
  char v177; // bl
  unsigned int v178; // edi
  const void **v179; // eax
  int v180; // ecx
  int *v181; // eax
  void **v182; // eax
  void **v183; // eax
  void **v184; // eax
  int *v185; // eax
  int *v186; // esi
  int *v187; // eax
  char v188; // bl
  int v189; // ebx
  const void **v190; // eax
  int v191; // ebx
  const void **v192; // eax
  const void **v193; // eax
  int v194; // ebx
  const void **v195; // eax
  const void **v196; // eax
  const void **v197; // eax
  int v198; // ecx
  int *v199; // eax
  void **v200; // eax
  void **v201; // eax
  void **v202; // eax
  void **v203; // eax
  int v204; // ecx
  int *v205; // eax
  void **v206; // eax
  int v207; // ebx
  size_t v208; // ebx
  char *v209; // esi
  unsigned int v210; // ebx
  unsigned int v211; // edi
  char *v212; // eax
  void **v213; // ecx
  int v214; // edi
  _DWORD *v215; // eax
  int v216; // eax
  int v217; // eax
  void **v218; // eax
  char *v219; // esi
  int *v220; // eax
  void **v221; // eax
  _DWORD *v222; // eax
  int v223; // ecx
  void **v224; // ecx
  char v225; // al
  char v226; // bl
  void (__thiscall ***v227)(_DWORD, int); // eax
  int v228; // ecx
  int v229; // esi
  void (__thiscall ***v230)(_DWORD, int); // ecx
  _DWORD *v231; // eax
  void (__thiscall ***v232)(_DWORD, int); // eax
  int v233; // ebx
  _DWORD *v234; // eax
  void *v235; // edx
  void *v236; // eax
  char *v237; // eax
  unsigned int v238; // edi
  char *v239; // esi
  void **v240; // ecx
  int v241; // ecx
  int v242; // ebx
  char *v243; // eax
  int *v244; // eax
  _DWORD *v245; // eax
  unsigned int v246; // eax
  int v247; // ecx
  int *v248; // edi
  char *v249; // esi
  int *v250; // eax
  int *v251; // eax
  int *v252; // eax
  char v253; // bl
  _DWORD *v254; // eax
  int v255; // ebx
  _DWORD *v256; // eax
  int v257; // eax
  void **v258; // eax
  char *v259; // esi
  int *v260; // eax
  void **v261; // eax
  char *v262; // edi
  int *v263; // eax
  int *v264; // esi
  int v265; // ebx
  char *v266; // eax
  unsigned int v267; // eax
  _DWORD *v268; // eax
  _DWORD *v269; // eax
  int v270; // ecx
  int v271; // ebx
  void **v272; // ecx
  char *v273; // edx
  _BYTE *v274; // edx
  size_t v275; // ecx
  char *v276; // eax
  void **v277; // eax
  int v278; // ebx
  _BYTE *v279; // esi
  void *v280; // edi
  _BYTE *v281; // edx
  _BYTE *v282; // edx
  int v283; // esi
  void (__thiscall ***v284)(_DWORD, int); // ecx
  _DWORD *v285; // eax
  void (__thiscall ***v286)(_DWORD, int); // eax
  void **v287; // ecx
  size_t v288; // esi
  size_t v289; // edi
  char *v290; // eax
  void *v291; // eax
  void *v292; // eax
  _BYTE *v293; // eax
  _BYTE *v294; // eax
  _BYTE *v295; // eax
  _BYTE *v296; // eax
  void *v297; // edx
  _BYTE *v298; // eax
  _BYTE *v299; // eax
  _BYTE *v300; // eax
  _BYTE *v301; // esi
  const char *v302; // eax
  _BYTE *v303; // eax
  void *v304; // edx
  _BYTE *v305; // edx
  char *v306; // ebx
  int v307; // edi
  _DWORD *v308; // esi
  char *v309; // eax
  int v310; // ecx
  _DWORD *v311; // eax
  _BYTE *v312; // edx
  void (__thiscall ***v313)(_DWORD, int); // eax
  int v314; // ecx
  void **v315; // edx
  char *v316; // eax
  char *v317; // edx
  _BYTE *v318; // edx
  _BYTE *v319; // edx
  void (__thiscall ***v320)(_DWORD, int); // eax
  int v321; // ecx
  _DWORD *v322; // eax
  _BYTE *v323; // edx
  int v324; // esi
  void (__thiscall ***v325)(_DWORD, int); // ecx
  _DWORD *v326; // eax
  void (__thiscall ***v327)(_DWORD, int); // eax
  _BYTE *v328; // eax
  _BYTE *v329; // eax
  _BYTE *v330; // eax
  void **v331; // edx
  _BYTE *v332; // eax
  void **v333; // eax
  int v334; // edi
  int v335; // edi
  int (__stdcall *v336)(int, int, int); // esi
  int v337; // eax
  const char *v338; // edx
  _BYTE *v339; // eax
  _BYTE *v340; // eax
  _BYTE *v341; // esi
  const char *v342; // eax
  _BYTE *v343; // eax
  _BYTE *v344; // eax
  _BYTE *v345; // eax
  _BYTE *v346; // eax
  void *v347; // edx
  void *v348; // edx
  char *v350; // eax
  char *v351; // eax
  char *v352; // eax
  char *v353; // eax
  _BYTE *v354; // eax
  char *v355; // eax
  char *v356; // eax
  char *v357; // eax
  char *v358; // eax
  char *v359; // eax
  char *v360; // eax
  _BYTE *v361; // eax
  int v362; // [esp-4h] [ebp-20Ch]
  int v363; // [esp-4h] [ebp-20Ch]
  int v364; // [esp-4h] [ebp-20Ch]
  int v365; // [esp-4h] [ebp-20Ch]
  int v366; // [esp-4h] [ebp-20Ch]
  int v367; // [esp-4h] [ebp-20Ch]
  int v368; // [esp+Ch] [ebp-1FCh] BYREF
  int v369; // [esp+10h] [ebp-1F8h] BYREF
  void **v370; // [esp+14h] [ebp-1F4h] BYREF
  _DWORD v371[6]; // [esp+18h] [ebp-1F0h] BYREF
  void *v372[6]; // [esp+30h] [ebp-1D8h] BYREF
  void *v373[6]; // [esp+48h] [ebp-1C0h] BYREF
  void *v374[6]; // [esp+60h] [ebp-1A8h] BYREF
  void *v375[4]; // [esp+78h] [ebp-190h] BYREF
  int v376; // [esp+88h] [ebp-180h]
  unsigned int v377; // [esp+8Ch] [ebp-17Ch]
  int v378; // [esp+90h] [ebp-178h] BYREF
  int v379; // [esp+94h] [ebp-174h]
  __int16 v380; // [esp+98h] [ebp-170h]
  char v381; // [esp+9Ah] [ebp-16Eh]
  int v382; // [esp+9Ch] [ebp-16Ch] BYREF
  int v383; // [esp+A0h] [ebp-168h]
  int v384; // [esp+A4h] [ebp-164h] BYREF
  unsigned int v385; // [esp+A8h] [ebp-160h]
  void *v386[5]; // [esp+ACh] [ebp-15Ch] BYREF
  unsigned int v387; // [esp+C0h] [ebp-148h]
  void *v388; // [esp+C4h] [ebp-144h] BYREF
  const void *v389[3]; // [esp+C8h] [ebp-140h] BYREF
  int v390; // [esp+D4h] [ebp-134h]
  unsigned int v391; // [esp+D8h] [ebp-130h]
  unsigned int v392; // [esp+E0h] [ebp-128h]
  int v393; // [esp+E4h] [ebp-124h] BYREF
  int v394; // [esp+E8h] [ebp-120h]
  void *v395[4]; // [esp+ECh] [ebp-11Ch] BYREF
  int v396; // [esp+FCh] [ebp-10Ch]
  unsigned int v397; // [esp+100h] [ebp-108h]
  void *v398[4]; // [esp+104h] [ebp-104h] BYREF
  unsigned int v399; // [esp+114h] [ebp-F4h]
  unsigned int v400; // [esp+118h] [ebp-F0h]
  void *v401; // [esp+11Ch] [ebp-ECh] BYREF
  int v402; // [esp+120h] [ebp-E8h] BYREF
  int v403; // [esp+124h] [ebp-E4h]
  int v404; // [esp+128h] [ebp-E0h]
  int v405; // [esp+12Ch] [ebp-DCh]
  unsigned int v406; // [esp+130h] [ebp-D8h]
  void *Block; // [esp+134h] [ebp-D4h] BYREF
  int v408; // [esp+138h] [ebp-D0h] BYREF
  struct std::_Facet_base *v409; // [esp+13Ch] [ebp-CCh] BYREF
  void *v410; // [esp+140h] [ebp-C8h] BYREF
  int v411; // [esp+144h] [ebp-C4h]
  unsigned int v412; // [esp+148h] [ebp-C0h]
  _BYTE *Buf; // [esp+14Ch] [ebp-BCh] BYREF
  void *v414; // [esp+150h] [ebp-B8h]
  unsigned int v415; // [esp+154h] [ebp-B4h]
  int v416; // [esp+158h] [ebp-B0h]
  size_t Size; // [esp+15Ch] [ebp-ACh]
  unsigned int v418; // [esp+160h] [ebp-A8h]
  void *v419[4]; // [esp+164h] [ebp-A4h] BYREF
  unsigned int v420; // [esp+174h] [ebp-94h]
  unsigned int v421; // [esp+178h] [ebp-90h]
  void *v422; // [esp+17Ch] [ebp-8Ch]
  char v423; // [esp+183h] [ebp-85h]
  void *v424; // [esp+184h] [ebp-84h] BYREF
  const void *v425; // [esp+188h] [ebp-80h]
  const void *v426; // [esp+18Ch] [ebp-7Ch]
  int v427; // [esp+190h] [ebp-78h]
  size_t v428; // [esp+194h] [ebp-74h]
  unsigned int v429; // [esp+198h] [ebp-70h]
  void *Src; // [esp+19Ch] [ebp-6Ch] BYREF
  void *v431; // [esp+1A0h] [ebp-68h]
  void *v432; // [esp+1A4h] [ebp-64h]
  void *v433; // [esp+1A8h] [ebp-60h]
  size_t v434; // [esp+1ACh] [ebp-5Ch]
  unsigned int v435; // [esp+1B0h] [ebp-58h]
  void *v436; // [esp+1B4h] [ebp-54h] BYREF
  int v437; // [esp+1B8h] [ebp-50h] BYREF
  struct std::_Facet_base *v438[3]; // [esp+1BCh] [ebp-4Ch] BYREF
  unsigned int v439; // [esp+1C8h] [ebp-40h]
  unsigned int v440; // [esp+1CCh] [ebp-3Ch]
  void *v441; // [esp+1D0h] [ebp-38h] BYREF
  void *v442; // [esp+1D4h] [ebp-34h] BYREF
  void *v443; // [esp+1D8h] [ebp-30h]
  void *v444; // [esp+1DCh] [ebp-2Ch]
  size_t MaxCount; // [esp+1E0h] [ebp-28h]
  int v446; // [esp+1E4h] [ebp-24h] BYREF
  size_t v447; // [esp+1E8h] [ebp-20h]
  unsigned int v448; // [esp+1ECh] [ebp-1Ch]
  int v449; // [esp+1F0h] [ebp-18h] BYREF
  unsigned int v450; // [esp+1F4h] [ebp-14h]
  char v451; // [esp+1FAh] [ebp-Eh]
  bool v452; // [esp+1FBh] [ebp-Dh]
  int v453; // [esp+204h] [ebp-4h]
  int savedregs; // [esp+208h] [ebp+0h] BYREF

  v3 = 0;
  v448 = 0;
  v4 = sub_10006250(&dword_10053148, "Redirecting '");
  v5 = sub_10006250(v4, "IDirect3DDevice8::CreatePixelShader");
  v6 = sub_10006250(v5, "(");
  v7 = sub_10007C40(v6, (int)&savedregs, a1);
  v8 = sub_10006250(v7, ", ");
  v9 = (int *)a2;
  v10 = sub_10007C40(v8, (int)&savedregs, a2);
  v11 = sub_10006250(v10, ", ");
  v12 = (_DWORD *)a3;
  v13 = sub_10007C40(v11, (int)&savedregs, a3);
  v14 = sub_10006250(v13, ")' ...");
  sub_100064E0(v14);
  if ( !v9 || !v12 )
    return -2005530516;
  *v12 = 0;
  v15 = sub_10006250(
          &dword_10053148,
          "> Disassembling shader and translating assembly to Direct3D 9 compatible code ...");
  sub_100064E0(v15);
  if ( (unsigned int)(*v9 + 65280) > 4 )
  {
    v355 = sub_10006250(&dword_10053148, "> Failed because of version mismatch ('");
    v356 = sub_10011E50(v355, (void (__cdecl *)(char *))sub_10008450);
    v357 = sub_10011E50(v356, (void (__cdecl *)(char *))sub_10008420);
    v358 = sub_100042E0(v357, (int)&savedregs, *v9);
    v359 = sub_10011E50(v358, (void (__cdecl *)(char *))sub_10008400);
    v360 = sub_10011E50(v359, (void (__cdecl *)(char *))sub_10008440);
    v361 = sub_10006250(v360, "')! Only 'ps_1_x' shaders are supported.");
    sub_100064E0(v361);
    return -2005530516;
  }
  v16 = -2005530516;
  v393 = 0;
  v384 = 0;
  v394 = 0;
  if ( !dword_10053120 || (v16 = dword_10053120(v9, 0, 0, &v393), v16 < 0) )
  {
    v350 = sub_10006250(&dword_10053148, "> Failed to disassemble shader with error code ");
    v351 = sub_10011E50(v350, (void (__cdecl *)(char *))sub_10008420);
    v352 = sub_10011CA0(v351, v16);
    v353 = sub_10011E50(v352, (void (__cdecl *)(char *))sub_10008400);
    v354 = sub_10006250(v353, "!");
    sub_100064E0(v354);
    return v16;
  }
  v17 = (*(int (__stdcall **)(int))(*(_DWORD *)v393 + 16))(v393) - 1;
  v18 = (void *)(*(int (__stdcall **)(int))(*(_DWORD *)v393 + 12))(v393);
  sub_10001A90(v419, v18, v17);
  v453 = 0;
  v19 = sub_10011EF0(v419, "ps_1_", 0);
  if ( *sub_10011F60(v419, v19 + 5) == 48 )
  {
    v20 = sub_10006250(&dword_10053148, "> Replacing version 'ps_1_0' with 'ps_1_1' ...");
    sub_100064E0(v20);
    sub_10011F80((const void **)v419, v19, v21, "ps_1_1");
  }
  v22 = sub_10011EF0(v419, "arithmetic", 0);
  if ( v22 <= 2 || v22 >= v420 )
  {
    v26 = 0;
    v422 = 0;
  }
  else
  {
    v24 = sub_10011E70(v419, v386, v22 - 2, 2u);
    v3 = 1;
    v25 = sub_10001940(v24);
    v422 = (void *)sub_10027E6A((int)v25, 0, 10);
    v26 = (size_t)v422;
  }
  if ( (v3 & 1) != 0 )
  {
    v3 &= ~1u;
    sub_100019D0(v386);
  }
  if ( !v26 )
  {
    v26 = 10;
    v422 = (void *)10;
  }
  v447 = v26;
  v27 = (int *)sub_10011C30((int)&v437, "    \\/\\/ ps\\.1\\.[1-4]\\n((?! ).+\\n)+", v23);
  LOBYTE(v453) = 1;
  v28 = (_DWORD *)sub_10012920((int)v386, (char *)v419, v27, &unk_1004A353, 0);
  sub_10005F60(v419, v28);
  sub_100019D0(v386);
  LOBYTE(v453) = 0;
  sub_10011BD0(&v437);
  v30 = (int *)sub_10011C30((int)&v437, "([^\\n]\\n)[\\s]*#line [0123456789]+.*\\n", v29);
  LOBYTE(v453) = 2;
  v31 = (_DWORD *)sub_10012920((int)v386, (char *)v419, v30, "$1", 0);
  sub_10005F60(v419, v31);
  sub_100019D0(v386);
  LOBYTE(v453) = 0;
  sub_10011BD0(&v437);
  v33 = (int *)sub_10011C30(
                 (int)&v437,
                 "(add)([_satxd248]*) (r[0-9][\\.wxyz]*), ((1-|)[crtv][0-9][\\.wxyz_abdis2]*), (-)(c[0-9][\\.wxyz]*)(_bx2"
                 "|_bias|_x2|_d[zbwa]|)(?![_\\.wxyz])",
                 v32);
  LOBYTE(v453) = 3;
  v34 = (_DWORD *)sub_10012920(
                    (int)v386,
                    (char *)v419,
                    v33,
                    "sub$2 $3, $4, $7$8 /* changed 'add' to 'sub' removed modifier $6 */",
                    0);
  sub_10005F60(v419, v34);
  sub_100019D0(v386);
  LOBYTE(v453) = 0;
  sub_10011BD0(&v437);
  sub_10001AF0(v395, v419);
  LOBYTE(v453) = 4;
  v383 = v26;
  while ( 1 )
  {
    v437 = 0;
    sub_10012060(v438);
    LOBYTE(v453) = 5;
    sub_10012B50(&v437, (int)"-c[0-9]|c[0-9][\\.wxyz]*_", (int)"", v35);
    LOBYTE(v453) = 6;
    v36 = v419;
    v3 |= 2u;
    v448 = v3;
    if ( v421 >= 0x10 )
      v36 = (void **)v419[0];
    if ( !sub_10013A70((int)v36, (char *)v36 + v420, 0, &v437, 0x10u, (int)v36) || (HIBYTE(a2) = 1, v26 >= 8) )
      HIBYTE(a2) = 0;
    v453 = 4;
    if ( (v3 & 2) != 0 )
    {
      v3 &= ~2u;
      sub_10011BD0(&v437);
    }
    if ( !HIBYTE(a2) )
      break;
    v437 = 0;
    sub_10012060(v438);
    LOBYTE(v453) = 7;
    sub_10012B50(&v437, (int)"1?-(c[0-9])[\\._a-z0-9]*|(c[0-9])[\\.wxyz]*_[a-z0-9]*", (int)"", v38);
    v406 = 15;
    v39 = v3 | 0x4000000;
    v401 = 0;
    v402 = 0;
    v403 = 0;
    v404 = 0;
    v405 = 0;
    v448 = v39;
    v409 = 0;
    v410 = 0;
    Block = (void *)607200301;
    v411 = 5;
    v412 = 15;
    v408 = 50;
    LOBYTE(v453) = 11;
    v40 = v419;
    HIBYTE(a2) = v421 >= 0x10;
    if ( v421 >= 0x10 )
      v40 = (void **)v419[0];
    v41 = (char *)v40 + v420;
    v42 = (char *)v419;
    if ( HIBYTE(a2) )
      v42 = (char *)v419[0];
    sub_10014950((void ***)&v382, v42, &v401, v41, &v437, (char *)&Block, 0);
    LOBYTE(v453) = 9;
    if ( v412 >= 0x10 )
    {
      v43 = Block;
      if ( v412 + 1 >= 0x1000 )
      {
        v43 = (_BYTE *)*((_DWORD *)Block - 1);
        if ( (unsigned int)((_BYTE *)Block - v43 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v43);
    }
    v44 = sub_10012380((const void **)&v401, 0, "\n", 1u);
    v45 = v39 | 0x8000000;
    v448 = v45;
    v441 = 0;
    v442 = 0;
    v443 = 0;
    v444 = 0;
    MaxCount = 0;
    v446 = 0;
    v441 = (void *)*v44;
    v442 = (void *)v44[1];
    v443 = (void *)v44[2];
    v444 = (void *)v44[3];
    MaxCount = (size_t)v44[4];
    v446 = (int)v44[5];
    v44[4] = 0;
    v44[5] = (const void *)15;
    *(_BYTE *)v44 = 0;
    LOBYTE(v453) = 12;
    v46 = MaxCount;
    if ( v446 == MaxCount )
    {
      LOBYTE(v449) = 0;
      v48 = sub_10001D90(&v441, 1u, v449, "\n", 1u);
    }
    else
    {
      ++MaxCount;
      v47 = (char *)&v441;
      if ( (unsigned int)v446 >= 0x10 )
        v47 = (char *)v441;
      *(_WORD *)&v47[v46] = 10;
      v48 = &v441;
    }
    v49 = v45 | 0x10000000;
    Src = 0;
    v431 = 0;
    v432 = 0;
    v433 = 0;
    v434 = 0;
    v435 = 0;
    Src = *v48;
    v431 = v48[1];
    v432 = v48[2];
    v433 = v48[3];
    v434 = (size_t)v48[4];
    v435 = (unsigned int)v48[5];
    v48[4] = 0;
    v48[5] = (void *)15;
    *(_BYTE *)v48 = 0;
    LOBYTE(v453) = 14;
    if ( (unsigned int)v446 >= 0x10 )
    {
      v50 = v441;
      if ( (unsigned int)(v446 + 1) >= 0x1000 )
      {
        v50 = (_BYTE *)*((_DWORD *)v441 - 1);
        if ( (unsigned int)((_BYTE *)v441 - v50 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v50);
    }
    MaxCount = 0;
    v51 = v49 & 0xFBFFFFFF;
    v446 = 15;
    LOBYTE(v441) = 0;
    LOBYTE(v453) = 15;
    if ( v406 >= 0x10 )
    {
      v52 = v401;
      if ( v406 + 1 >= 0x1000 )
      {
        v52 = (_BYTE *)*((_DWORD *)v401 - 1);
        if ( (unsigned int)((_BYTE *)v401 - v52 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v52);
    }
    v405 = 0;
    v406 = 15;
    LOBYTE(v401) = 0;
    sub_100121B0(&v437);
    if ( v439 )
    {
      v53 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
      if ( v53 )
        (**v53)(v53, 1);
    }
    p_Src = &Src;
    v55 = (void **)Src;
    HIBYTE(a2) = v435 >= 0x10;
    if ( v435 >= 0x10 )
      p_Src = Src;
    v56 = v434;
    v57 = sub_10012CA0((int)p_Src, v434, 0, "-c", 2u);
    memset(v375, 0, sizeof(v375));
    v376 = 0;
    v377 = 0;
    LOBYTE(v453) = 17;
    if ( v56 >= v57 )
      v56 = v57;
    v58 = &Src;
    if ( HIBYTE(a2) )
      v58 = v55;
    sub_10001C50(v375, v58, v56);
    LOBYTE(v453) = 16;
    v59 = v375;
    v60 = v375[0];
    v61 = v51 | 0x1000000;
    HIBYTE(a2) = v377 >= 0x10;
    if ( v377 >= 0x10 )
      v59 = (void **)v375[0];
    if ( v376 )
    {
      for ( i = (void **)((char *)v59 + v376 - 1); *(_BYTE *)i != 10; i = (void **)((char *)i - 1) )
      {
        if ( i == v59 )
          goto LABEL_63;
      }
      v63 = (char *)i - (char *)v59;
    }
    else
    {
LABEL_63:
      v63 = -1;
    }
    v64 = v63 + 1;
    if ( HIBYTE(a2) )
    {
      if ( v377 + 1 >= 0x1000 )
      {
        v60 = (void *)*((_DWORD *)v375[0] - 1);
        if ( (unsigned int)(v375[0] - v60 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v60);
    }
    v65 = &Src;
    v376 = 0;
    v377 = 15;
    HIBYTE(a2) = v435 >= 0x10;
    LOBYTE(v375[0]) = 0;
    if ( v435 >= 0x10 )
      v65 = Src;
    v66 = v434;
    v67 = sub_10012CA0((int)v65, v434, v64, "\n", 1u);
    Block = 0;
    v408 = 0;
    v409 = 0;
    v410 = 0;
    v411 = 0;
    v412 = 0;
    LOBYTE(v453) = 18;
    if ( v66 < v64 )
LABEL_460:
      sub_10006120();
    v68 = v67 - v64;
    v69 = v66 - v64;
    if ( v69 >= v68 )
      v69 = v68;
    v70 = (char *)&Src;
    if ( HIBYTE(a2) )
      v70 = (char *)Src;
    sub_10001C50(&Block, &v70[v64], v69);
    LOBYTE(v453) = 16;
    v3 = v61 | 0x2000000;
    sub_10005F60(&Src, &Block);
    if ( v412 >= 0x10 )
    {
      v71 = Block;
      if ( v412 + 1 >= 0x1000 )
      {
        v71 = (_BYTE *)*((_DWORD *)Block - 1);
        if ( (unsigned int)((_BYTE *)Block - v71 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v71);
    }
    v408 = 0;
    sub_10012060(&v409);
    LOBYTE(v453) = 19;
    sub_10012B50(&v408, (int)"[ \\+]+[a-z_\\.0-9]+ (r[0-9]).*-c[0-9].*", (int)"", v72);
    LOBYTE(v453) = 20;
    sub_10012920((int)&v424, (char *)&Src, &v408, "$1", 0);
    LOBYTE(v453) = 22;
    if ( v408 )
    {
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v408 + 32), 0xFFFFFFFF) )
      {
        v73 = v408;
        while ( v73 )
        {
          v74 = (void (__thiscall ***)(_DWORD, int))v73;
          v75 = (_DWORD *)(v73 + 12);
          v73 = *(_DWORD *)(v73 + 12);
          *v75 = 0;
          (**v74)(v74, 1);
        }
      }
    }
    v408 = 0;
    if ( v412 )
    {
      v76 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v412 + 8))(v412);
      if ( v76 )
        (**v76)(v76, 1);
    }
    v437 = 0;
    sub_10012060(v438);
    LOBYTE(v453) = 23;
    sub_10012B50(&v437, (int)"[ \\+]+[a-z_\\.0-9]+ r[0-9][\\._a-z0-9]*, (.*)-c[0-9](.*)", (int)"", v77);
    LOBYTE(v453) = 24;
    sub_10012920((int)v398, (char *)&Src, &v437, "$1$2", 0);
    LOBYTE(v453) = 26;
    if ( v437 )
    {
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v437 + 32), 0xFFFFFFFF) )
      {
        v78 = v437;
        while ( v78 )
        {
          v79 = (void (__thiscall ***)(_DWORD, int))v78;
          v80 = (_DWORD *)(v78 + 12);
          v78 = *(_DWORD *)(v78 + 12);
          *v80 = 0;
          (**v79)(v79, 1);
        }
      }
    }
    v437 = 0;
    if ( v439 )
    {
      v81 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
      if ( v81 )
        (**v81)(v81, 1);
    }
    v82 = (char *)&v424;
    if ( v429 >= 0x10 )
      v82 = (char *)v424;
    v83 = v398;
    if ( v400 >= 0x10 )
      v83 = (void **)v398[0];
    if ( sub_10012CA0((int)v83, v399, 0, v82, v428) != -1 )
      goto LABEL_127;
    v392 = v420;
    v408 = 0;
    sub_10012060(&v409);
    LOBYTE(v453) = 27;
    sub_10012B50(
      &v408,
      (int)"    (...)(_[_satxd248]*|) (r[0-9])([\\.wxyz]*), (1?-?[crtv][0-9][\\.wxyz_abdis2]*, )?(1?-?[crtv][0-9][\\.wxyz"
           "_abdis2]*, )?(1?-?[crtv][0-9][\\.wxyz_abdis2]*, )?((1?-)(c[0-9])([\\.wxyz]*)(_bx2|_bias|_x2|_d[zbwa]|)|(1?-?)"
           "(c[0-9])([\\.wxyz]*)(_bx2|_bias|_x2|_d[zbwa]))(?![_\\.wxyz])",
      (int)"",
      v84);
    v446 = 15;
    v85 = v3 | 0x20000000;
    v441 = 0;
    v442 = 0;
    v443 = 0;
    v444 = 0;
    MaxCount = 0;
    v448 = v85;
    v401 = 0;
    v402 = 0;
    v403 = 0;
    v404 = 0;
    v405 = 0;
    LOBYTE(v453) = 30;
    v406 = 15;
    v401 = operator new(0x70u);
    v405 = 109;
    v406 = 111;
    strcpy(
      (char *)v401,
      "    mov $3$4, $10$11$14$15 /* added line */\n    $1$2 $3$4, $5$6$9$13$3$12$16 /* changed $10$11$14$15 to $3 */");
    LOBYTE(v453) = 31;
    v86 = v419;
    HIBYTE(a2) = v421 >= 0x10;
    if ( v421 >= 0x10 )
      v86 = (void **)v419[0];
    v87 = (char *)v86 + v420;
    v88 = (char *)v419;
    if ( HIBYTE(a2) )
      v88 = (char *)v419[0];
    sub_10014950((void ***)&v378, v88, &v441, v87, &v408, (char *)&v401, 4096);
    LOBYTE(v453) = 29;
    if ( v406 >= 0x10 )
    {
      v89 = v401;
      if ( v406 + 1 >= 0x1000 )
      {
        v89 = (_BYTE *)*((_DWORD *)v401 - 1);
        if ( (unsigned int)((_BYTE *)v401 - v89 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v89);
    }
    if ( v421 >= 0x10 )
    {
      v90 = v419[0];
      if ( v421 + 1 >= 0x1000 )
      {
        v90 = (void *)*((_DWORD *)v419[0] - 1);
        if ( (unsigned int)(v419[0] - v90 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v90);
    }
    v419[0] = v441;
    v3 = v85 & 0xDFFFFFFF;
    v419[1] = v442;
    v419[2] = v443;
    v419[3] = v444;
    v420 = MaxCount;
    v421 = v446;
    MaxCount = 0;
    v446 = 15;
    LOBYTE(v441) = 0;
    LOBYTE(v453) = 26;
    sub_100121B0(&v408);
    v91 = v412;
    if ( v412 )
    {
      v92 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v412 + 8))(v412);
      if ( v92 )
        (**v92)(v92, 1);
    }
    v93 = v392;
    if ( v392 == v420 )
    {
      v94 = (int *)sub_10011C30(
                     (int)&v408,
                     "(    .*\\n)  \\+ (...)(_[_satxd248]*|) (r[0-9])([\\.wxyz]*), (1?-?[crtv][0-9][\\.wxyz_abdis2]*, )?("
                     "1?-?[crtv][0-9][\\.wxyz_abdis2]*, )?(1?-?[crtv][0-9][\\.wxyz_abdis2]*, )?((1?-)(c[0-9])([\\.wxyz]*)"
                     "(_bx2|_bias|_x2|_d[zbwa]|)|(1?-?)(c[0-9])([\\.wxyz]*)(_bx2|_bias|_x2|_d[zbwa]))(?![_\\.wxyz])",
                     v91);
      LOBYTE(v453) = 32;
      v95 = (_DWORD *)sub_10012920(
                        (int)v386,
                        (char *)v419,
                        v94,
                        "    mov $4$5, $11$12$15$16 /* added line */\n"
                        "$1  + $2$3 $4$5, $6$7$10$14$4$13$17 /* changed $11$12$15$16 to $4 */",
                        4096);
      sub_10005F60(v419, v95);
      sub_100019D0(v386);
      sub_10011BD0(&v408);
      if ( v93 == v420 )
      {
LABEL_127:
        sub_100019D0(v398);
        sub_100019D0(&v424);
        LOBYTE(v453) = 4;
        sub_100019D0(&Src);
        break;
      }
    }
    v26 = (size_t)v422 + 1;
    LOBYTE(v453) = 22;
    v422 = (char *)v422 + 1;
    if ( v400 >= 0x10 )
    {
      v96 = v398[0];
      if ( v400 + 1 >= 0x1000 )
      {
        v96 = (void *)*((_DWORD *)v398[0] - 1);
        if ( (unsigned int)(v398[0] - v96 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v96);
    }
    LOBYTE(v453) = 16;
    v399 = 0;
    v400 = 15;
    LOBYTE(v398[0]) = 0;
    if ( v429 >= 0x10 )
    {
      v97 = v424;
      if ( v429 + 1 >= 0x1000 )
      {
        v97 = (_BYTE *)*((_DWORD *)v424 - 1);
        if ( (unsigned int)((_BYTE *)v424 - v97 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v97);
    }
    LOBYTE(v453) = 4;
    v428 = 0;
    v429 = 15;
    LOBYTE(v424) = 0;
    if ( v435 >= 0x10 )
    {
      v98 = Src;
      if ( v435 + 1 >= 0x1000 )
      {
        v98 = (_BYTE *)*((_DWORD *)Src - 1);
        if ( (unsigned int)((_BYTE *)Src - v98 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v98);
    }
  }
  v99 = (int *)sub_10011C30((int)&v402, "-c[0-9]|c[0-9][\\.wxyz]*_", v37);
  LOBYTE(v453) = 33;
  v100 = v3 | 4;
  v450 = v100;
  v448 = v100;
  if ( !sub_10012A20((int *)v419, v99) )
    goto LABEL_131;
  v102 = (int *)sub_10011C30((int)&v408, "tex[bcdmr]", v101);
  v453 = 34;
  v100 |= 8u;
  v450 = v100;
  v448 = v100;
  if ( sub_10012A20((int *)v419, v102)
    || (v104 = (int *)sub_10011C30((int)&v437, "ps_1_[0-3]", v103),
        v453 = 35,
        v100 |= 0x10u,
        v450 = v100,
        v448 = v100,
        v105 = sub_10012A20((int *)v419, v104),
        HIBYTE(a2) = 1,
        !v105) )
  {
LABEL_131:
    HIBYTE(a2) = 0;
  }
  if ( (v100 & 0x10) != 0 )
  {
    v100 &= ~0x10u;
    v450 = v100;
    sub_10011BD0(&v437);
  }
  if ( (v100 & 8) != 0 )
  {
    v100 &= ~8u;
    v450 = v100;
    sub_10011BD0(&v408);
  }
  v453 = 4;
  if ( (v100 & 4) != 0 )
  {
    v100 &= ~4u;
    v450 = v100;
    sub_10011BD0(&v402);
  }
  if ( !HIBYTE(a2) )
    goto LABEL_402;
  v423 = 0;
  v379 = 0;
  v380 = 0;
  v381 = 1;
  v422 = 0;
  v410 = 0;
  v411 = 0;
  v412 = 0;
  LOBYTE(v453) = 36;
  sub_10001A20(&Src, "    ps_1_4 /* converted */\n");
  LOBYTE(v453) = 37;
  HIBYTE(a2) = v383 >= 8;
  if ( sub_10011EF0(v395, "def c", 0) == -1 && (int)v447 < 8 )
  {
    v106 = 0;
    while ( 1 )
    {
      v107 = (const void **)sub_100084E0(v386, v106);
      LOBYTE(v453) = 38;
      sub_10012620((const void **)&v424, "c", v107);
      LOBYTE(v453) = 40;
      sub_100019D0(v386);
      if ( sub_10011F30(v395, (int)&v424, 0) == -1 )
        break;
      LOBYTE(v453) = 37;
      sub_100019D0(&v424);
      if ( ++v106 >= 8 )
        goto LABEL_146;
    }
    HIBYTE(a2) = 1;
    v108 = (void **)sub_100125C0(&v441, "    def ", &v424);
    LOBYTE(v453) = 41;
    v109 = sub_100126F0(v398, v108, ", 0, 0, 0, 0 /* added line */\n");
    LOBYTE(v453) = 42;
    sub_10001950(&Src, v109);
    sub_100019D0(v398);
    sub_100019D0(&v441);
    LOBYTE(v453) = 37;
    sub_100019D0(&v424);
  }
LABEL_146:
  v110 = 0;
  v111 = 0;
  v447 = 0;
  v440 = 0;
  do
  {
    v112 = (const void **)sub_100084E0(v373, v111);
    LOBYTE(v453) = 43;
    sub_10012620((const void **)v386, "r", v112);
    LOBYTE(v453) = 45;
    sub_100019D0(v373);
    if ( sub_10011F30(v395, (int)v386, 0) == -1 )
      goto LABEL_190;
    while ( 1 )
    {
      v113 = (char *)&v446 + 1;
      v114 = v110;
      do
      {
        *--v113 = v114 % 0xA + 48;
        v114 /= 0xAu;
      }
      while ( v114 );
      sub_10013920(&v436, v113, (_BYTE *)&v446 + 1, 0);
      LOBYTE(v453) = 46;
      v115 = v450 | 0x30020;
      v448 = v450 | 0x30020;
      v116 = sub_10012380((const void **)&v436, 0, "t", 1u);
      v117 = (void *)*v116;
      v118 = (unsigned int)v116[4];
      v398[1] = (void *)v116[1];
      v398[2] = (void *)v116[2];
      v398[3] = (void *)v116[3];
      v119 = (unsigned int)v116[5];
      v398[0] = v117;
      v399 = v118;
      v449 = v119;
      v400 = v119;
      v116[4] = 0;
      v116[5] = (const void *)15;
      *(_BYTE *)v116 = 0;
      v100 = v115 | 0x40040;
      v453 = 47;
      v450 = v100;
      v448 = v100;
      v120 = (char *)v398;
      v452 = v119 >= 0x10;
      if ( v119 >= 0x10 )
        v120 = (char *)v117;
      v121 = v395;
      if ( v397 >= 0x10 )
        v121 = (void **)v395[0];
      if ( sub_10012CA0((int)v121, v396, 0, v120, v118) != -1 )
      {
        v127 = v429;
        v128 = v424;
LABEL_165:
        v451 = 1;
        goto LABEL_166;
      }
      v123 = (char *)&v446 + 1;
      v124 = v110;
      do
      {
        --v123;
        LOBYTE(v122) = 10 * (v124 / 0xA);
        *v123 = v124 % 0xA + 48;
        v124 /= 0xAu;
      }
      while ( v124 );
      v125 = v450;
      sub_10013920(&v401, v123, (_BYTE *)&v446 + 1, v122);
      v453 = 48;
      v125 |= 0x180080u;
      v448 = v125;
      v126 = sub_10012380((const void **)&v401, 0, "r", 1u);
      v100 = v125 | 0x200100;
      v450 = v100;
      v127 = (unsigned int)v126[5];
      v128 = (void *)*v126;
      v129 = (size_t)v126[4];
      v425 = v126[1];
      v426 = v126[2];
      v130 = (int)v126[3];
      v126[4] = 0;
      v126[5] = (const void *)15;
      *(_BYTE *)v126 = 0;
      v131 = (char *)&v424;
      v424 = v128;
      v427 = v130;
      v428 = v129;
      v429 = v127;
      if ( v127 >= 0x10 )
        v131 = (char *)v128;
      v132 = v395;
      if ( v397 >= 0x10 )
        v132 = (void **)v395[0];
      if ( sub_10012CA0((int)v132, v396, 0, v131, v129) != -1 && v440 != v447 )
        goto LABEL_165;
      v451 = 0;
LABEL_166:
      if ( (v100 & 0x100) != 0 )
      {
        v100 &= ~0x100u;
        v450 = v100;
        if ( v127 >= 0x10 )
        {
          v133 = v128;
          if ( v127 + 1 >= 0x1000 )
          {
            v128 = (void *)*((_DWORD *)v128 - 1);
            if ( (unsigned int)(v133 - (_BYTE *)v128 - 4) > 0x1F )
              goto LABEL_462;
          }
          sub_1001D481(v128);
        }
      }
      v453 = 47;
      if ( (v100 & 0x80u) != 0 )
      {
        v100 &= ~0x80u;
        v450 = v100;
        if ( v406 >= 0x10 )
        {
          v134 = v401;
          if ( v406 + 1 >= 0x1000 )
          {
            v134 = (_BYTE *)*((_DWORD *)v401 - 1);
            if ( (unsigned int)((_BYTE *)v401 - v134 - 4) > 0x1F )
              goto LABEL_462;
          }
          sub_1001D481(v134);
        }
        v405 = 0;
        v406 = 15;
        LOBYTE(v401) = 0;
      }
      v453 = 46;
      if ( (v100 & 0x40) != 0 )
      {
        v100 &= ~0x40u;
        v450 = v100;
        if ( v452 )
        {
          v135 = v398[0];
          if ( (unsigned int)(v449 + 1) >= 0x1000 )
          {
            v135 = (void *)*((_DWORD *)v398[0] - 1);
            if ( (unsigned int)(v398[0] - v135 - 4) > 0x1F )
              goto LABEL_462;
          }
          sub_1001D481(v135);
        }
      }
      v453 = 45;
      if ( (v100 & 0x20) != 0 )
      {
        v100 &= ~0x20u;
        v450 = v100;
        if ( v439 >= 0x10 )
        {
          v136 = v436;
          if ( v439 + 1 >= 0x1000 )
          {
            v136 = (_BYTE *)*((_DWORD *)v436 - 1);
            if ( (unsigned int)((_BYTE *)v436 - v136 - 4) > 0x1F )
              goto LABEL_462;
          }
          sub_1001D481(v136);
        }
      }
      v110 = v447 + 1;
      if ( !v451 )
        break;
      ++v447;
    }
    v137 = (const void **)sub_100084E0(&v441, v447);
    LOBYTE(v453) = 49;
    v138 = (char *)sub_10012620((const void **)v398, "r", v137);
    LOBYTE(v453) = 50;
    v139 = (int *)sub_10012A50((int)&v402, (int *)v386, v362);
    LOBYTE(v453) = 51;
    v140 = sub_10012AC0(&v424, (char *)v395, v139, v138, 0);
    sub_10005F60(v395, v140);
    sub_100019D0(&v424);
    sub_10011BD0(&v402);
    sub_100019D0(v398);
    sub_100019D0(&v441);
    v447 = v110;
LABEL_190:
    LOBYTE(v453) = 37;
    sub_100019D0(v386);
    v111 = v440 + 1;
    v440 = v111;
  }
  while ( v111 < 2 );
  v447 = v434;
  v141 = 1;
  v392 = 0;
  v440 = 1;
  sub_10001AF0(&Buf, v395);
  LOBYTE(v453) = 52;
  while ( 1 )
  {
    v142 = v395;
    v143 = (void **)v395[0];
    v449 = (int)v395;
    v452 = v397 >= 0x10;
    if ( v397 >= 0x10 )
    {
      v142 = (void **)v395[0];
      v449 = (int)v395[0];
    }
    v144 = v396;
    if ( !v396 || v141 > v396 - 1 )
      goto LABEL_205;
    v145 = (char *)v142 + v396 - 1;
    v146 = memchr((char *)v142 + v440, 10, v396 - v440);
    if ( !v146 )
    {
LABEL_204:
      v143 = (void **)v395[0];
LABEL_205:
      v148 = 0;
      v449 = 0;
      goto LABEL_206;
    }
    while ( *v146 == 10 ? 0 : *v146 < 0xAu ? -1 : 1 )
    {
      v146 = memchr(v146 + 1, 10, v145 - v146);
      if ( !v146 )
        goto LABEL_204;
    }
    v156 = &v146[-v449];
    v148 = (unsigned int)(v156 + 1);
    v449 = (int)(v156 + 1);
    if ( v156 == (_BYTE *)-2 )
      goto LABEL_377;
    v143 = (void **)v395[0];
LABEL_206:
    if ( v148 < v440 )
      goto LABEL_377;
    v440 = v148;
    v441 = 0;
    v442 = 0;
    v443 = 0;
    v444 = 0;
    MaxCount = 0;
    v446 = 0;
    LOBYTE(v453) = 53;
    if ( v144 < v148 )
      goto LABEL_460;
    v149 = v144 - v148;
    if ( v144 - v148 >= v144 )
      v149 = v144;
    v150 = v395;
    if ( v452 )
      v150 = v143;
    sub_10001C50(&v441, (char *)v150 + v148, v149);
    LOBYTE(v453) = 52;
    v100 |= 0x40000000u;
    v450 = v100;
    if ( v418 >= 0x10 )
    {
      v151 = Buf;
      if ( v418 + 1 >= 0x1000 )
      {
        v151 = (_BYTE *)*((_DWORD *)Buf - 1);
        if ( (unsigned int)(Buf - v151 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v151);
    }
    p_Buf = (void **)&Buf;
    v414 = v442;
    v415 = (unsigned int)v443;
    v416 = (int)v444;
    Buf = v441;
    Size = MaxCount;
    v418 = v446;
    if ( (unsigned int)v446 >= 0x10 )
      p_Buf = (void **)v441;
    if ( MaxCount )
    {
      v153 = (size_t)p_Buf + MaxCount;
      v154 = memchr(p_Buf, 10, MaxCount);
      if ( v154 )
      {
        while ( *v154 == 10 ? 0 : *v154 < 0xAu ? -1 : 1 )
        {
          v154 = memchr(v154 + 1, 10, v153 - (_DWORD)(v154 + 1));
          if ( !v154 )
            goto LABEL_230;
        }
        v157 = v154 - (_BYTE *)p_Buf;
        if ( v157 != -1 )
          sub_10005E60(&Buf, v157, 0);
      }
    }
LABEL_230:
    v437 = 0;
    sub_10012060(v438);
    LOBYTE(v453) = 54;
    sub_10012B50(&v437, (int)"ps_._.", (int)"", v158);
    LOBYTE(v453) = 55;
    v159 = (void **)&Buf;
    if ( v418 >= 0x10 )
      v159 = (void **)Buf;
    v160 = sub_10013A70((int)v159, (char *)v159 + Size, 0, &v437, 0x10u, (int)v159);
    LOBYTE(v453) = 52;
    v452 = v160;
    if ( v437 )
    {
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v437 + 32), 0xFFFFFFFF) )
      {
        v161 = v437;
        while ( v161 )
        {
          v162 = (void (__thiscall ***)(_DWORD, int))v161;
          v163 = (_DWORD *)(v161 + 12);
          v161 = *(_DWORD *)(v161 + 12);
          *v163 = 0;
          (**v162)(v162, 1);
        }
      }
    }
    v437 = 0;
    if ( v439 )
    {
      v164 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
      if ( v164 )
        (**v164)(v164, 1);
    }
    if ( !v452 )
      break;
LABEL_193:
    v141 = v440;
  }
  if ( sub_10011EF0(&Buf, "def c", 0) != -1 )
  {
    HIBYTE(a2) = 1;
    sub_100126A0(v386, &Buf);
    v165 = v447;
    LOBYTE(v453) = 56;
    sub_10011FB0((const void **)&Src, v447, (char *)v386);
    v166 = v386;
    v447 = (size_t)v386[4] + v165;
    LOBYTE(v453) = 52;
LABEL_192:
    sub_100019D0(v166);
    goto LABEL_193;
  }
  if ( sub_10011EF0(&Buf, "tex t", 0) != -1 )
  {
    v168 = (int *)sub_10011C30((int)&v402, ".*tex t([0-9]).*", v167);
    LOBYTE(v453) = 57;
    sub_10012920((int)v398, (char *)&Buf, v168, "$1", 0);
    LOBYTE(v453) = 59;
    sub_10011BD0(&v402);
    v169 = (void **)sub_100125C0(&v441, "    texld r", v398);
    LOBYTE(v453) = 60;
    v170 = sub_100126F0(v386, v169, ", t");
    LOBYTE(v453) = 61;
    v171 = sub_100127B0(v373, (int)v170, v398);
    LOBYTE(v453) = 62;
    sub_100126F0(&v424, v171, "\n");
    sub_100019D0(v373);
    sub_100019D0(v386);
    LOBYTE(v453) = 66;
    sub_100019D0(&v441);
    v172 = sub_10001940(v398);
    v173 = sub_10027E6A((int)v172, 0, 10);
    if ( v173 >= 6 )
      v173 = 6;
    v174 = v447;
    *((_BYTE *)&v379 + v173) = 1;
    sub_10011FB0((const void **)&Src, v174, (char *)&v424);
    if ( HIBYTE(a2) )
    {
      v392 += v428;
    }
    else
    {
      HIBYTE(a2) = 1;
      v447 = v428 + v174;
    }
    sub_100019D0(&v424);
    LOBYTE(v453) = 52;
    v166 = v398;
    goto LABEL_192;
  }
  v175 = (int *)sub_10011C30((int)&v402, "-c[0-9]|c[0-9][\\.wxyz]*_", v167);
  LOBYTE(v453) = 67;
  v176 = sub_10012A20((int *)&Buf, v175);
  LOBYTE(v453) = 52;
  v177 = v176;
  sub_10011BD0(&v402);
  if ( v177 )
  {
    v178 = 0;
    while ( 1 )
    {
      v179 = (const void **)sub_100084E0(v373, v178);
      LOBYTE(v453) = 68;
      sub_10012620((const void **)&v424, "r", v179);
      LOBYTE(v453) = 70;
      sub_100019D0(v373);
      if ( sub_10011F30(&Src, (int)&v424, 0) == -1 )
        break;
      LOBYTE(v453) = 52;
      sub_100019D0(&v424);
      if ( ++v178 >= 6 )
        goto LABEL_277;
    }
    v181 = (int *)sub_10011C30((int)&v402, ".*-(c[0-9]).*|.*(c[0-9])[\\.wxyz]*_.*", v180);
    LOBYTE(v453) = 71;
    sub_10012920((int)v398, (char *)&Buf, v181, "$1$2", 0);
    LOBYTE(v453) = 73;
    sub_10011BD0(&v402);
    v182 = (void **)sub_100125C0(v389, "-", v398);
    LOBYTE(v453) = 74;
    v183 = sub_100126F0(v372, v182, "|");
    LOBYTE(v453) = 75;
    v184 = sub_100127B0(v374, (int)v183, v398);
    LOBYTE(v453) = 76;
    v185 = (int *)sub_100126F0(v386, v184, "[\\.wxyz]*_");
    LOBYTE(v453) = 77;
    v186 = (int *)sub_10012A50((int)&v437, v185, v363);
    LOBYTE(v453) = 78;
    v187 = sub_10011E70(v395, v373, v440 + Size, v396);
    LOBYTE(v453) = 79;
    v188 = sub_10012A20(v187, v186);
    sub_100019D0(v373);
    sub_10011BD0(&v437);
    sub_100019D0(v386);
    sub_100019D0(v374);
    sub_100019D0(v372);
    LOBYTE(v453) = 73;
    sub_100019D0(v389);
    if ( v188 )
    {
      v189 = v450;
      while ( 1 )
      {
        if ( v178 >= 6 )
          goto LABEL_260;
        v190 = (const void **)sub_100084E0(v373, v178);
        LOBYTE(v453) = 80;
        v191 = v189 | 0x200;
        v448 = v191;
        v192 = sub_10012620((const void **)v374, "r", v190);
        v453 = 81;
        v189 = v191 | 0x400;
        v448 = v189;
        if ( sub_10011F30(&Src, (int)v192, 0) != -1 )
          goto LABEL_259;
        v193 = (const void **)sub_100084E0(v372, v178);
        v453 = 82;
        v194 = v189 | 0x800;
        v448 = v194;
        v195 = sub_10012620(v389, "r", v193);
        v189 = v194 | 0x1000;
        if ( sub_10011F30(v395, (int)v195, 0) == -1 )
LABEL_260:
          v451 = 0;
        else
LABEL_259:
          v451 = 1;
        if ( (v189 & 0x1000) != 0 )
        {
          v189 &= ~0x1000u;
          sub_100019D0(v389);
        }
        if ( (v189 & 0x800) != 0 )
        {
          v189 &= ~0x800u;
          sub_100019D0(v372);
        }
        if ( (v189 & 0x400) != 0 )
        {
          v189 &= ~0x400u;
          sub_100019D0(v374);
        }
        v453 = 73;
        if ( (v189 & 0x200) != 0 )
        {
          v189 &= ~0x200u;
          sub_100019D0(v373);
        }
        if ( !v451 )
          break;
        ++v178;
      }
      v450 = v189;
      if ( v178 < 6 )
      {
        v196 = (const void **)sub_100084E0(v372, v178);
        LOBYTE(v453) = 83;
        v197 = sub_10012620(v389, "r", v196);
        sub_10005F60(&v424, v197);
        sub_100019D0(v389);
        LOBYTE(v453) = 73;
        sub_100019D0(v372);
        v199 = (int *)sub_10012A50((int)&v437, (int *)v398, v198);
        LOBYTE(v453) = 84;
        v200 = sub_10012AC0((void **)v389, (char *)v395, v199, (char *)&v424, 0);
        sub_10005F60(v395, v200);
        sub_100019D0(v389);
        LOBYTE(v453) = 73;
        sub_10011BD0(&v437);
      }
    }
    v201 = (void **)sub_100125C0(v374, "    mov ", &v424);
    LOBYTE(v453) = 85;
    v202 = sub_100126F0(v372, v201, ", ");
    LOBYTE(v453) = 86;
    v203 = sub_100127B0((void **)v389, (int)v202, v398);
    LOBYTE(v453) = 87;
    sub_100126F0(&v441, v203, "\n");
    sub_100019D0(v389);
    sub_100019D0(v372);
    LOBYTE(v453) = 91;
    sub_100019D0(v374);
    v205 = (int *)sub_10012A50((int)&v402, (int *)v398, v204);
    LOBYTE(v453) = 92;
    v206 = sub_10012AC0(v373, (char *)&Buf, v205, (char *)&v424, 0);
    sub_10005F60(&Buf, v206);
    sub_100019D0(v373);
    LOBYTE(v453) = 91;
    sub_10011BD0(&v402);
    v207 = v383;
    if ( v383 >= 8 )
    {
      v208 = v447;
      HIBYTE(a2) = 1;
      sub_10011FB0((const void **)&Src, v447, (char *)&v441);
      v447 = MaxCount + v208;
    }
    else
    {
      sub_10011FB0((const void **)&Src, v392 + v447, (char *)&v441);
      v383 = v207 + 1;
    }
    sub_100019D0(&v441);
    sub_100019D0(v398);
    LOBYTE(v453) = 52;
    sub_100019D0(&v424);
  }
LABEL_277:
  if ( sub_10011A40(&v410) )
  {
    v209 = (char *)v422;
    v210 = 0;
    v448 = (v411 - (int)v422) / 48;
    if ( v448 )
    {
      v211 = Size;
      do
      {
        v212 = v209;
        if ( *((_DWORD *)v209 + 5) >= 0x10u )
          v212 = *(char **)v209;
        v213 = (void **)&Buf;
        if ( v418 >= 0x10 )
          v213 = (void **)Buf;
        if ( sub_10012CA0((int)v213, v211, 0, v212, *((_DWORD *)v209 + 4)) != -1 )
        {
          v214 = v449 + v211;
          v215 = sub_10011E70(v395, v389, v214, 4u);
          if ( sub_10011EF0(v215, "+", 0) != -1 )
            v214 = sub_10011EF0(v395, "\n", v214 + 1);
          sub_100019D0(v389);
          v216 = sub_10011A20(&v410, v210);
          if ( sub_10011F30(v395, v216, v214) == -1 )
          {
            v217 = sub_10011A20(&v410, v210);
            v218 = (void **)sub_100125C0(v374, "$1", (void **)(v217 + 24));
            LOBYTE(v453) = 93;
            v219 = (char *)sub_100126F0(v372, v218, "$2");
            LOBYTE(v453) = 94;
            v220 = (int *)sub_10011C30((int)&v402, "([ \\+]+[a-z_\\.0-9]+ )r[0-9](.*)", v364);
            LOBYTE(v453) = 95;
            v221 = sub_10012AC0((void **)v389, (char *)&Buf, v220, v219, 0);
            sub_10005F60(&Buf, v221);
            sub_100019D0(v389);
            sub_10011BD0(&v402);
            sub_100019D0(v372);
            LOBYTE(v453) = 52;
            sub_100019D0(v374);
            v449 = (int)v422;
            v222 = sub_10011A00(&v449, &v369, v210);
            sub_10011A60(&v410, &v368, (_DWORD *)*v222);
            v422 = v410;
            break;
          }
          v211 = Size;
        }
        ++v210;
        v209 += 48;
      }
      while ( v210 < v448 );
    }
  }
  v437 = 0;
  sub_10012060(v438);
  LOBYTE(v453) = 96;
  sub_10012B50(&v437, (int)"t[0-9]", (int)"", v223);
  LOBYTE(v453) = 97;
  v224 = (void **)&Buf;
  if ( v418 >= 0x10 )
    v224 = (void **)Buf;
  v225 = sub_10013A70((int)v224, (char *)v224 + Size, 0, &v437, 0x10u, (int)v224);
  LOBYTE(v453) = 52;
  v226 = v225;
  sub_100121B0(&v437);
  if ( v439 )
  {
    v227 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
    if ( v227 )
      (**v227)(v227, 1);
  }
  if ( !v226 )
    goto LABEL_341;
  v437 = 0;
  sub_10012060(v438);
  LOBYTE(v453) = 98;
  sub_10012B50(&v437, (int)".*t([0-9]).*", (int)"", v228);
  LOBYTE(v453) = 99;
  sub_10012920((int)&v424, (char *)&Buf, &v437, "$1", 0);
  LOBYTE(v453) = 101;
  if ( v437 )
  {
    if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v437 + 32), 0xFFFFFFFF) )
    {
      v229 = v437;
      while ( v229 )
      {
        v230 = (void (__thiscall ***)(_DWORD, int))v229;
        v231 = (_DWORD *)(v229 + 12);
        v229 = *(_DWORD *)(v229 + 12);
        *v231 = 0;
        (**v230)(v230, 1);
      }
    }
  }
  v437 = 0;
  if ( v439 )
  {
    v232 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
    if ( v232 )
      (**v232)(v232, 1);
  }
  v233 = v440 + Size;
  v449 = v440 + Size;
  v234 = sub_10011E70(v395, v386, v440 + Size, 4u);
  if ( sub_10011EF0(v234, "+", 0) != -1 )
  {
    v233 = sub_10011EF0(v395, "\n", v233 + 1);
    v449 = v233;
  }
  if ( v387 >= 0x10 )
  {
    v235 = v386[0];
    if ( v387 + 1 >= 0x1000 )
    {
      v235 = (void *)*((_DWORD *)v386[0] - 1);
      if ( (unsigned int)(v386[0] - v235 - 4) > 0x1F )
        goto LABEL_462;
    }
    sub_1001D481(v235);
  }
  if ( v428 == 0x7FFFFFFF )
    sub_100012E0();
  v236 = &v424;
  if ( v429 >= 0x10 )
    v236 = v424;
  sub_100137A0(v398, a1, v428, "t", 1u, v236, v428);
  v450 |= 0x80000000;
  v237 = (char *)v398;
  v238 = v400;
  v239 = (char *)v398[0];
  v452 = v400 >= 0x10;
  if ( v400 >= 0x10 )
    v237 = (char *)v398[0];
  v240 = v395;
  if ( v397 >= 0x10 )
    v240 = (void **)v395[0];
  v242 = sub_10012CA0((int)v240, v396, v233, v237, v399);
  if ( v452 )
  {
    v243 = v239;
    if ( v238 + 1 >= 0x1000 )
    {
      v239 = (char *)*((_DWORD *)v239 - 1);
      if ( (unsigned int)(v243 - v239 - 4) > 0x1F )
        goto LABEL_462;
    }
    sub_1001D481(v239);
  }
  if ( v242 != -1 )
  {
LABEL_340:
    LOBYTE(v453) = 52;
    sub_100019D0(&v424);
LABEL_341:
    v437 = 0;
    sub_10012060(v438);
    LOBYTE(v453) = 124;
    sub_10012B50(&v437, (int)"t([0-9])", (int)"", v270);
    v271 = v450 | 0x800000;
    v441 = 0;
    v442 = 0;
    v443 = 0;
    v444 = 0;
    MaxCount = 0;
    v446 = 15;
    v448 = v450 | 0x800000;
    v425 = 0;
    v426 = 0;
    v427 = 0;
    v424 = (void *)3220594;
    v428 = 3;
    v429 = 15;
    LOBYTE(v453) = 0x80;
    v272 = (void **)&Buf;
    v452 = v418 >= 0x10;
    if ( v418 >= 0x10 )
      v272 = (void **)Buf;
    v273 = (char *)&Buf;
    if ( v452 )
      v273 = Buf;
    sub_10014950(&v370, v273, &v441, (char *)v272 + Size, &v437, (char *)&v424, 0);
    LOBYTE(v453) = 126;
    if ( v429 >= 0x10 )
    {
      v274 = v424;
      if ( v429 + 1 >= 0x1000 )
      {
        v274 = (_BYTE *)*((_DWORD *)v424 - 1);
        if ( (unsigned int)((_BYTE *)v424 - v274 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v274);
    }
    v275 = MaxCount;
    if ( v446 == MaxCount )
    {
      LOBYTE(v378) = 0;
      v277 = sub_10001D90(&v441, 1u, v378, "\n", 1u);
    }
    else
    {
      ++MaxCount;
      v276 = (char *)&v441;
      if ( (unsigned int)v446 >= 0x10 )
        v276 = (char *)v441;
      *(_WORD *)&v276[v275] = 10;
      v277 = &v441;
    }
    v278 = v271 | 0x400000;
    v279 = *v277;
    v280 = v277[1];
    v385 = (unsigned int)v277[2];
    v449 = (int)v277[3];
    v448 = (unsigned int)v277[4];
    v450 = (unsigned int)v277[5];
    v277[4] = 0;
    v277[5] = (void *)15;
    *(_BYTE *)v277 = 0;
    if ( v418 >= 0x10 )
    {
      v281 = Buf;
      if ( v418 + 1 >= 0x1000 )
      {
        v281 = (_BYTE *)*((_DWORD *)Buf - 1);
        if ( (unsigned int)(Buf - v281 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v281);
    }
    v100 = v278 & 0xFF7FFFFF;
    v415 = v385;
    v416 = v449;
    Size = v448;
    LOBYTE(v453) = 125;
    Buf = v279;
    v414 = v280;
    v418 = v450;
    v450 = v100;
    if ( (unsigned int)v446 >= 0x10 )
    {
      v282 = v441;
      if ( (unsigned int)(v446 + 1) >= 0x1000 )
      {
        v282 = (_BYTE *)*((_DWORD *)v441 - 1);
        if ( (unsigned int)((_BYTE *)v441 - v282 - 4) > 0x1F )
          goto LABEL_462;
      }
      sub_1001D481(v282);
    }
    LOBYTE(v453) = 52;
    MaxCount = 0;
    v446 = 15;
    LOBYTE(v441) = 0;
    if ( v437 )
    {
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v437 + 32), 0xFFFFFFFF) )
      {
        v283 = v437;
        while ( v283 )
        {
          v284 = (void (__thiscall ***)(_DWORD, int))v283;
          v285 = (_DWORD *)(v283 + 12);
          v283 = *(_DWORD *)(v283 + 12);
          *v285 = 0;
          (**v284)(v284, 1);
        }
      }
    }
    v437 = 0;
    if ( v439 )
    {
      v286 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
      if ( v286 )
        (**v286)(v286, 1);
    }
    v287 = (void **)&Buf;
    v288 = Size;
    if ( v418 >= 0x10 )
      v287 = (void **)Buf;
    v289 = v434;
    if ( Size > v435 - v434 )
    {
      LOBYTE(v382) = 0;
      sub_10001D90(&Src, Size, v382, v287, Size);
    }
    else
    {
      v434 += Size;
      v290 = (char *)&Src;
      v449 = (int)&Src;
      if ( v435 >= 0x10 )
      {
        v290 = (char *)Src;
        v449 = (int)Src;
      }
      memmove(&v290[v289], v287, Size);
      *(_BYTE *)(v288 + v449 + v289) = 0;
    }
    goto LABEL_193;
  }
  v244 = (int *)sub_10011C30((int)&v402, "[ \\+]+[a-z_\\.0-9]+ r([0-9]).*", v241);
  LOBYTE(v453) = 102;
  sub_10012920((int)v398, (char *)&Buf, v244, "$1", 0);
  LOBYTE(v453) = 104;
  sub_10011BD0(&v402);
  v245 = sub_10001940(v398);
  v246 = sub_10027E6A((int)v245, 0, 10);
  v385 = v246;
  if ( v246 >= 6 )
    v246 = 6;
  if ( *((_BYTE *)&v379 + v246) )
  {
LABEL_339:
    sub_100019D0(v398);
    goto LABEL_340;
  }
  v248 = (int *)sub_10011C30((int)&v442, "t[0-9]", v247);
  LOBYTE(v453) = 105;
  v249 = (char *)sub_100125C0(v374, "r", &v424);
  LOBYTE(v453) = 106;
  v250 = sub_100125C0(v372, "t", &v424);
  LOBYTE(v453) = 107;
  v251 = (int *)sub_10012A50((int)&v437, v250, v365);
  LOBYTE(v453) = 108;
  v252 = (int *)sub_10012AC0((void **)v389, (char *)&Buf, v251, v249, 0);
  LOBYTE(v453) = 109;
  v253 = sub_10012A20(v252, v248);
  sub_100019D0(v389);
  sub_10011BD0(&v437);
  sub_100019D0(v372);
  sub_100019D0(v374);
  LOBYTE(v453) = 104;
  sub_10011BD0((int *)&v442);
  if ( !v253 )
  {
    v254 = sub_100125C0(v372, "r", v398);
    LOBYTE(v453) = 110;
    v255 = v450 | 0x2000;
    v450 = v255;
    v448 = v255;
    if ( sub_10011F30(&Src, (int)v254, 0) == -1
      || (v256 = sub_100125C0(v389, "r", v398),
          v255 |= 0x4000u,
          v450 = v255,
          v257 = sub_10011F30(v395, (int)v256, v449),
          v451 = 0,
          v257 == -1) )
    {
      v451 = 1;
    }
    if ( (v255 & 0x4000) != 0 )
    {
      v255 &= ~0x4000u;
      v450 = v255;
      sub_100019D0(v389);
    }
    v453 = 104;
    if ( (v255 & 0x2000) != 0 )
    {
      v450 = v255 & 0xFFFFDFFF;
      sub_100019D0(v372);
    }
    if ( v451 )
    {
      v258 = (void **)sub_100125C0(v374, "$1r", &v424);
      LOBYTE(v453) = 111;
      v259 = (char *)sub_100126F0(v372, v258, "$2");
      LOBYTE(v453) = 112;
      v260 = (int *)sub_10011C30((int)&v442, "([ \\+]+[a-z_\\.0-9]+ )r[0-9](.*)", v366);
      LOBYTE(v453) = 113;
      v261 = sub_10012AC0((void **)v389, (char *)&Buf, v260, v259, 0);
      sub_10005F60(&Buf, v261);
      sub_100019D0(v389);
      sub_10011BD0((int *)&v442);
      sub_100019D0(v372);
      LOBYTE(v453) = 104;
      sub_100019D0(v374);
      v262 = (char *)sub_100125C0(v374, "r", &v424);
      LOBYTE(v453) = 114;
      v263 = sub_100125C0(v372, "r", v398);
      LOBYTE(v453) = 115;
      v264 = (int *)sub_10012A50((int)&v442, v263, v367);
      LOBYTE(v453) = 116;
      v265 = v449;
      v266 = (char *)sub_10011E70(v395, v389, v449, v396);
      LOBYTE(v453) = 117;
      sub_10012AC0(v386, v266, v264, v262, 0);
      sub_100019D0(v389);
      sub_10011BD0((int *)&v442);
      sub_100019D0(v372);
      LOBYTE(v453) = 122;
      sub_100019D0(v374);
      sub_10005E60(v395, v265, 0);
      sub_10001950(v395, v386);
      sub_100019D0(v386);
    }
    else
    {
      v267 = v385;
      if ( v385 >= 6 )
        v267 = 6;
      *((_BYTE *)&v379 + v267) = 1;
      sub_100116E0(v371);
      LOBYTE(v453) = 123;
      v268 = sub_100125C0(v389, "r", v398);
      sub_10005F60(v371, v268);
      sub_100019D0(v389);
      v269 = sub_100125C0(v389, "r", &v424);
      sub_10005F60(v372, v269);
      sub_100019D0(v389);
      sub_10011AD0((int *)&v410, v371);
      sub_10011720(v371);
      v422 = v410;
    }
    goto LABEL_339;
  }
  v423 = 1;
  sub_100019D0(v398);
  LOBYTE(v453) = 52;
  sub_100019D0(&v424);
LABEL_377:
  sub_10012380((const void **)&Src, v447, "    phase\n", 0xAu);
  if ( !v423 )
  {
    v291 = &Src;
    if ( v435 >= 0x10 )
      v291 = Src;
    if ( dword_10053124(v291, v434, 0, 0, 0, &v384) < 0 )
    {
      v293 = sub_10006250(&dword_10053148, "> Failed to convert shader to ps_1_4");
      sub_100064E0(v293);
      v294 = sub_10006250(&dword_10053148, "> Dumping translated shader assembly:");
      v295 = sub_100064E0(v294);
      v296 = sub_100064E0(v295);
      v297 = &Src;
      if ( v435 >= 0x10 )
        v297 = Src;
      v298 = sub_10001EF0(v296, (int)v297, v434);
      sub_100064E0(v298);
      v299 = sub_10006250(&dword_10053148, "> Failed to reassemble shader:");
      v300 = sub_100064E0(v299);
      v301 = sub_100064E0(v300);
      v302 = (const char *)(*(int (__stdcall **)(int))(*(_DWORD *)v394 + 12))(v394);
      v303 = sub_10006250(v301, v302);
      sub_100064E0(v303);
    }
    else
    {
      v292 = &Src;
      if ( v435 >= 0x10 )
        v292 = Src;
      sub_10012450((size_t *)v419, v292, v434);
    }
  }
  LOBYTE(v453) = 37;
  if ( v418 >= 0x10 )
  {
    v304 = Buf;
    if ( v418 + 1 < 0x1000 || (v304 = (void *)*((_DWORD *)Buf - 1), (unsigned int)(Buf - (_BYTE *)v304 - 4) <= 0x1F) )
    {
      sub_1001D481(v304);
      goto LABEL_391;
    }
LABEL_462:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_391:
  LOBYTE(v453) = 36;
  Size = 0;
  v418 = 15;
  LOBYTE(Buf) = 0;
  if ( v435 >= 0x10 )
  {
    v305 = Src;
    if ( v435 + 1 >= 0x1000 )
    {
      v305 = (_BYTE *)*((_DWORD *)Src - 1);
      if ( (unsigned int)((_BYTE *)Src - v305 - 4) > 0x1F )
        goto LABEL_462;
    }
    sub_1001D481(v305);
  }
  v306 = (char *)v422;
  v434 = 0;
  v435 = 15;
  LOBYTE(Src) = 0;
  LOBYTE(v453) = 4;
  if ( v422 )
  {
    v307 = v411;
    v308 = v422;
    if ( v422 != (void *)v411 )
    {
      do
      {
        sub_10011720(v308);
        v308 += 12;
      }
      while ( v308 != (_DWORD *)v307 );
    }
    v309 = v306;
    if ( (unsigned int)(48 * ((int)(v412 - (_DWORD)v306) / 48)) >= 0x1000 )
    {
      v306 = (char *)*((_DWORD *)v306 - 1);
      if ( (unsigned int)(v309 - v306 - 4) > 0x1F )
        goto LABEL_462;
    }
    sub_1001D481(v306);
  }
  v100 = v450;
LABEL_402:
  v437 = 0;
  sub_10012060(v438);
  LOBYTE(v453) = -127;
  sub_10012B50(
    &v437,
    (int)"(mad)([_satxd248]*) (r[0-9][\\.wxyz]*), (1?-?[crtv][0-9][\\.wxyz_abdis2]*), (1?-?[crtv][0-9][\\.wxyz_abdis2]*),"
         " (-)(c[0-9][\\.wxyz]*)(_bx2|_bias|_x2|_d[zbwa]|)(?![_\\.wxyz])",
    (int)"",
    v310);
  LOBYTE(v453) = -126;
  v311 = (_DWORD *)sub_10012920(
                     (int)&v424,
                     (char *)v419,
                     &v437,
                     "sub$2 $3, $4, $7$8 /* changed 'mad' to 'sub' removed $5 removed modifier $6 */",
                     0);
  sub_10005F60(v419, v311);
  if ( v429 >= 0x10 )
  {
    v312 = v424;
    if ( v429 + 1 >= 0x1000 )
    {
      v312 = (_BYTE *)*((_DWORD *)v424 - 1);
      if ( (unsigned int)((_BYTE *)v424 - v312 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v312);
  }
  v428 = 0;
  v429 = 15;
  LOBYTE(v424) = 0;
  LOBYTE(v453) = 4;
  sub_100121B0(&v437);
  if ( v439 )
  {
    v313 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
    if ( v313 )
      (**v313)(v313, 1);
  }
  v437 = 0;
  sub_10012060(v438);
  LOBYTE(v453) = -125;
  sub_10012B50(&v437, (int)"(c[0-9][\\.wxyz]*)(_bx2|_bias|_x2|_d[zbwa])", (int)"", v314);
  v435 = 15;
  Src = 0;
  v431 = 0;
  v432 = 0;
  v433 = 0;
  v434 = 0;
  v448 = v100 | 0x8000;
  v388 = 0;
  memset(v389, 0, sizeof(v389));
  v390 = 0;
  LOBYTE(v453) = -122;
  v391 = 15;
  v388 = operator new(0x20u);
  v390 = 28;
  v391 = 31;
  strcpy((char *)v388, "$1 /* removed modifier $2 */");
  LOBYTE(v453) = -121;
  v315 = v419;
  if ( v421 >= 0x10 )
    v315 = (void **)v419[0];
  v316 = (char *)v315 + v420;
  v317 = (char *)v419;
  if ( v421 >= 0x10 )
    v317 = (char *)v419[0];
  sub_10014950((void ***)&a2, v317, &Src, v316, &v437, (char *)&v388, 0);
  LOBYTE(v453) = -123;
  if ( v391 >= 0x10 )
  {
    v318 = v388;
    if ( v391 + 1 >= 0x1000 )
    {
      v318 = (_BYTE *)*((_DWORD *)v388 - 1);
      if ( (unsigned int)((_BYTE *)v388 - v318 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v318);
  }
  sub_10005F60(v419, &Src);
  LOBYTE(v453) = -124;
  if ( v435 >= 0x10 )
  {
    v319 = Src;
    if ( v435 + 1 >= 0x1000 )
    {
      v319 = (_BYTE *)*((_DWORD *)Src - 1);
      if ( (unsigned int)((_BYTE *)Src - v319 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v319);
  }
  v434 = 0;
  v435 = 15;
  LOBYTE(Src) = 0;
  LOBYTE(v453) = 4;
  sub_100121B0(&v437);
  if ( v439 )
  {
    v320 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
    if ( v320 )
      (**v320)(v320, 1);
  }
  v437 = 0;
  sub_10012060(v438);
  LOBYTE(v453) = -120;
  sub_10012B50(&v437, (int)"(1?-)(c[0-9][\\.wxyz]*(?![\\.wxyz]))", (int)"", v321);
  LOBYTE(v453) = -119;
  v322 = (_DWORD *)sub_10012920((int)&v424, (char *)v419, &v437, "$2 /* removed modifier $1 */", 0);
  sub_10005F60(v419, v322);
  if ( v429 >= 0x10 )
  {
    v323 = v424;
    if ( v429 + 1 >= 0x1000 )
    {
      v323 = (_BYTE *)*((_DWORD *)v424 - 1);
      if ( (unsigned int)((_BYTE *)v424 - v323 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v323);
  }
  LOBYTE(v453) = 4;
  v428 = 0;
  v429 = 15;
  LOBYTE(v424) = 0;
  if ( v437 )
  {
    if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v437 + 32), 0xFFFFFFFF) )
    {
      v324 = v437;
      while ( v324 )
      {
        v325 = (void (__thiscall ***)(_DWORD, int))v324;
        v326 = (_DWORD *)(v324 + 12);
        v324 = *(_DWORD *)(v324 + 12);
        *v326 = 0;
        (**v325)(v325, 1);
      }
    }
  }
  v437 = 0;
  if ( v439 )
  {
    v327 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(unsigned int))(*(_DWORD *)v439 + 8))(v439);
    if ( v327 )
      (**v327)(v327, 1);
  }
  v328 = sub_10006250(&dword_10053148, "> Dumping translated shader assembly:");
  v329 = sub_100064E0(v328);
  v330 = sub_100064E0(v329);
  v331 = v419;
  if ( v421 >= 0x10 )
    v331 = (void **)v419[0];
  v332 = sub_10001EF0(v330, (int)v331, v420);
  sub_100064E0(v332);
  if ( dword_10053124 )
  {
    v333 = v419;
    if ( v421 >= 0x10 )
      v333 = (void **)v419[0];
    v334 = dword_10053124(v333, v420, 0, 0, 0, &v384);
    (*(void (__stdcall **)(int))(*(_DWORD *)v393 + 8))(v393);
    if ( v334 >= 0 )
    {
      v335 = *(_DWORD *)(a1 + 12);
      v336 = *(int (__stdcall **)(int, int, int))(*(_DWORD *)v335 + 424);
      v337 = (*(int (__stdcall **)(int))(*(_DWORD *)v384 + 12))(v384);
      v334 = v336(v335, v337, a3);
      if ( v334 < 0 )
      {
        v338 = "> 'IDirect3DDevice9::CreatePixelShader' failed with error code ";
        goto LABEL_447;
      }
      goto LABEL_448;
    }
  }
  else
  {
    v334 = -2005530516;
    (*(void (__stdcall **)(int))(*(_DWORD *)v393 + 8))(v393);
  }
  if ( v394 )
  {
    v339 = sub_10006250(&dword_10053148, "> Failed to reassemble shader:");
    v340 = sub_100064E0(v339);
    v341 = sub_100064E0(v340);
    v342 = (const char *)(*(int (__stdcall **)(int))(*(_DWORD *)v394 + 12))(v394);
    v343 = sub_10006250(v341, v342);
    sub_100064E0(v343);
    (*(void (__stdcall **)(int))(*(_DWORD *)v394 + 8))(v394);
  }
  else
  {
    v338 = "> Failed to reassemble shader with error code ";
LABEL_447:
    v344 = sub_10006250(&dword_10053148, v338);
    *(_DWORD *)&v344[*(_DWORD *)(*(_DWORD *)v344 + 4) + 20] = *(_DWORD *)&v344[*(_DWORD *)(*(_DWORD *)v344 + 4) + 20] & 0xFFFFF1FF | 0x800;
    v345 = sub_10011CA0(v344, v334);
    *(_DWORD *)&v345[*(_DWORD *)(*(_DWORD *)v345 + 4) + 20] = *(_DWORD *)&v345[*(_DWORD *)(*(_DWORD *)v345 + 4) + 20] & 0xFFFFF1FF | 0x200;
    v346 = sub_10006250(v345, "!");
    sub_100064E0(v346);
  }
LABEL_448:
  if ( v397 >= 0x10 )
  {
    v347 = v395[0];
    if ( v397 + 1 < 0x1000 || (v347 = (void *)*((_DWORD *)v395[0] - 1), (unsigned int)(v395[0] - v347 - 4) <= 0x1F) )
    {
      sub_1001D481(v347);
      goto LABEL_452;
    }
LABEL_467:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_452:
  v396 = 0;
  v397 = 15;
  LOBYTE(v395[0]) = 0;
  if ( v421 >= 0x10 )
  {
    v348 = v419[0];
    if ( v421 + 1 >= 0x1000 )
    {
      v348 = (void *)*((_DWORD *)v419[0] - 1);
      if ( (unsigned int)(v419[0] - v348 - 4) > 0x1F )
        goto LABEL_467;
    }
    sub_1001D481(v348);
  }
  return v334;
}
// 1000EBC6: conditional instruction was optimized away because %var_180.4!=0
// 1000EBE7: conditional instruction was optimized away because eax.4==0
// 1000E5F5: variable 'v21' is possibly undefined
// 1000E68A: variable 'v23' is possibly undefined
// 1000E6DB: variable 'v29' is possibly undefined
// 1000E72C: variable 'v32' is possibly undefined
// 1000E7B1: variable 'v35' is possibly undefined
// 1000E842: variable 'v38' is possibly undefined
// 1000ED43: variable 'v72' is possibly undefined
// 1000EDEF: variable 'v77' is possibly undefined
// 1000EEE2: variable 'v84' is possibly undefined
// 1000F0D5: variable 'v91' is possibly undefined
// 1000F250: variable 'v37' is possibly undefined
// 1000F283: variable 'v101' is possibly undefined
// 1000F2B6: variable 'v103' is possibly undefined
// 1000F612: variable 'v122' is possibly undefined
// 1000F853: variable 'v362' is possibly undefined
// 1000FB04: variable 'v158' is possibly undefined
// 1000FC28: variable 'v167' is possibly undefined
// 1000FE13: variable 'v180' is possibly undefined
// 1000FEAD: variable 'v363' is possibly undefined
// 100100C4: variable 'v198' is possibly undefined
// 1001019C: variable 'v204' is possibly undefined
// 10010390: variable 'v364' is possibly undefined
// 10010447: variable 'v223' is possibly undefined
// 100104D0: variable 'v228' is possibly undefined
// 100106A7: variable 'v241' is possibly undefined
// 1001071A: variable 'v247' is possibly undefined
// 10010764: variable 'v365' is possibly undefined
// 100108D7: variable 'v366' is possibly undefined
// 10010970: variable 'v367' is possibly undefined
// 10010AF9: variable 'v270' is possibly undefined
// 10011059: variable 'v310' is possibly undefined
// 10011120: variable 'v314' is possibly undefined
// 100112D8: variable 'v321' is possibly undefined
// 100012E0: using guessed type void __noreturn sub_100012E0(void);
// 10006120: using guessed type void __noreturn sub_10006120(void);
// 10053120: using guessed type int (__stdcall *dword_10053120)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10053124: using guessed type int (__stdcall *dword_10053124)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10053148: using guessed type int dword_10053148;
// 1000E470: using guessed type _DWORD var_1F0[6];

//----- (100116E0) --------------------------------------------------------
_DWORD *__thiscall sub_100116E0(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  this[11] = 15;
  *((_BYTE *)this + 24) = 0;
  return this;
}

//----- (10011720) --------------------------------------------------------
void __thiscall sub_10011720(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  void *v5; // eax

  v2 = this[11];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[6];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_1001D481(v3);
  }
  this[10] = 0;
  this[11] = 15;
  *((_BYTE *)this + 24) = 0;
  v4 = this[5];
  if ( v4 >= 0x10 )
  {
    v5 = (void *)*this;
    if ( v4 + 1 < 0x1000 )
    {
LABEL_10:
      sub_1001D481(v5);
      goto LABEL_11;
    }
    if ( (unsigned int)v5 - *((_DWORD *)v5 - 1) - 4 <= 0x1F )
    {
      v5 = (void *)*((_DWORD *)v5 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (100117B0) --------------------------------------------------------
int __cdecl sub_100117B0(int a1, int a2)
{
  int v2; // ecx

  v2 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 28) = a2;
  return (*(int (__cdecl **)(int))(*(_DWORD *)v2 + 428))(v2);
}

//----- (100117D0) --------------------------------------------------------
int __stdcall sub_100117D0(int a1, _DWORD *a2)
{
  if ( !a2 )
    return -2005530516;
  *a2 = *(_DWORD *)(a1 + 28);
  return 0;
}

//----- (10011800) --------------------------------------------------------
int __stdcall sub_10011800(_DWORD *a1, int a2)
{
  if ( !a2 )
    return -2005530516;
  if ( a1[7] == a2 )
    (*(void (__stdcall **)(_DWORD *, _DWORD))(*a1 + 352))(a1, 0);
  (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 8))(a2);
  return 0;
}

//----- (10011840) --------------------------------------------------------
int __cdecl sub_10011840(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 436))(*(_DWORD *)(a1 + 12));
}

//----- (10011860) --------------------------------------------------------
int __cdecl sub_10011860(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 440))(*(_DWORD *)(a1 + 12));
}

//----- (10011880) --------------------------------------------------------
int __stdcall sub_10011880(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v16; // eax
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v4 = sub_10006250(&dword_10053148, "Redirecting '");
  v5 = sub_10006250(v4, "IDirect3DDevice8::GetPixelShaderFunction");
  v6 = sub_10006250(v5, "(");
  v7 = sub_10007C40(v6, (int)&savedregs, a1);
  v8 = sub_10006250(v7, ", ");
  v9 = sub_100042E0(v8, (int)&savedregs, a2);
  v10 = sub_10006250(v9, ", ");
  v11 = sub_10007C40(v10, (int)&savedregs, a3);
  v12 = sub_10006250(v11, ", ");
  v13 = sub_10007C40(v12, (int)&savedregs, a4);
  v14 = sub_10006250(v13, ")' ...");
  sub_100064E0(v14);
  if ( !a2 )
    return -2005530516;
  v16 = sub_10006250(&dword_10053148, "> Returning translated shader byte code.");
  sub_100064E0(v16);
  return (*(int (__stdcall **)(int, int, int))(*(_DWORD *)a2 + 16))(a2, a3, a4);
}
// 10053148: using guessed type int dword_10053148;

//----- (10011950) --------------------------------------------------------
int __cdecl sub_10011950(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 460))(*(_DWORD *)(a1 + 12));
}

//----- (10011970) --------------------------------------------------------
int __cdecl sub_10011970(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 464))(*(_DWORD *)(a1 + 12));
}

//----- (10011990) --------------------------------------------------------
int __cdecl sub_10011990(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 468))(*(_DWORD *)(a1 + 12));
}

//----- (100119B0) --------------------------------------------------------
char *__thiscall sub_100119B0(char *this)
{
  char *result; // eax
  int v2; // ebx
  char *v3; // edi
  char *v4; // ecx
  int v5; // esi
  char *v6; // [esp+8h] [ebp-8h]

  result = this;
  v2 = 0;
  v3 = this + 40;
  v4 = this + 136;
  v6 = v4;
  if ( v3 != v4 )
  {
    v5 = 1;
    do
    {
      if ( (v5 & *((_DWORD *)result + 34)) != 0 )
      {
        (*(void (__stdcall **)(_DWORD, int, char *))(**((_DWORD **)result + 3) + 220))(*((_DWORD *)result + 3), v2, v3);
        result = this;
        v4 = v6;
      }
      v3 += 16;
      v5 = __ROL4__(v5, 1);
      ++v2;
    }
    while ( v3 != v4 );
  }
  return result;
}

//----- (10011A00) --------------------------------------------------------
_DWORD *__thiscall sub_10011A00(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = *this + 48 * a3;
  return result;
}

//----- (10011A20) --------------------------------------------------------
int __thiscall sub_10011A20(_DWORD *this, int a2)
{
  return *this + 48 * a2;
}

//----- (10011A40) --------------------------------------------------------
int __thiscall sub_10011A40(_DWORD *this)
{
  return (this[1] - *this) / 48;
}

//----- (10011A60) --------------------------------------------------------
_DWORD *__thiscall sub_10011A60(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  _DWORD *v4; // ebx
  _DWORD *v5; // esi
  _DWORD *v6; // edi
  _DWORD *result; // eax

  v3 = this;
  v4 = (_DWORD *)this[1];
  v5 = a3 + 12;
  v6 = a3;
  if ( a3 + 12 != v4 )
  {
    do
    {
      sub_10005F60(v6, v5);
      sub_10005F60(v6 + 6, v5 + 6);
      v5 += 12;
      v6 += 12;
    }
    while ( v5 != v4 );
    v3 = this;
  }
  sub_10011720((_DWORD *)(v3[1] - 48));
  this[1] -= 48;
  result = a2;
  *a2 = a3;
  return result;
}

//----- (10011AD0) --------------------------------------------------------
_DWORD *__thiscall sub_10011AD0(int *this, _DWORD *Src)
{
  _DWORD *v3; // ebx
  _DWORD *result; // eax

  v3 = (_DWORD *)this[1];
  if ( v3 == (_DWORD *)this[2] )
    return (_DWORD *)sub_10013DD0(this, (int)v3, Src);
  sub_10001AF0(v3, Src);
  result = sub_10001AF0(v3 + 6, Src + 6);
  this[1] += 48;
  return result;
}

//----- (10011BD0) --------------------------------------------------------
void __thiscall sub_10011BD0(int *this)
{
  int v2; // ecx
  int v3; // esi
  void (__thiscall ***v4)(_DWORD, int); // ecx
  _DWORD *v5; // eax
  int v6; // ecx
  void (__thiscall ***v7)(_DWORD, int); // eax

  v2 = *this;
  if ( v2 )
  {
    if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 32), 0xFFFFFFFF) )
    {
      v3 = *this;
      while ( v3 )
      {
        v4 = (void (__thiscall ***)(_DWORD, int))v3;
        v5 = (_DWORD *)(v3 + 12);
        v3 = *(_DWORD *)(v3 + 12);
        *v5 = 0;
        (**v4)(v4, 1);
      }
    }
  }
  *this = 0;
  v6 = this[4];
  if ( v6 )
  {
    v7 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
    if ( v7 )
      (**v7)(v7, 1);
  }
}

//----- (10011C30) --------------------------------------------------------
int __thiscall sub_10011C30(int this, const char *a2, int a3)
{
  unsigned int v4; // kr00_4
  int v5; // ecx

  *(_DWORD *)this = 0;
  sub_10012060((struct std::_Facet_base **)(this + 4));
  v4 = strlen(a2);
  sub_10012B50((int *)this, (int)a2, (int)&a2[v4], v5);
  return this;
}
// 10011C80: variable 'v5' is possibly undefined

//----- (10011CA0) --------------------------------------------------------
_BYTE *__thiscall sub_10011CA0(_BYTE *this, int a2)
{
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  _BYTE *v7; // eax
  bool v8; // al
  _BYTE *v9; // eax
  struct std::_Facet_base *v10; // edi
  void (__thiscall ***v11)(_DWORD, int); // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v16; // [esp-4h] [ebp-40h]
  _DWORD v17[3]; // [esp+0h] [ebp-3Ch] BYREF
  int v18[3]; // [esp+Ch] [ebp-30h] BYREF
  bool v19; // [esp+18h] [ebp-24h]
  int v20; // [esp+1Ch] [ebp-20h]
  char v21[4]; // [esp+20h] [ebp-1Ch] BYREF
  struct std::_Facet_base *v22; // [esp+24h] [ebp-18h]
  _BYTE *v23; // [esp+28h] [ebp-14h]
  _DWORD *v24; // [esp+2Ch] [ebp-10h]
  int v25; // [esp+38h] [ebp-4h]

  LOBYTE(v3) = 0;
  v24 = v17;
  v23 = this;
  v4 = *(_DWORD *)this;
  v20 = 0;
  v18[2] = (int)this;
  v5 = *(_DWORD *)&this[*(_DWORD *)(v4 + 4) + 56];
  if ( v5 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  v25 = 0;
  v6 = *(_DWORD *)this;
  v7 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
  if ( *((_DWORD *)v7 + 3) )
  {
    v8 = 0;
  }
  else
  {
    v9 = (_BYTE *)*((_DWORD *)v7 + 15);
    if ( !v9 || v9 == this )
    {
      v8 = 1;
    }
    else
    {
      sub_10002290(v9);
      v6 = *(_DWORD *)this;
      v8 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] == 0;
    }
  }
  v19 = v8;
  v25 = 1;
  if ( v8 )
  {
    v10 = *(struct std::_Facet_base **)(*(_DWORD *)&this[*(_DWORD *)(v6 + 4) + 48] + 4);
    v22 = v10;
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v10 + 4))(v10);
    LOBYTE(v25) = 2;
    v22 = sub_100066A0((int)v21);
    if ( v10 )
    {
      v11 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v10 + 8))(v10);
      if ( v11 )
        (**v11)(v11, 1);
    }
    LOBYTE(v25) = 3;
    v12 = *(_DWORD *)(*(_DWORD *)this + 4);
    v13 = (int)&this[v12];
    LOBYTE(v18[0]) = 0;
    v16 = *(_DWORD *)&this[v12 + 56];
    LOBYTE(v12) = this[v12 + 64];
    v3 = *(_BYTE *)sub_10008090(v22, (int)v18, v13, v12, a2, v18[0], v16) != 0 ? 4 : 0;
    v25 = 1;
  }
  sub_10001870(
    &this[*(_DWORD *)(*(_DWORD *)this + 4)],
    v3 | this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] | (*(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56] != 0
                                                      ? 0
                                                      : 4),
    0);
  if ( !(unsigned __int8)j____uncaught_exception(v17[0], v17[1], v17[2]) )
    sub_100023A0(this);
  v25 = 5;
  v14 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v14 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 8))(v14);
  return this;
}
// 1001BDB7: using guessed type int __cdecl j____uncaught_exception(_DWORD, _DWORD, _DWORD);
// 10011CA0: using guessed type char var_1C[4];

//----- (10011E50) --------------------------------------------------------
char *__thiscall sub_10011E50(char *this, void (__cdecl *a2)(char *))
{
  a2(&this[*(_DWORD *)(*(_DWORD *)this + 4)]);
  return this;
}

//----- (10011E70) --------------------------------------------------------
_DWORD *__thiscall sub_10011E70(_DWORD *this, _DWORD *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax
  size_t v5; // eax

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  v4 = this[4];
  if ( v4 < a3 )
    sub_10006120();
  v5 = v4 - a3;
  if ( v5 >= a4 )
    v5 = a4;
  if ( this[5] >= 0x10u )
    this = (_DWORD *)*this;
  sub_10001C50(a2, (char *)this + a3, v5);
  return a2;
}
// 10006120: using guessed type void __noreturn sub_10006120(void);

//----- (10011EF0) --------------------------------------------------------
int __thiscall sub_10011EF0(_DWORD *this, char *a2, unsigned int a3)
{
  unsigned int v4; // eax
  unsigned int v5; // edx

  v4 = strlen(a2);
  v5 = this[4];
  if ( this[5] >= 0x10u )
    this = (_DWORD *)*this;
  return sub_10012CA0((int)this, v5, a3, a2, v4);
}

//----- (10011F30) --------------------------------------------------------
int __thiscall sub_10011F30(_DWORD *this, int a2, unsigned int a3)
{
  char *v3; // eax
  unsigned int v4; // edx

  v3 = (char *)a2;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    v3 = *(char **)a2;
  v4 = this[4];
  if ( this[5] >= 0x10u )
    this = (_DWORD *)*this;
  return sub_10012CA0((int)this, v4, a3, v3, *(_DWORD *)(a2 + 16));
}

//----- (10011F60) --------------------------------------------------------
char *__thiscall sub_10011F60(_DWORD *this, unsigned int a2)
{
  if ( this[4] <= a2 )
    sub_10006120();
  if ( this[5] >= 0x10u )
    this = (_DWORD *)*this;
  return (char *)this + a2;
}
// 10006120: using guessed type void __noreturn sub_10006120(void);

//----- (10011F80) --------------------------------------------------------
const void **__thiscall sub_10011F80(const void **Src, size_t a2, int a3, char *a4)
{
  size_t v5; // kr00_4

  v5 = strlen(a4);
  return sub_10012200(Src, a2, (int)Src, a4, v5);
}
// 10011FA1: variable 'Src' is possibly undefined

//----- (10011FB0) --------------------------------------------------------
const void **__thiscall sub_10011FB0(const void **this, size_t Size, char *a3)
{
  char *v3; // eax

  v3 = a3;
  if ( *((_DWORD *)a3 + 5) >= 0x10u )
    v3 = *(char **)a3;
  return sub_10012380(this, Size, v3, *((_DWORD *)a3 + 4));
}

//----- (10011FD0) --------------------------------------------------------
void **__thiscall sub_10011FD0(void **Src, const char *Srca)
{
  unsigned int v3; // esi
  unsigned int v4; // edi
  char *v5; // edx
  void *v6; // eax
  char *v7; // edi
  char *v9; // [esp-8h] [ebp-14h]

  v3 = strlen(Srca);
  v4 = (unsigned int)Src[5];
  v5 = (char *)Src[4];
  if ( v3 > v4 - (unsigned int)v5 )
  {
    v9 = (char *)Srca;
    LOBYTE(Srca) = 0;
    return sub_10001D90(Src, v3, (int)Srca, v9, v3);
  }
  else
  {
    Src[4] = &v5[v3];
    v6 = Src;
    if ( v4 >= 0x10 )
      v6 = *Src;
    v7 = &v5[(_DWORD)v6];
    memmove(&v5[(_DWORD)v6], Srca, v3);
    v7[v3] = 0;
    return Src;
  }
}

//----- (10012060) --------------------------------------------------------
struct std::_Facet_base **__thiscall sub_10012060(struct std::_Facet_base **this)
{
  _DWORD *v1; // ebx
  unsigned int v2; // edi
  int v3; // ecx
  int v4; // ebx
  struct std::_Facet_base *v5; // esi
  int v6; // ebx
  int v8; // eax
  char v10[4]; // [esp+10h] [ebp-20h] BYREF
  struct std::_Facet_base *v11; // [esp+14h] [ebp-1Ch]
  char v12[4]; // [esp+18h] [ebp-18h] BYREF
  struct std::_Facet_base *v13; // [esp+1Ch] [ebp-14h] BYREF
  int v14; // [esp+20h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-4h]

  v1 = this + 2;
  v14 = (int)(this + 2);
  this[3] = sub_1001C2C3(1);
  v15 = 1;
  std::_Lockit::_Lockit((std::_Lockit *)v10, 0);
  LOBYTE(v15) = 2;
  v2 = dword_1005322C;
  v11 = (struct std::_Facet_base *)dword_1005321C;
  v13 = (struct std::_Facet_base *)dword_1005321C;
  if ( !dword_1005322C )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_1005322C )
      dword_1005322C = ++dword_10052410;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
    v2 = dword_1005322C;
  }
  v3 = v1[1];
  v4 = 4 * v2;
  if ( v2 >= *(_DWORD *)(v3 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v5 = *(struct std::_Facet_base **)(v4 + *(_DWORD *)(v3 + 8));
    if ( v5 )
    {
LABEL_7:
      v6 = v14;
      goto LABEL_8;
    }
  }
  if ( *(_BYTE *)(v3 + 20) )
  {
    v8 = sub_1001C2BD();
    if ( v2 >= *(_DWORD *)(v8 + 12) )
      goto LABEL_14;
    v5 = *(struct std::_Facet_base **)(v4 + *(_DWORD *)(v8 + 8));
  }
  if ( v5 )
    goto LABEL_7;
LABEL_14:
  v5 = v11;
  v6 = v14;
  if ( !v11 )
  {
    if ( sub_10013310((_Collvec **)&v13, (_DWORD *)v14) == -1 )
      sub_10002860();
    v5 = v13;
    v11 = v13;
    LOBYTE(v15) = 3;
    std::_Facet_Register(v13);
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v5 + 4))(v5);
    dword_1005321C = (int)v5;
  }
LABEL_8:
  LOBYTE(v15) = 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v10);
  *this = v5;
  this[1] = sub_10006130(v6);
  return this;
}
// 10002860: using guessed type void __noreturn sub_10002860(void);
// 10052410: using guessed type int dword_10052410;
// 1005321C: using guessed type int dword_1005321C;
// 10012060: using guessed type char var_20[4];
// 10012060: using guessed type char var_18[4];

//----- (100121B0) --------------------------------------------------------
int __thiscall sub_100121B0(int *this)
{
  int v2; // ecx
  int result; // eax
  int i; // esi
  int (__thiscall ***v5)(_DWORD, int); // ecx
  _DWORD *v6; // eax

  v2 = *this;
  if ( !v2 || (result = _InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 32), 0xFFFFFFFF)) != 0 )
  {
    *this = 0;
  }
  else
  {
    for ( i = *this; i; result = (**v5)(v5, 1) )
    {
      v5 = (int (__thiscall ***)(_DWORD, int))i;
      v6 = (_DWORD *)(i + 12);
      i = *(_DWORD *)(i + 12);
      *v6 = 0;
    }
    *this = 0;
  }
  return result;
}

//----- (10012200) --------------------------------------------------------
const void **__thiscall sub_10012200(const void **Src, size_t a2, int a3, char *Srca, size_t Size)
{
  const void **v5; // edi
  size_t v6; // edx
  unsigned int v7; // esi
  size_t v9; // ecx
  char *v10; // ecx
  char *v11; // esi
  unsigned int v12; // esi
  size_t v13; // esi
  size_t v14; // [esp-4h] [ebp-1Ch]
  char *v15; // [esp+Ch] [ebp-Ch]
  char *v16; // [esp+Ch] [ebp-Ch]
  char *v17; // [esp+Ch] [ebp-Ch]
  size_t v18; // [esp+10h] [ebp-8h]
  char *v19; // [esp+10h] [ebp-8h]
  int v20; // [esp+14h] [ebp-4h]
  int v21; // [esp+14h] [ebp-4h]
  char *v22; // [esp+20h] [ebp+8h]

  v5 = Src;
  v6 = (size_t)Src[4];
  v15 = (char *)v6;
  if ( v6 < a2 )
    sub_10006120();
  if ( v6 - a2 >= 6 )
  {
    v7 = 6;
    v20 = 6;
  }
  else
  {
    v7 = v6 - a2;
    v20 = v6 - a2;
  }
  if ( v7 == Size )
  {
    if ( (unsigned int)Src[5] >= 0x10 )
      Src = (const void **)*Src;
    memmove((char *)Src + a2, Srca, Size);
    return v5;
  }
  else
  {
    v9 = v6 - a2 - v7 + 1;
    v18 = v9;
    if ( Size >= v7 )
    {
      v21 = Size - v7;
      v16 = (char *)v5[5];
      if ( Size - v7 > (unsigned int)&v16[-v6] )
      {
        v14 = Size;
        LOBYTE(Size) = 0;
        return sub_10012DD0(v5, v21, Size, a2, v7, Srca, v14);
      }
      else
      {
        v19 = (char *)v5;
        v5[4] = (const void *)(v6 + v21);
        if ( (unsigned int)v16 >= 0x10 )
          v19 = (char *)*v5;
        v12 = (unsigned int)&v19[a2 + v7];
        v22 = &v19[a2];
        v17 = (char *)v12;
        if ( &Srca[Size] <= v22 || Srca > &v19[v6] )
        {
          v13 = Size;
        }
        else if ( v12 > (unsigned int)Srca )
        {
          v13 = v12 - (_DWORD)Srca;
        }
        else
        {
          v13 = 0;
        }
        memmove(&v17[v21], v17, v9);
        memmove(v22, Srca, v13);
        memmove(&v22[v13], &Srca[v13 + v21], Size - v13);
        return v5;
      }
    }
    else
    {
      v10 = (char *)v5;
      if ( (unsigned int)v5[5] >= 0x10 )
        v10 = (char *)*v5;
      v11 = &v10[a2];
      memmove(&v10[a2], Srca, Size);
      memmove(&v11[Size], &v11[v20], v18);
      v5[4] = &v15[Size - v20];
      return v5;
    }
  }
}
// 10006120: using guessed type void __noreturn sub_10006120(void);

//----- (10012380) --------------------------------------------------------
const void **__thiscall sub_10012380(const void **Src, size_t Size, char *Srca, size_t a4)
{
  size_t v4; // edx
  size_t v6; // ecx
  unsigned int v7; // ebx
  char *v9; // eax
  unsigned int v10; // ebx
  size_t v11; // ebx
  char *v13; // [esp+1Ch] [ebp+10h]

  v4 = Size;
  v6 = (size_t)Src[4];
  if ( v6 < Size )
    sub_10006120();
  v7 = (unsigned int)Src[5];
  if ( a4 > v7 - v6 )
  {
    LOBYTE(Size) = 0;
    return sub_10012F50(Src, a4, Size, v4, Srca, a4);
  }
  else
  {
    v13 = (char *)Src;
    Src[4] = (const void *)(v6 + a4);
    v9 = (char *)Src;
    if ( v7 >= 0x10 )
    {
      v9 = (char *)*Src;
      v13 = (char *)*Src;
    }
    v10 = (unsigned int)&v9[Size];
    if ( &Srca[a4] <= &v9[Size] || Srca > &v13[v6] )
    {
      v11 = a4;
    }
    else if ( v10 > (unsigned int)Srca )
    {
      v11 = v10 - (_DWORD)Srca;
    }
    else
    {
      v11 = 0;
    }
    memmove(&v13[Size + a4], &v13[Size], v6 - Size + 1);
    memmove(&v13[Size], Srca, v11);
    memmove(&v13[Size + v11], &Srca[v11 + a4], a4 - v11);
    return Src;
  }
}
// 10006120: using guessed type void __noreturn sub_10006120(void);

//----- (10012450) --------------------------------------------------------
size_t *__thiscall sub_10012450(size_t *this, void *Src, size_t Size)
{
  unsigned int v5; // ecx
  size_t *v6; // ebx
  size_t v8; // ebx
  size_t v9; // ecx
  void *v10; // eax
  void *v11; // ecx
  _DWORD *v12; // eax
  void *v13; // eax
  unsigned int v14; // [esp+Ch] [ebp-4h]
  size_t Sizea; // [esp+1Ch] [ebp+Ch]

  v5 = this[5];
  v14 = v5;
  if ( Size > v5 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_100012E0();
    if ( (Size | 0xF) > 0x7FFFFFFF || v5 > 0x7FFFFFFF - (v5 >> 1) )
    {
      v8 = 0x7FFFFFFF;
      v9 = -2147483613;
    }
    else
    {
      v8 = v5 + (v5 >> 1);
      if ( (Size | 0xF) >= v8 )
        v8 = Size | 0xF;
      if ( v8 + 1 < 0x1000 )
      {
        if ( v8 == -1 )
          v12 = 0;
        else
          v12 = operator new(v8 + 1);
        goto LABEL_19;
      }
      v9 = v8 + 36;
      if ( v8 + 36 <= v8 + 1 )
        sub_10001240();
    }
    v10 = operator new(v9);
    v11 = v10;
    if ( !v10 )
      goto LABEL_25;
    v12 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
    *(v12 - 1) = v11;
LABEL_19:
    Sizea = (size_t)v12;
    this[4] = Size;
    this[5] = v8;
    memmove(v12, Src, Size);
    *(_BYTE *)(Sizea + Size) = 0;
    if ( v14 < 0x10 )
    {
LABEL_24:
      *this = Sizea;
      return this;
    }
    v13 = (void *)*this;
    if ( v14 + 1 < 0x1000 )
    {
LABEL_23:
      sub_1001D481(v13);
      goto LABEL_24;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_23;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  v6 = this;
  if ( v5 >= 0x10 )
    v6 = (size_t *)*this;
  this[4] = Size;
  memmove(v6, Src, Size);
  *((_BYTE *)v6 + Size) = 0;
  return this;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10012580) --------------------------------------------------------
void __stdcall sub_10012580(_DWORD *Block, int a2)
{
  void *v2; // eax

  v2 = Block;
  if ( (unsigned int)(48 * a2) >= 0x1000 )
  {
    if ( (unsigned int)Block - *(Block - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*(Block - 1);
  }
  sub_1001D481(v2);
}

//----- (100125C0) --------------------------------------------------------
_DWORD *__fastcall sub_100125C0(_DWORD *a1, char *Src, void **a3)
{
  size_t v4; // esi
  void *v5; // ecx

  v4 = strlen(Src);
  v5 = a3;
  if ( 0x7FFFFFFF - (int)a3[4] < v4 )
    sub_100012E0();
  if ( (unsigned int)a3[5] >= 0x10 )
    v5 = *a3;
  sub_100137A0(a1, (int)a3, (int)v5, Src, v4, v5, (size_t)a3[4]);
  return a1;
}
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10012620) --------------------------------------------------------
const void **__fastcall sub_10012620(const void **a1, char *a2, const void **Src)
{
  const void **v4; // edx
  const void **result; // eax

  v4 = sub_10012380(Src, 0, a2, strlen(a2));
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *a1 = *v4;
  a1[1] = v4[1];
  a1[2] = v4[2];
  a1[3] = v4[3];
  a1[4] = v4[4];
  a1[5] = v4[5];
  result = a1;
  v4[4] = 0;
  v4[5] = (const void *)15;
  *(_BYTE *)v4 = 0;
  return result;
}

//----- (100126A0) --------------------------------------------------------
_DWORD *__fastcall sub_100126A0(_DWORD *a1, _DWORD *Src)
{
  size_t v3; // ecx
  int v5; // [esp+4h] [ebp-Ch]

  v3 = Src[4];
  if ( v3 == 0x7FFFFFFF )
    sub_100012E0();
  if ( Src[5] >= 0x10u )
    Src = (_DWORD *)*Src;
  sub_100137A0(a1, v5, v3, Src, v3, "\n", 1u);
  return a1;
}
// 100126D2: variable 'v5' is possibly undefined
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (100126F0) --------------------------------------------------------
void **__fastcall sub_100126F0(void **a1, void **a2, char *Src)
{
  void **v3; // ebx
  void **v4; // esi
  unsigned int v5; // edi
  _BYTE *v6; // ecx
  bool v7; // cf
  char *v8; // eax
  char *v9; // esi
  void **result; // eax
  int v11; // [esp+10h] [ebp-4h]

  v3 = a2;
  v4 = a1;
  v11 = (int)a1;
  v5 = strlen(Src);
  v6 = a2[4];
  if ( v5 > (_BYTE *)a2[5] - v6 )
  {
    LOBYTE(v11) = 0;
    v3 = sub_10001D90(a2, v5, v11, Src, v5);
  }
  else
  {
    v7 = (unsigned int)a2[5] < 0x10;
    a2[4] = &v6[v5];
    v8 = (char *)a2;
    if ( !v7 )
      v8 = (char *)*a2;
    v9 = &v6[(_DWORD)v8];
    memmove(&v6[(_DWORD)v8], Src, v5);
    v9[v5] = 0;
    v4 = (void **)v11;
  }
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = 0;
  v4[4] = 0;
  v4[5] = 0;
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  v4[3] = v3[3];
  v4[4] = v3[4];
  v4[5] = v3[5];
  result = v4;
  v3[4] = 0;
  v3[5] = (void *)15;
  *(_BYTE *)v3 = 0;
  return result;
}

//----- (100127B0) --------------------------------------------------------
void **__fastcall sub_100127B0(void **a1, int a2, void **Src)
{
  void **v4; // esi
  void *v5; // ecx
  unsigned int v6; // ebx
  int v7; // edx
  bool v8; // cf
  char *v9; // eax
  void **result; // eax
  void *v11; // [esp+10h] [ebp-4h]
  _BYTE *Srca; // [esp+1Ch] [ebp+8h]

  v4 = (void **)a2;
  v5 = Src;
  v6 = (unsigned int)Src[4];
  if ( (unsigned int)Src[5] >= 0x10 )
    v5 = *Src;
  v7 = *(_DWORD *)(a2 + 16);
  v11 = v4[4];
  if ( (char *)v6 > (char *)v4[5] - v7 )
  {
    LOBYTE(Src) = 0;
    v4 = sub_10001D90(v4, v6, (int)Src, v5, v6);
  }
  else
  {
    v8 = (unsigned int)v4[5] < 0x10;
    v4[4] = (void *)(v6 + v7);
    v9 = (char *)v4;
    Srca = v4;
    if ( !v8 )
    {
      v9 = (char *)*v4;
      Srca = *v4;
    }
    memmove(&v9[v7], v5, v6);
    Srca[v6 + (_DWORD)v11] = 0;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *a1 = *v4;
  a1[1] = v4[1];
  a1[2] = v4[2];
  a1[3] = v4[3];
  a1[4] = v4[4];
  a1[5] = v4[5];
  result = a1;
  v4[4] = 0;
  v4[5] = (void *)15;
  *(_BYTE *)v4 = 0;
  return result;
}

//----- (10012870) --------------------------------------------------------
void **__fastcall sub_10012870(void **a1, void **a2, _DWORD *Src)
{
  sub_10013570(a1, (int)a1, a2, Src);
  return a1;
}

//----- (10012890) --------------------------------------------------------
_DWORD *__fastcall sub_10012890(_DWORD *a1, char *a2)
{
  unsigned int v4; // ecx
  unsigned int v5; // edx
  char *v6; // eax
  _DWORD *result; // eax
  int v8; // [esp+Ch] [ebp-4h]

  v8 = (int)a1;
  v4 = *((_DWORD *)a2 + 4);
  v5 = *((_DWORD *)a2 + 5);
  if ( v4 >= v5 )
  {
    LOBYTE(v8) = 0;
    sub_100068E0((void **)a2, v4, v8, 10);
  }
  else
  {
    *((_DWORD *)a2 + 4) = v4 + 1;
    v6 = a2;
    if ( v5 >= 0x10 )
      v6 = *(char **)a2;
    *(_WORD *)&v6[v4] = 10;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *a1 = *(_DWORD *)a2;
  a1[1] = *((_DWORD *)a2 + 1);
  a1[2] = *((_DWORD *)a2 + 2);
  a1[3] = *((_DWORD *)a2 + 3);
  a1[4] = *((_DWORD *)a2 + 4);
  a1[5] = *((_DWORD *)a2 + 5);
  result = a1;
  *((_DWORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 5) = 15;
  *a2 = 0;
  return result;
}

//----- (10012920) --------------------------------------------------------
int __fastcall sub_10012920(int a1, char *a2, int *a3, void *Src, int a5)
{
  int v7; // eax
  char *v8; // eax
  void *v9; // edx
  void *Block[5]; // [esp+Ch] [ebp-30h] BYREF
  unsigned int v12; // [esp+20h] [ebp-1Ch]
  void **v13[3]; // [esp+24h] [ebp-18h] BYREF
  int v14; // [esp+38h] [ebp-4h]

  v13[1] = (void **)a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  v13[2] = (void **)1;
  memset(Block, 0, sizeof(Block));
  v12 = 0;
  v14 = 1;
  sub_10001C50(Block, Src, strlen((const char *)Src));
  v14 = 2;
  v7 = *((_DWORD *)a2 + 4);
  if ( *((_DWORD *)a2 + 5) < 0x10u )
  {
    v8 = &a2[v7];
  }
  else
  {
    v8 = (char *)(*(_DWORD *)a2 + v7);
    a2 = *(char **)a2;
  }
  sub_10014950(v13, a2, (void **)a1, v8, a3, (char *)Block, a5);
  if ( v12 >= 0x10 )
  {
    v9 = Block[0];
    if ( v12 + 1 >= 0x1000 )
    {
      v9 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v9 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v9);
  }
  return a1;
}

//----- (10012A20) --------------------------------------------------------
char __fastcall sub_10012A20(int *a1, int *a2)
{
  int v2; // eax

  v2 = (int)a1;
  if ( (unsigned int)a1[5] >= 0x10 )
    v2 = *a1;
  return sub_10013A70(v2, (char *)(v2 + a1[4]), 0, a2, 0x10u, v2);
}

//----- (10012A50) --------------------------------------------------------
int __thiscall sub_10012A50(int this, int *a2, int a3)
{
  int v3; // esi
  int v5; // ecx
  int v6; // eax
  int v7; // eax

  v3 = (int)a2;
  *(_DWORD *)this = 0;
  sub_10012060((struct std::_Facet_base **)(this + 4));
  v6 = a2[4];
  if ( (unsigned int)a2[5] < 0x10 )
  {
    v7 = (int)a2 + v6;
  }
  else
  {
    v7 = *a2 + v6;
    v3 = *a2;
  }
  sub_10012B50((int *)this, v3, v7, v5);
  return this;
}
// 10012A9E: variable 'v5' is possibly undefined

//----- (10012AC0) --------------------------------------------------------
void **__fastcall sub_10012AC0(void **Src, char *a2, int *a3, char *a4, int a5)
{
  bool v6; // cf
  int v7; // eax
  char *v8; // eax
  void **v10[2]; // [esp+4h] [ebp-18h] BYREF
  int v11; // [esp+Ch] [ebp-10h]
  int v12; // [esp+18h] [ebp-4h]

  v10[1] = Src;
  v11 = 0;
  *Src = 0;
  Src[1] = 0;
  Src[2] = 0;
  Src[3] = 0;
  Src[4] = 0;
  Src[5] = (void *)15;
  *(_BYTE *)Src = 0;
  v12 = 0;
  v6 = *((_DWORD *)a2 + 5) < 0x10u;
  v7 = *((_DWORD *)a2 + 4);
  v11 = 1;
  if ( v6 )
  {
    v8 = &a2[v7];
  }
  else
  {
    v8 = (char *)(*(_DWORD *)a2 + v7);
    a2 = *(char **)a2;
  }
  sub_10014950(v10, a2, Src, v8, a3, a4, a5);
  return Src;
}

//----- (10012B50) --------------------------------------------------------
void __thiscall sub_10012B50(int *this, int a2, int a3, int a4)
{
  int v5; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  char *v8; // edx
  char *v9; // eax
  int v10[5]; // [esp+Ch] [ebp-60h] BYREF
  void *Block; // [esp+20h] [ebp-4Ch]
  int v12; // [esp+24h] [ebp-48h]
  int v13; // [esp+28h] [ebp-44h]
  int v14; // [esp+2Ch] [ebp-40h]
  _DWORD *v15; // [esp+30h] [ebp-3Ch]
  _DWORD *v16; // [esp+34h] [ebp-38h]
  int v17; // [esp+38h] [ebp-34h]
  int v18; // [esp+3Ch] [ebp-30h]
  int v19; // [esp+40h] [ebp-2Ch]
  int v20; // [esp+44h] [ebp-28h]
  int v21; // [esp+48h] [ebp-24h]
  int v22; // [esp+4Ch] [ebp-20h]
  int v23; // [esp+5Ch] [ebp-10h]
  int v24; // [esp+68h] [ebp-4h]
  _DWORD *v25; // [esp+74h] [ebp+8h]

  v10[0] = a2;
  v10[1] = a2;
  v10[2] = a3;
  v5 = (int)(this + 1);
  v10[3] = 0;
  v10[4] = 0;
  Block = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v24 = 1;
  v25 = operator new(0x24u);
  v25[1] = 20;
  v25[2] = 0;
  v25[3] = 0;
  v25[4] = 0;
  *v25 = &std::_Root_node::`vftable';
  v25[6] = 0;
  v25[7] = 0;
  v25[8] = 0;
  v15 = v25;
  v16 = v25;
  v17 = 1;
  v18 = v5;
  v19 = 256;
  v20 = 4;
  v21 = v5;
  v22 = 1;
  v23 = 142040571;
  sub_100143D0(v10);
  v24 = 2;
  v6 = sub_10014000(v10);
  v7 = v6;
  if ( v6 )
    _InterlockedIncrement(v6 + 8);
  sub_100121B0(this);
  v8 = (char *)Block;
  *this = (int)v7;
  if ( v8 )
  {
    v9 = v8;
    if ( ((v13 - (_DWORD)v8) & 0xFFFFFFFC) >= 0x1000 )
    {
      v8 = (char *)*((_DWORD *)v8 - 1);
      if ( (unsigned int)(v9 - v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v8);
  }
}
// 1004C20C: using guessed type void *std::_Root_node::`vftable';

//----- (10012CA0) --------------------------------------------------------
int __fastcall sub_10012CA0(int a1, unsigned int a2, unsigned int a3, char *a4, unsigned int a5)
{
  unsigned int v6; // edi
  char *v7; // esi
  char *v8; // edi
  char *v9; // ecx
  char *v10; // edx
  unsigned int v11; // esi
  bool v12; // cf
  unsigned __int8 v13; // al
  unsigned __int8 v14; // al
  unsigned __int8 v15; // al
  int v16; // eax
  int Val; // [esp+10h] [ebp-4h]
  int v20; // [esp+24h] [ebp+10h]

  if ( a5 > a2 )
    return -1;
  v6 = a3;
  if ( a3 > a2 - a5 )
    return -1;
  if ( !a5 )
    return v6;
  v7 = a4;
  v20 = a2 + 1 + a1 - a5;
  Val = *a4;
  v8 = (char *)memchr((const void *)(a3 + a1), Val, v20 - (a3 + a1));
  if ( !v8 )
    return -1;
  while ( 1 )
  {
    v9 = v7;
    v10 = v8;
    v11 = a5 - 4;
    if ( a5 < 4 )
    {
LABEL_8:
      if ( v11 == -4 )
        goto LABEL_17;
    }
    else
    {
      while ( *(_DWORD *)v10 == *(_DWORD *)v9 )
      {
        v10 += 4;
        v9 += 4;
        v12 = v11 < 4;
        v11 -= 4;
        if ( v12 )
          goto LABEL_8;
      }
    }
    v12 = (unsigned __int8)*v10 < (unsigned __int8)*v9;
    if ( *v10 != *v9
      || v11 != -3
      && ((v13 = v10[1], v12 = v13 < (unsigned __int8)v9[1], v13 != v9[1])
       || v11 != -2
       && ((v14 = v10[2], v12 = v14 < (unsigned __int8)v9[2], v14 != v9[2])
        || v11 != -1 && (v15 = v10[3], v12 = v15 < (unsigned __int8)v9[3], v15 != v9[3]))) )
    {
      v16 = v12 ? -1 : 1;
      goto LABEL_18;
    }
LABEL_17:
    v16 = 0;
LABEL_18:
    if ( !v16 )
      return (int)&v8[-a1];
    v8 = (char *)memchr(v8 + 1, Val, v20 - (_DWORD)(v8 + 1));
    if ( !v8 )
      return -1;
    v7 = a4;
  }
}

//----- (10012DA0) --------------------------------------------------------
void __fastcall sub_10012DA0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *i; // esi

  for ( i = a1; i != a2; i += 12 )
    sub_10011720(i);
}

//----- (10012DD0) --------------------------------------------------------
const void **__thiscall sub_10012DD0(
        const void **Src,
        unsigned int a2,
        int a3,
        size_t Size,
        int a5,
        void *Srca,
        size_t a7)
{
  size_t v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // esi
  size_t v12; // ecx
  void *v13; // eax
  _DWORD *v14; // edi
  char *v15; // esi
  void *v17; // [esp+10h] [ebp-8h]
  char *v18; // [esp+10h] [ebp-8h]
  size_t v19; // [esp+14h] [ebp-4h]
  size_t v20; // [esp+14h] [ebp-4h]
  unsigned int v21; // [esp+20h] [ebp+8h]

  v8 = (size_t)Src[4];
  v19 = v8;
  if ( 0x7FFFFFFF - v8 < a2 )
    sub_100012E0();
  v9 = (unsigned int)Src[5];
  v17 = (void *)(v8 + a2);
  v10 = (v8 + a2) | 0xF;
  v21 = v9;
  if ( v10 > 0x7FFFFFFF )
  {
    v11 = 0x7FFFFFFF;
LABEL_4:
    v12 = -2147483613;
    goto LABEL_5;
  }
  if ( v9 > 0x7FFFFFFF - (v9 >> 1) )
  {
    v11 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  v11 = (v9 >> 1) + v9;
  if ( v10 >= v11 )
    v11 = v10;
  if ( v11 + 1 < 0x1000 )
  {
    if ( v11 == -1 )
      v14 = 0;
    else
      v14 = operator new(v11 + 1);
    goto LABEL_17;
  }
  v12 = v11 + 36;
  if ( v11 + 36 <= v11 + 1 )
    sub_10001240();
LABEL_5:
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_25;
  v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
  *(v14 - 1) = v13;
LABEL_17:
  Src[4] = v17;
  Src[5] = (const void *)v11;
  v20 = v19 - Size - a5 + 1;
  v18 = (char *)v14 + Size + a7;
  if ( v21 >= 0x10 )
  {
    v15 = (char *)*Src;
    memmove(v14, *Src, Size);
    memmove((char *)v14 + Size, Srca, a7);
    memmove(v18, &v15[Size + a5], v20);
    if ( v21 + 1 < 0x1000 )
    {
LABEL_21:
      sub_1001D481(v15);
      *Src = v14;
      return Src;
    }
    if ( (unsigned int)&v15[-*((_DWORD *)v15 - 1) - 4] <= 0x1F )
    {
      v15 = (char *)*((_DWORD *)v15 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v14, Src, Size);
  memmove((char *)v14 + Size, Srca, a7);
  memmove(v18, (char *)Src + a5 + Size, v20);
  *Src = v14;
  return Src;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10012F50) --------------------------------------------------------
const void **__thiscall sub_10012F50(const void **Src, unsigned int a2, int a3, size_t Size, void *Srca, size_t a6)
{
  size_t v7; // esi
  size_t v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // esi
  size_t v12; // ecx
  void *v13; // eax
  _DWORD *v14; // edi
  char *v15; // esi
  void *v17; // [esp+10h] [ebp-8h]
  char *v18; // [esp+10h] [ebp-8h]
  size_t v19; // [esp+14h] [ebp-4h]
  size_t v20; // [esp+14h] [ebp-4h]
  unsigned int v21; // [esp+20h] [ebp+8h]

  v7 = (size_t)Src[4];
  v19 = v7;
  if ( 0x7FFFFFFF - v7 < a2 )
    sub_100012E0();
  v8 = v7 + a2;
  v9 = (unsigned int)Src[5];
  v17 = (void *)v8;
  v10 = v8 | 0xF;
  v21 = v9;
  if ( v10 > 0x7FFFFFFF )
  {
    v11 = 0x7FFFFFFF;
LABEL_4:
    v12 = -2147483613;
    goto LABEL_5;
  }
  if ( v9 > 0x7FFFFFFF - (v9 >> 1) )
  {
    v11 = 0x7FFFFFFF;
    goto LABEL_4;
  }
  v11 = (v9 >> 1) + v9;
  if ( v10 >= v11 )
    v11 = v10;
  if ( v11 + 1 < 0x1000 )
  {
    if ( v11 == -1 )
      v14 = 0;
    else
      v14 = operator new(v11 + 1);
    goto LABEL_17;
  }
  v12 = v11 + 36;
  if ( v11 + 36 <= v11 + 1 )
    sub_10001240();
LABEL_5:
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_25;
  v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
  *(v14 - 1) = v13;
LABEL_17:
  Src[4] = v17;
  Src[5] = (const void *)v11;
  v20 = v19 - Size + 1;
  v18 = (char *)v14 + Size + a6;
  if ( v21 >= 0x10 )
  {
    v15 = (char *)*Src;
    memmove(v14, *Src, Size);
    memmove((char *)v14 + Size, Srca, a6);
    memmove(v18, &v15[Size], v20);
    if ( v21 + 1 < 0x1000 )
    {
LABEL_21:
      sub_1001D481(v15);
      *Src = v14;
      return Src;
    }
    if ( (unsigned int)&v15[-*((_DWORD *)v15 - 1) - 4] <= 0x1F )
    {
      v15 = (char *)*((_DWORD *)v15 - 1);
      goto LABEL_21;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v14, Src, Size);
  memmove((char *)v14 + Size, Srca, a6);
  memmove(v18, (char *)Src + Size, v20);
  *Src = v14;
  return Src;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10013120) --------------------------------------------------------
int __stdcall sub_10013120(int a1, int a2)
{
  int v2; // edx
  unsigned int v3; // ecx
  int v4; // eax

  v2 = -2128831035;
  v3 = 0;
  if ( a2 != a1 )
  {
    do
    {
      v4 = *(unsigned __int8 *)(v3 + a1);
      ++v3;
      v2 = 16777619 * (v2 ^ v4);
    }
    while ( v3 < a2 - a1 );
  }
  return v2;
}

//----- (10013160) --------------------------------------------------------
char *__thiscall sub_10013160(_Collvec *this, char *String1, char *a3, char *a4)
{
  const char *v5; // ebx
  size_t v6; // edx
  size_t v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // edx
  char *v10; // eax
  unsigned int v11; // ebx
  char *v12; // eax
  char *v13; // edi
  int v14; // eax
  char *v15; // eax
  char *v16; // edx
  size_t v17; // eax
  char *v18; // eax
  unsigned int v19; // edi
  unsigned int v20; // ebx
  char *v21; // eax
  char *v22; // edi
  size_t v24; // [esp-4h] [ebp-28h]
  _Collvec *v25; // [esp+Ch] [ebp-18h]
  int v26; // [esp+10h] [ebp-14h]

  *(_DWORD *)String1 = 0;
  *((_DWORD *)String1 + 1) = 0;
  *((_DWORD *)String1 + 2) = 0;
  *((_DWORD *)String1 + 3) = 0;
  *((_DWORD *)String1 + 4) = 0;
  *((_DWORD *)String1 + 5) = 15;
  *String1 = 0;
  v5 = a4;
  v6 = 0;
  v7 = a4 - a3;
  if ( a4 != a3 )
  {
    v8 = 0;
    v25 = this + 1;
    do
    {
      v9 = *((_DWORD *)String1 + 5);
      if ( v7 > v8 )
      {
        v11 = v7 - v8;
        if ( v7 - v8 > v9 - v8 )
        {
          LOBYTE(v26) = 0;
          sub_10006BA0((void **)String1, v11, v26, v7 - v8, 0);
        }
        else
        {
          *((_DWORD *)String1 + 4) = v7;
          v12 = String1;
          if ( v9 >= 0x10 )
            v12 = *(char **)String1;
          v24 = v7 - v8;
          v13 = &v12[v8];
          memset(v13, 0, v24);
          v13[v11] = 0;
        }
        v5 = a4;
      }
      else
      {
        v10 = String1;
        if ( v9 >= 0x10 )
          v10 = *(char **)String1;
        *((_DWORD *)String1 + 4) = v7;
        v10[v7] = 0;
      }
      v14 = *((_DWORD *)String1 + 4);
      if ( *((_DWORD *)String1 + 5) < 0x10u )
      {
        v15 = &String1[v14];
        v16 = String1;
      }
      else
      {
        v15 = (char *)(*(_DWORD *)String1 + v14);
        v16 = *(char **)String1;
      }
      v17 = _Strxfrm(v16, v15, a3, v5, v25);
      v6 = *((_DWORD *)String1 + 4);
      v7 = v17;
      if ( v17 <= v6 )
        goto LABEL_19;
      v8 = *((_DWORD *)String1 + 4);
    }
    while ( v17 );
  }
  if ( v7 <= v6 )
  {
LABEL_19:
    v18 = String1;
    if ( *((_DWORD *)String1 + 5) >= 0x10u )
      v18 = *(char **)String1;
    *((_DWORD *)String1 + 4) = v7;
    v18[v7] = 0;
    return String1;
  }
  v19 = *((_DWORD *)String1 + 5);
  v20 = v7 - v6;
  if ( v7 - v6 > v19 - v6 )
  {
    LOBYTE(a4) = 0;
    sub_10006BA0((void **)String1, v20, (int)a4, v7 - v6, 0);
  }
  else
  {
    *((_DWORD *)String1 + 4) = v7;
    v21 = String1;
    if ( v19 >= 0x10 )
      v21 = *(char **)String1;
    v22 = &v21[v6];
    memset(&v21[v6], 0, v7 - v6);
    v22[v20] = 0;
  }
  return String1;
}
// 1001321A: variable 'v26' is possibly undefined

//----- (100132D0) --------------------------------------------------------
int __thiscall sub_100132D0(const _Collvec *this, char *a2, char *a3, char *a4, char *a5)
{
  int v5; // eax

  v5 = _Strcoll(a2, a3, a4, a5, this + 1);
  if ( v5 >= 0 )
    return v5 != 0;
  else
    return -1;
}

//----- (10013310) --------------------------------------------------------
int __cdecl sub_10013310(_Collvec **a1, _DWORD *a2)
{
  _Collvec *v2; // ebx
  void **v3; // eax
  const char *v4; // esi
  bool v5; // cf
  _BYTE *v6; // edx
  char v8[4]; // [esp+4h] [ebp-5Ch] BYREF
  void *v9; // [esp+8h] [ebp-58h]
  char v10; // [esp+Ch] [ebp-54h]
  void *v11; // [esp+10h] [ebp-50h]
  char v12; // [esp+14h] [ebp-4Ch]
  void *v13; // [esp+18h] [ebp-48h]
  __int16 v14; // [esp+1Ch] [ebp-44h]
  void *v15; // [esp+20h] [ebp-40h]
  __int16 v16; // [esp+24h] [ebp-3Ch]
  void *v17; // [esp+28h] [ebp-38h]
  char v18; // [esp+2Ch] [ebp-34h]
  void *Block; // [esp+30h] [ebp-30h]
  char v20; // [esp+34h] [ebp-2Ch]
  void *v21; // [esp+38h] [ebp-28h] BYREF
  unsigned int v22; // [esp+4Ch] [ebp-14h]
  int v23; // [esp+50h] [ebp-10h]
  int v24; // [esp+5Ch] [ebp-4h]

  v23 = 0;
  if ( a1 && !*a1 )
  {
    v2 = (_Collvec *)operator new(0x10u);
    v24 = 0;
    v3 = sub_100082B0(a2, &v21);
    v4 = (const char *)v3;
    v5 = (unsigned int)v3[5] < 0x10;
    v23 = 1;
    if ( !v5 )
      v4 = (const char *)*v3;
    std::_Lockit::_Lockit((std::_Lockit *)v8, 0);
    v24 = 8;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    Block = 0;
    v20 = 0;
    if ( !v4 )
      sub_1001C06E((int)"bad locale name");
    std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)v8, v4);
    v2->_LocaleName = 0;
    v2->_Page = (unsigned int)&std::collate<char>::`vftable';
    v2[1] = _Getcoll();
    *a1 = v2;
    v23 = 1;
    v24 = 10;
    std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)v8);
    LOBYTE(v24) = 11;
    if ( Block )
      free(Block);
    Block = 0;
    LOBYTE(v24) = 12;
    if ( v17 )
      free(v17);
    v17 = 0;
    LOBYTE(v24) = 13;
    if ( v15 )
      free(v15);
    v15 = 0;
    LOBYTE(v24) = 14;
    if ( v13 )
      free(v13);
    v13 = 0;
    LOBYTE(v24) = 15;
    if ( v11 )
      free(v11);
    v11 = 0;
    LOBYTE(v24) = 16;
    if ( v9 )
      free(v9);
    v9 = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v8);
    if ( v22 >= 0x10 )
    {
      v6 = v21;
      if ( v22 + 1 >= 0x1000 )
      {
        v6 = (_BYTE *)*((_DWORD *)v21 - 1);
        if ( (unsigned int)((_BYTE *)v21 - v6 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_1001D481(v6);
    }
  }
  return 1;
}
// 1003F64C: using guessed type void *std::collate<char>::`vftable';
// 10013310: using guessed type char var_5C[4];

//----- (10013570) --------------------------------------------------------
void **__thiscall sub_10013570(void **this, int a2, void **a3, _DWORD *Src)
{
  void **v5; // edi
  _DWORD *v6; // ebx
  size_t v7; // edx
  unsigned int v8; // ecx
  int *v9; // ecx
  void *v10; // ebx
  unsigned int v11; // eax
  size_t v12; // eax
  void *v13; // eax
  _DWORD *v14; // ecx
  unsigned int v15; // ecx
  _DWORD *v16; // eax
  _DWORD *v17; // ebx
  _DWORD *v19; // [esp+Ch] [ebp-1Ch]
  size_t Size; // [esp+10h] [ebp-18h]
  unsigned int v21; // [esp+14h] [ebp-14h]
  int v22; // [esp+18h] [ebp-10h]
  char *v23; // [esp+34h] [ebp+Ch]

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  v5 = a3;
  v6 = Src;
  v7 = (size_t)a3[4];
  v8 = Src[5];
  v23 = (char *)Src[4];
  v21 = (unsigned int)&v23[v7];
  Size = v7;
  if ( v23 <= (char *)v5[5] - v7 && v8 <= (unsigned int)v5[5] )
  {
    v9 = (int *)this;
    *this = *v5;
    this[1] = v5[1];
    this[2] = v5[2];
    this[3] = v5[3];
    this[4] = v5[4];
    this[5] = v5[5];
    v5[4] = 0;
    v5[5] = (void *)15;
    *(_BYTE *)v5 = 0;
    if ( (unsigned int)this[5] >= 0x10 )
      v9 = (int *)*this;
    if ( Src[5] >= 0x10u )
      v6 = (_DWORD *)*Src;
    memmove((char *)v9 + v7, v6, (size_t)(v23 + 1));
    this[4] = (void *)v21;
    return this;
  }
  if ( v7 <= v8 - (unsigned int)v23 )
  {
    *this = (void *)*Src;
    this[1] = (void *)Src[1];
    this[2] = (void *)Src[2];
    this[3] = (void *)Src[3];
    this[4] = (void *)Src[4];
    this[5] = (void *)Src[5];
    Src[4] = 0;
    Src[5] = 15;
    *(_BYTE *)Src = 0;
    v10 = *this;
    memmove((char *)*this + v7, *this, (size_t)(v23 + 1));
    if ( (unsigned int)v5[5] >= 0x10 )
      v5 = (void **)*v5;
    memmove(v10, v5, Size);
    this[4] = (void *)v21;
    return this;
  }
  if ( 0x7FFFFFFF - v7 < (unsigned int)v23 )
    sub_100012E0();
  v11 = v21 | 0xF;
  v22 = v21 | 0xF;
  if ( (v21 | 0xF) > 0x7FFFFFFF )
  {
    v22 = 0x7FFFFFFF;
    v12 = -2147483613;
LABEL_15:
    v13 = operator new(v12);
    if ( !v13 )
      _invalid_parameter_noinfo_noreturn();
    v7 = Size;
    v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
    *(v14 - 1) = v13;
    v11 = v22;
    goto LABEL_25;
  }
  if ( v11 < 0x16 )
  {
    v11 = 22;
    v22 = 22;
  }
  v15 = v11 + 1;
  if ( v11 + 1 >= 0x1000 )
  {
    v12 = v11 + 36;
    if ( v15 + 35 <= v15 )
      sub_10001240();
    goto LABEL_15;
  }
  if ( v11 == -1 )
  {
    v14 = 0;
LABEL_25:
    v19 = v14;
    goto LABEL_26;
  }
  v16 = operator new(v11 + 1);
  v7 = Size;
  v14 = v16;
  v19 = v16;
  v11 = v22;
LABEL_26:
  this[4] = (void *)v21;
  v17 = Src;
  *this = v14;
  this[5] = (void *)v11;
  if ( (unsigned int)v5[5] >= 0x10 )
    v5 = (void **)*v5;
  memmove(v14, v5, v7);
  if ( Src[5] >= 0x10u )
    v17 = (_DWORD *)*Src;
  memmove((char *)v19 + Size, v17, (size_t)(v23 + 1));
  return this;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (100137A0) --------------------------------------------------------
_DWORD *__thiscall sub_100137A0(_DWORD *this, int a2, int a3, void *Src, size_t Size, void *a6, size_t a7)
{
  unsigned int v8; // esi
  size_t v9; // edx
  _DWORD *v10; // edi
  size_t v11; // ecx
  size_t v12; // ecx
  void *v13; // eax
  _DWORD *v14; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  v8 = 15;
  v9 = Size;
  v10 = this;
  v11 = Size + a7;
  if ( Size + a7 > 0xF )
  {
    v8 = v11 | 0xF;
    if ( (v11 | 0xF) <= 0x7FFFFFFF )
    {
      if ( v8 < 0x16 )
        v8 = 22;
      if ( v8 + 1 < 0x1000 )
      {
        if ( v8 == -1 )
        {
          v10 = 0;
        }
        else
        {
          v14 = operator new(v8 + 1);
          v11 = Size + a7;
          v9 = Size;
          v10 = v14;
        }
LABEL_14:
        *this = v10;
        goto LABEL_15;
      }
      v12 = v8 + 36;
      if ( v8 + 36 <= v8 + 1 )
        sub_10001240();
    }
    else
    {
      v8 = 0x7FFFFFFF;
      v12 = -2147483613;
    }
    v13 = operator new(v12);
    if ( !v13 )
      _invalid_parameter_noinfo_noreturn();
    v11 = Size + a7;
    v9 = Size;
    v10 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
    *(v10 - 1) = v13;
    goto LABEL_14;
  }
LABEL_15:
  this[4] = v11;
  this[5] = v8;
  memmove(v10, Src, v9);
  memmove((char *)v10 + Size, a6, a7);
  *((_BYTE *)v10 + Size + a7) = 0;
  return this;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);

//----- (100138B0) --------------------------------------------------------
_DWORD *__thiscall sub_100138B0(_DWORD *Block, char a2)
{
  void *v4; // [esp-4h] [ebp-14h]

  v4 = (void *)Block[3];
  *Block = &std::collate<char>::`vftable';
  free(v4);
  *Block = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1003F318: using guessed type void *std::_Facet_base::`vftable';
// 1003F64C: using guessed type void *std::collate<char>::`vftable';

//----- (10013920) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_DWORD *__thiscall sub_10013920(_DWORD *this, _BYTE *Src, _BYTE *a3, int a4)
{
  _DWORD *result; // eax
  size_t v6; // edi
  unsigned int v7; // ebx
  size_t v8; // ecx
  void *v9; // eax
  void *v10; // ecx
  _DWORD *v11; // eax
  int v12; // [esp+24h] [ebp+Ch]

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  if ( Src == a3 )
  {
    this[4] = 0;
    result = this;
    this[5] = 15;
    *(_BYTE *)this = 0;
    return result;
  }
  v6 = a3 - Src;
  if ( (unsigned int)(a3 - Src) > 0x7FFFFFFF )
    sub_100012E0();
  this[5] = 15;
  if ( v6 < 0x10 )
  {
    this[4] = v6;
    memmove(this, Src, v6);
    *((_BYTE *)this + v6) = 0;
    return this;
  }
  v7 = v6 | 0xF;
  if ( (v6 | 0xF) > 0x7FFFFFFF )
  {
    v7 = 0x7FFFFFFF;
    v8 = -2147483613;
LABEL_8:
    v9 = operator new(v8);
    v10 = v9;
    if ( !v9 )
      _invalid_parameter_noinfo_noreturn();
    v11 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
    *(v11 - 1) = v10;
    goto LABEL_18;
  }
  if ( v7 < 0x16 )
    v7 = 22;
  if ( v7 + 1 >= 0x1000 )
  {
    v8 = v7 + 36;
    if ( v7 + 36 <= v7 + 1 )
      sub_10001240();
    goto LABEL_8;
  }
  if ( v7 == -1 )
    v11 = 0;
  else
    v11 = operator new(v7 + 1);
LABEL_18:
  v12 = (int)v11;
  *this = v11;
  this[4] = v6;
  this[5] = v7;
  memmove(v11, Src, v6);
  *(_BYTE *)(v12 + v6) = 0;
  return this;
}
// 10013A5C: bad sp value at call
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 100012E0: using guessed type void __noreturn sub_100012E0(void);

//----- (10013A70) --------------------------------------------------------
char __fastcall sub_10013A70(int a1, char *a2, int a3, int *a4, unsigned int a5, int a6)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // eax
  int v9; // esi
  int v10; // edx
  int v12; // eax
  int v13; // edi
  int v14; // ecx
  unsigned int v15; // eax
  int v16; // ecx
  int v17; // esi
  bool v18; // zf
  _BYTE *v19; // edx
  _BYTE *v20; // edx
  _BYTE *v21; // edx
  _BYTE *v22; // edx
  void *v23; // edx
  int v24; // [esp+0h] [ebp-94h] BYREF
  void *v25; // [esp+4h] [ebp-90h]
  int v26; // [esp+8h] [ebp-8Ch]
  int v27; // [esp+Ch] [ebp-88h]
  int v28; // [esp+10h] [ebp-84h]
  void *v29; // [esp+14h] [ebp-80h]
  int v30; // [esp+18h] [ebp-7Ch]
  int v31; // [esp+1Ch] [ebp-78h]
  void *v32; // [esp+24h] [ebp-70h]
  int v33; // [esp+28h] [ebp-6Ch]
  int v34; // [esp+2Ch] [ebp-68h]
  int v35; // [esp+30h] [ebp-64h]
  void *v36; // [esp+34h] [ebp-60h]
  int v37; // [esp+38h] [ebp-5Ch]
  int v38; // [esp+3Ch] [ebp-58h]
  void *Block; // [esp+40h] [ebp-54h] BYREF
  int v40; // [esp+44h] [ebp-50h]
  int v41; // [esp+48h] [ebp-4Ch]
  char *v42; // [esp+50h] [ebp-44h]
  char *v43; // [esp+54h] [ebp-40h]
  int v44; // [esp+58h] [ebp-3Ch]
  int v45; // [esp+5Ch] [ebp-38h]
  unsigned int v46; // [esp+60h] [ebp-34h]
  char v47; // [esp+64h] [ebp-30h]
  int v48; // [esp+68h] [ebp-2Ch]
  char v49; // [esp+6Ch] [ebp-28h]
  int v50; // [esp+70h] [ebp-24h]
  int v51; // [esp+84h] [ebp-10h]
  struct _EXCEPTION_REGISTRATION_RECORD *v52; // [esp+88h] [ebp-Ch]
  void *v53; // [esp+8Ch] [ebp-8h]
  int v54; // [esp+90h] [ebp-4h]
  char v55; // [esp+A3h] [ebp+Fh]

  v54 = -1;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v53 = &loc_1003D62B;
  v52 = ExceptionList;
  v9 = a1;
  v10 = *a4;
  if ( !*a4 )
    return 0;
  v55 = 0;
  v51 = a1;
  if ( (a5 & 0x4000) != 0 && (char *)a1 != a2 )
    v9 = a1 + 1;
  v12 = *(_DWORD *)(v10 + 20);
  v13 = (int)(a4 + 1);
  v14 = *(_DWORD *)(v10 + 28);
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v54 = 2;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  Block = 0;
  v40 = 0;
  v41 = 0;
  v45 = v12;
  v42 = a2;
  v43 = (char *)v9;
  v44 = v10;
  v46 = a5;
  v47 = 0;
  v48 = v14;
  if ( (*(_BYTE *)(v10 + 8) & 8) == 0 || (v49 = 1, (a5 & 0x10) != 0) )
    v49 = 0;
  v50 = v13;
  v15 = *(_DWORD *)(v10 + 24);
  if ( v15 )
    sub_100167D0((int)&Block, v15, v14);
  v54 = 3;
  if ( !sub_10014E00((int)&v24, a3, v14) )
  {
    if ( (char *)v9 == a2 || (a5 & 0x40) != 0 )
      goto LABEL_20;
    v46 = v46 & 0xFFFFDEFF | 0x100;
    v17 = sub_10014B80(&v24, (char *)(v9 + 1), a2, 0);
    if ( (char *)v17 == a2 )
    {
LABEL_17:
      v43 = a2;
      if ( !sub_10014E00((int)&v24, a3, v16) )
        goto LABEL_20;
    }
    else
    {
      while ( 1 )
      {
        v43 = (char *)v17;
        if ( sub_10014E00((int)&v24, a3, v16) )
          break;
        v17 = sub_10014B80(&v24, (char *)(v17 + 1), a2, 0);
        if ( (char *)v17 == a2 )
          goto LABEL_17;
      }
    }
  }
  v55 = 1;
  if ( a3 )
  {
    *(_DWORD *)a3 = a6;
    v18 = v51 == *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 20) = v51;
    *(_BYTE *)(a3 + 28) = !v18;
  }
LABEL_20:
  v19 = Block;
  if ( Block )
  {
    if ( ((v41 - (_DWORD)Block) & 0xFFFFFFF8) >= 0x1000 )
    {
      v19 = (_BYTE *)*((_DWORD *)Block - 1);
      if ( (unsigned int)((_BYTE *)Block - v19 - 4) > 0x1F )
        goto LABEL_41;
    }
    sub_1001D481(v19);
    Block = 0;
    v40 = 0;
    v41 = 0;
  }
  v20 = v36;
  if ( v36 )
  {
    if ( ((v38 - (_DWORD)v36) & 0xFFFFFFF8) >= 0x1000 )
    {
      v20 = (_BYTE *)*((_DWORD *)v36 - 1);
      if ( (unsigned int)((_BYTE *)v36 - v20 - 4) > 0x1F )
        goto LABEL_41;
    }
    sub_1001D481(v20);
    v36 = 0;
    v37 = 0;
    v38 = 0;
  }
  v21 = v32;
  if ( v32 )
  {
    if ( ((v34 - (_DWORD)v32) & 0xFFFFFFFC) >= 0x1000 )
    {
      v21 = (_BYTE *)*((_DWORD *)v32 - 1);
      if ( (unsigned int)((_BYTE *)v32 - v21 - 4) > 0x1F )
        goto LABEL_41;
    }
    sub_1001D481(v21);
    v32 = 0;
    v33 = 0;
    v34 = 0;
  }
  v22 = v29;
  if ( v29 )
  {
    if ( ((v31 - (_DWORD)v29) & 0xFFFFFFF8) >= 0x1000 )
    {
      v22 = (_BYTE *)*((_DWORD *)v29 - 1);
      if ( (unsigned int)((_BYTE *)v29 - v22 - 4) > 0x1F )
        goto LABEL_41;
    }
    sub_1001D481(v22);
    v29 = 0;
    v30 = 0;
    v31 = 0;
  }
  v23 = v25;
  if ( v25 )
  {
    if ( ((v27 - (_DWORD)v25) & 0xFFFFFFFC) < 0x1000
      || (v23 = (void *)*((_DWORD *)v25 - 1), (unsigned int)((_BYTE *)v25 - (_BYTE *)v23 - 4) <= 0x1F) )
    {
      sub_1001D481(v23);
      return v55;
    }
LABEL_41:
    _invalid_parameter_noinfo_noreturn();
  }
  return v55;
}
// 10013BAE: variable 'v14' is possibly undefined
// 10013BFC: variable 'v16' is possibly undefined

//----- (10013DD0) --------------------------------------------------------
int __thiscall sub_10013DD0(int *this, int a2, _DWORD *Src)
{
  int v4; // esi
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // esi
  unsigned int v12; // eax
  void *v13; // eax
  _DWORD *v14; // edi
  int v15; // eax
  _DWORD *v16; // esi
  int v17; // ecx
  int v18; // edx
  _DWORD *v19; // esi
  _DWORD *v20; // esi
  int v21; // eax
  int v22; // ecx
  int result; // eax
  _DWORD *v24; // [esp-8h] [ebp-40h]
  _DWORD v25[5]; // [esp+0h] [ebp-38h] BYREF
  unsigned int v26; // [esp+14h] [ebp-24h]
  int v27; // [esp+18h] [ebp-20h]
  int v28; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v30; // [esp+24h] [ebp-14h]
  _DWORD *v31; // [esp+28h] [ebp-10h]
  int v32; // [esp+34h] [ebp-4h]
  int i; // [esp+40h] [ebp+8h]

  v31 = v25;
  v4 = *this;
  v5 = a2 - *this;
  v6 = this[1] - *this;
  v28 = v5 / 48;
  v27 = v6 / 48;
  if ( v6 / 48 == 89478485 )
    sub_10008240();
  v7 = v6 / 48;
  v8 = v6 / 48 + 1;
  v9 = (this[2] - v4) / 48;
  v10 = v9 >> 1;
  if ( v9 > 89478485 - (v9 >> 1) )
    goto LABEL_24;
  v11 = v10 + v9;
  if ( v10 + v9 < v8 )
    v11 = v7 + 1;
  if ( v11 > 0x5555555 )
    goto LABEL_24;
  v30 = v11;
  v12 = 48 * v11;
  v26 = 48 * v11;
  if ( 48 * v11 < 0x1000 )
  {
    if ( v12 )
      v14 = operator new(48 * v11);
    else
      v14 = 0;
    v30 = v11;
    goto LABEL_14;
  }
  if ( v12 + 35 <= v12 )
LABEL_24:
    sub_10001240();
  v13 = operator new(v12 + 35);
  if ( !v13 )
    goto LABEL_26;
  v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
  *(v14 - 1) = v13;
LABEL_14:
  v15 = v28;
  v32 = 0;
  Block = v14;
  v28 = (int)&v14[12 * v28];
  v16 = (_DWORD *)v28;
  v25[3] = &v14[12 * v15];
  v25[4] = v28 + 48;
  sub_10001AF0((_DWORD *)v28, Src);
  LOBYTE(v32) = 1;
  sub_10001AF0(v16 + 6, Src + 6);
  v17 = *this;
  v18 = this[1];
  v24 = v14;
  if ( a2 != v18 )
  {
    sub_10014FA0(v17, a2, v14);
    v18 = this[1];
    v17 = a2;
    v24 = v16 + 12;
  }
  sub_10014FA0(v17, v18, v24);
  v19 = (_DWORD *)*this;
  if ( *this )
  {
    for ( i = this[1]; v19 != (_DWORD *)i; v19 += 12 )
      sub_10011720(v19);
    v20 = (_DWORD *)*this;
    if ( (unsigned int)(48 * ((this[2] - *this) / 48)) < 0x1000 )
      goto LABEL_22;
    if ( (unsigned int)v20 - *(v20 - 1) - 4 <= 0x1F )
    {
      v20 = (_DWORD *)*(v20 - 1);
LABEL_22:
      sub_1001D481(v20);
      goto LABEL_23;
    }
LABEL_26:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_23:
  v21 = v27 + 1;
  *this = (int)v14;
  v22 = 3 * v21;
  result = v28;
  this[1] = (int)&v14[4 * v22];
  this[2] = (int)&v14[v26 / 4];
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10014000) --------------------------------------------------------
_DWORD *__thiscall sub_10014000(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edi
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  _DWORD *v8; // ecx
  int v9; // eax
  _DWORD *v10; // esi
  int v12; // [esp+14h] [ebp-10h]

  v2 = this + 9;
  v3 = operator new(0x18u);
  v3[4] = 0;
  v3[1] = 13;
  v3[2] = 0;
  v3[3] = 0;
  *v3 = &std::_Node_capture::`vftable';
  v3[5] = 0;
  v3[4] = v2[1];
  v4 = *(_DWORD *)(v2[1] + 12);
  if ( v4 )
  {
    v3[3] = v4;
    *(_DWORD *)(*(_DWORD *)(v2[1] + 12) + 16) = v3;
  }
  *(_DWORD *)(v2[1] + 12) = v3;
  v2[1] = v3;
  sub_10014620((int)this);
  if ( *this != this[2] )
    sub_100143C0(14);
  v5 = v3[1];
  if ( v5 == 8 )
  {
    v12 = 9;
  }
  else if ( v5 == 10 || (v12 = 14, v5 == 11) )
  {
    v12 = 12;
  }
  v6 = operator new(0x18u);
  v6[4] = 0;
  v6[1] = v12;
  v6[2] = 0;
  v6[3] = 0;
  *v6 = &std::_Node_end_group::`vftable';
  v6[5] = v3;
  v6[4] = v2[1];
  v7 = *(_DWORD *)(v2[1] + 12);
  if ( v7 )
  {
    v6[3] = v7;
    *(_DWORD *)(*(_DWORD *)(v2[1] + 12) + 16) = v6;
  }
  *(_DWORD *)(v2[1] + 12) = v6;
  v2[1] = v6;
  v8 = operator new(0x14u);
  v8[4] = 0;
  *v8 = &std::_Node_base::`vftable';
  v8[1] = 21;
  v8[2] = 0;
  v8[3] = 0;
  v8[4] = v2[1];
  v9 = *(_DWORD *)(v2[1] + 12);
  if ( v9 )
  {
    v8[3] = v9;
    *(_DWORD *)(*(_DWORD *)(v2[1] + 12) + 16) = v8;
  }
  *(_DWORD *)(v2[1] + 12) = v8;
  v2[1] = v8;
  v10 = (_DWORD *)*v2;
  v10[5] = this[16];
  v10[7] = this[3] + 1;
  sub_10008770(v10, 0, 0);
  return v10;
}
// 1004A9C0: using guessed type void *std::_Node_capture::`vftable';
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004C204: using guessed type void *std::_Node_end_group::`vftable';

//----- (10014220) --------------------------------------------------------
void __thiscall sub_10014220(_DWORD *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax

  v2 = (_DWORD *)this[5];
  if ( v2 )
  {
    if ( ((this[7] - (_DWORD)v2) & 0xFFFFFFF8) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_1001D481(v2);
    this[5] = 0;
    this[6] = 0;
    this[7] = 0;
  }
  v3 = (_DWORD *)this[1];
  if ( !v3 )
    return;
  if ( ((this[3] - (_DWORD)v3) & 0xFFFFFFFC) >= 0x1000 )
  {
    if ( (unsigned int)v3 - *(v3 - 1) - 4 <= 0x1F )
    {
      v3 = (_DWORD *)*(v3 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_1001D481(v3);
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
}

//----- (100143B0) --------------------------------------------------------
void __noreturn sub_100143B0()
{
  sub_1001C00E((int)"vector<bool> too long");
}
// 100143B0: using guessed type void __noreturn sub_100143B0();

//----- (100143C0) --------------------------------------------------------
void __cdecl __noreturn sub_100143C0(int a1)
{
  std::_Xregex_error(a1);
}
// 1001C04E: using guessed type void __cdecl __noreturn std::_Xregex_error(_DWORD);

//----- (100143D0) --------------------------------------------------------
int __thiscall sub_100143D0(_BYTE *this)
{
  int v2; // eax
  char v3; // cl
  char v4; // al
  char *v5; // eax
  int result; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // ecx

  if ( *(_DWORD *)this == *((_DWORD *)this + 2) )
  {
    v2 = -1;
    this[72] = -1;
    v3 = -1;
  }
  else
  {
    v4 = **(_BYTE **)this;
    this[72] = v4;
    v5 = strchr("()$^.*+?[]|\\-{},:=!\n\r\b", v4);
    v3 = this[72];
    if ( v5 )
      v2 = v3;
    else
      v2 = 0;
  }
  *((_DWORD *)this + 19) = v2;
  result = v3 - 10;
  switch ( v3 )
  {
    case 10:
      if ( (this[80] & 4) != 0 && !*((_DWORD *)this + 4) )
        *((_DWORD *)this + 19) = 124;
      break;
    case 36:
      if ( (*((_DWORD *)this + 20) & 0x2000000) != 0 )
      {
        result = *(_DWORD *)this + 1;
        if ( result != *((_DWORD *)this + 2) && *(_BYTE *)result != 10 )
          *((_DWORD *)this + 19) = 0;
      }
      break;
    case 40:
    case 41:
      if ( (this[80] & 8) == 0 )
        *((_DWORD *)this + 19) = 0;
      break;
    case 42:
      if ( (*((_DWORD *)this + 20) & 0x4000000) != 0 )
      {
        v8 = *((_DWORD *)this + 10);
        result = *(_DWORD *)(v8 + 4);
        switch ( result )
        {
          case 20:
            goto LABEL_30;
          case 8:
            goto LABEL_30;
          case 13:
            goto LABEL_30;
          case 2:
            result = *(_DWORD *)(*(_DWORD *)(v8 + 16) + 4);
            if ( result == 20 || result == 8 || result == 13 )
              goto LABEL_30;
            break;
        }
      }
      break;
    case 43:
    case 63:
      if ( (this[80] & 1) == 0 )
        *((_DWORD *)this + 19) = 0;
      break;
    case 92:
      result = *(_DWORD *)this + 1;
      if ( result != *((_DWORD *)this + 2) )
      {
        if ( (v7 = *((_DWORD *)this + 20), (v7 & 8) == 0) && (*(_BYTE *)result == 40 || *(_BYTE *)result == 41)
          || (v7 & 0x10) == 0 && (*(_BYTE *)result == 123 || *(_BYTE *)result == 125) )
        {
          LOBYTE(result) = *(_BYTE *)result;
          this[72] = result;
          result = (char)result;
          *((_DWORD *)this + 19) = (char)result;
        }
      }
      break;
    case 94:
      if ( (*((_DWORD *)this + 20) & 0x2000000) != 0 )
      {
        v9 = *((_DWORD *)this + 10);
        result = *(_DWORD *)(v9 + 4);
        if ( result != 20 && result != 8 && result != 13 )
        {
          if ( result == 2 )
          {
            result = *(_DWORD *)(*(_DWORD *)(v9 + 16) + 4);
            if ( result != 20 && result != 8 && result != 13 )
              *((_DWORD *)this + 19) = 0;
          }
          else
          {
LABEL_30:
            *((_DWORD *)this + 19) = 0;
          }
        }
      }
      break;
    case 123:
    case 125:
      if ( (this[80] & 0x10) == 0 )
        *((_DWORD *)this + 19) = 0;
      break;
    case 124:
      result = -((this[80] & 2) != 0);
      *((_DWORD *)this + 19) &= result;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10014620) --------------------------------------------------------
char __thiscall sub_10014620(int this)
{
  _DWORD *v2; // ebx
  char result; // al
  _DWORD *v4; // edx
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // eax
  int v8; // esi
  int v9; // ecx
  _BYTE *v10; // eax
  _BYTE *v11; // edx
  _BYTE *v12; // ecx
  int v13; // edx
  _DWORD *v14; // ecx
  int v15; // eax
  int v16; // esi
  int v17; // eax
  int v18; // eax
  int i; // eax
  int v20; // eax
  _DWORD *v21; // [esp+Ch] [ebp-14h]
  _DWORD *v22; // [esp+10h] [ebp-10h]
  int v23; // [esp+14h] [ebp-Ch]
  _DWORD *v24; // [esp+18h] [ebp-8h]
  int v25; // [esp+18h] [ebp-8h]
  _DWORD *v26; // [esp+1Ch] [ebp-4h]

  v2 = (_DWORD *)(this + 76);
  v23 = *(_DWORD *)(this + 40);
  v21 = (_DWORD *)(this + 76);
  result = sub_10015AC0(this);
  if ( result )
  {
    v21 = v2;
  }
  else
  {
    if ( *v2 != 124 )
      return result;
    v4 = operator new(0x14u);
    v4[4] = 0;
    *v4 = &std::_Node_base::`vftable';
    v4[1] = 8;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = *(_DWORD *)(this + 40);
    v5 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
    if ( v5 )
    {
      v4[3] = v5;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v4;
    }
    *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v4;
    *(_DWORD *)(this + 40) = v4;
    sub_100148C0((_DWORD *)(this + 36), (int)v4);
  }
  v6 = operator new(0x14u);
  v22 = v6;
  v6[4] = 0;
  v6[1] = 17;
  v6[2] = 0;
  v6[3] = 0;
  *v6 = &std::_Node_endif::`vftable';
  v6[4] = *(_DWORD *)(this + 40);
  v7 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
  if ( v7 )
  {
    v6[3] = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v6;
  }
  *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v6;
  *(_DWORD *)(this + 40) = v6;
  v24 = operator new(0x1Cu);
  v24[5] = v6;
  v8 = v23;
  v24[1] = 16;
  v24[2] = 0;
  v24[3] = 0;
  v24[4] = 0;
  *v24 = &std::_Node_if::`vftable';
  v24[6] = 0;
  v9 = *(_DWORD *)(v23 + 12);
  *(_DWORD *)(*(_DWORD *)(v9 + 16) + 12) = v24;
  v24[4] = *(_DWORD *)(v9 + 16);
  result = (char)v21;
  *(_DWORD *)(v9 + 16) = v24;
  v24[3] = v9;
  if ( *v21 == 124 )
  {
    while ( 1 )
    {
      v10 = *(_BYTE **)this;
      v11 = *(_BYTE **)(this + 8);
      if ( *(_BYTE **)this != v11 )
        break;
LABEL_22:
      sub_100143D0((_BYTE *)this);
      if ( !sub_10015AC0(this) )
      {
        v14 = operator new(0x14u);
        v14[4] = 0;
        *v14 = &std::_Node_base::`vftable';
        v14[1] = 8;
        v14[2] = 0;
        v14[3] = 0;
        v14[4] = *(_DWORD *)(this + 40);
        v15 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
        if ( v15 )
        {
          v14[3] = v15;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v14;
        }
        *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v14;
        *(_DWORD *)(this + 40) = v14;
        sub_100148C0((_DWORD *)(this + 36), (int)v14);
      }
      v16 = *(_DWORD *)(v8 + 12);
      v17 = v22[3];
      v22[3] = 0;
      v25 = v17;
      v18 = *(_DWORD *)(this + 40);
      *(_DWORD *)(this + 40) = v22;
      v22[3] = 0;
      *(_DWORD *)(v18 + 12) = v22;
      for ( i = *(_DWORD *)(v16 + 24); i; i = *(_DWORD *)(i + 24) )
        v16 = i;
      v26 = operator new(0x1Cu);
      v26[5] = v22;
      v26[1] = 16;
      v26[2] = 0;
      v26[3] = 0;
      v26[4] = 0;
      *v26 = &std::_Node_if::`vftable';
      v26[6] = 0;
      *(_DWORD *)(v16 + 24) = v26;
      v26[3] = v25;
      v20 = *(_DWORD *)(v16 + 24);
      v8 = v23;
      *(_DWORD *)(v25 + 16) = v20;
      result = (char)v21;
      if ( *v21 != 124 )
        return result;
    }
    if ( *v10 != 92 || (v12 = v10 + 1, v10 + 1 == v11) )
    {
LABEL_21:
      *(_DWORD *)this = v10 + 1;
      goto LABEL_22;
    }
    v13 = *(_DWORD *)(this + 80);
    if ( (v13 & 8) == 0 )
    {
      if ( *v12 == 40 || *v12 == 41 )
      {
LABEL_20:
        v10 = v12;
        goto LABEL_21;
      }
      v10 = *(_BYTE **)this;
    }
    if ( (v13 & 0x10) != 0 || *v12 != 123 && *v12 != 125 )
      goto LABEL_21;
    goto LABEL_20;
  }
  return result;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004C0A0: using guessed type void *std::_Node_endif::`vftable';
// 1004C0DC: using guessed type void *std::_Node_if::`vftable';

//----- (100148C0) --------------------------------------------------------
int __thiscall sub_100148C0(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // edi
  _DWORD *v5; // ecx
  int v6; // eax
  int result; // eax

  v3 = *(_DWORD *)(a2 + 4);
  if ( v3 == 8 )
  {
    v4 = 9;
  }
  else if ( v3 == 10 || (v4 = 14, v3 == 11) )
  {
    v4 = 12;
  }
  v5 = operator new(0x18u);
  v5[4] = 0;
  v5[1] = v4;
  v5[2] = 0;
  v5[3] = 0;
  *v5 = &std::_Node_end_group::`vftable';
  v5[5] = a2;
  v5[4] = this[1];
  v6 = *(_DWORD *)(this[1] + 12);
  if ( v6 )
  {
    v5[3] = v6;
    *(_DWORD *)(*(_DWORD *)(this[1] + 12) + 16) = v5;
  }
  result = this[1];
  *(_DWORD *)(result + 12) = v5;
  this[1] = v5;
  return result;
}
// 1004C204: using guessed type void *std::_Node_end_group::`vftable';

//----- (10014950) --------------------------------------------------------
void ***__fastcall sub_10014950(void ***a1, char *a2, void **Src, char *a4, int *a5, char *a6, int a7)
{
  __int16 v8; // di
  int v9; // esi
  int v10; // eax
  void **v11; // eax
  int v12; // ecx
  char *v13; // ecx
  char *v14; // edx
  void ***v15; // eax
  int *v16; // ebx
  int *v17; // esi
  int v18; // eax
  char *v19; // ecx
  int *v20; // eax
  int v21; // ecx
  int v22; // edx
  bool v23; // zf
  void **v24; // eax
  void ***v25; // edi
  int *v26; // eax
  int v28; // [esp+Ch] [ebp-60h] BYREF
  char v29; // [esp+10h] [ebp-5Ch]
  void *Block; // [esp+14h] [ebp-58h]
  int v31; // [esp+18h] [ebp-54h]
  int v32; // [esp+1Ch] [ebp-50h]
  char *v33; // [esp+20h] [ebp-4Ch]
  int v34; // [esp+24h] [ebp-48h]
  char v35; // [esp+28h] [ebp-44h]
  int v36; // [esp+2Ch] [ebp-40h]
  int v37; // [esp+30h] [ebp-3Ch]
  char v38; // [esp+34h] [ebp-38h]
  int v39[2]; // [esp+38h] [ebp-34h] BYREF
  char v40; // [esp+40h] [ebp-2Ch]
  char v41[4]; // [esp+44h] [ebp-28h] BYREF
  void **v42; // [esp+48h] [ebp-24h] BYREF
  void **v43; // [esp+4Ch] [ebp-20h] BYREF
  void ***v44; // [esp+50h] [ebp-1Ch]
  int v45; // [esp+54h] [ebp-18h]
  void **v46; // [esp+58h] [ebp-14h]
  int v47; // [esp+5Ch] [ebp-10h]
  int v48; // [esp+68h] [ebp-4h]

  v44 = a1;
  v28 = 0;
  v29 = 0;
  Block = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39[0] = 0;
  v39[1] = 0;
  v40 = 0;
  v48 = 0;
  v8 = a7;
  LOWORD(v9) = a7;
  v47 = a7;
  if ( sub_10013A70((int)a2, a4, (int)&v28, a5, a7, (int)a2) )
  {
    v10 = v8 & 0x800;
    v45 = v10;
    while ( 1 )
    {
      if ( v10 )
        v11 = Src;
      else
        v11 = *sub_100165F0(&v43, v33, (char *)v34, Src);
      v12 = *((_DWORD *)a6 + 4);
      if ( *((_DWORD *)a6 + 5) < 0x10u )
      {
        v13 = &a6[v12];
        v14 = a6;
      }
      else
      {
        v13 = (char *)(*(_DWORD *)a6 + v12);
        v14 = *(char **)a6;
      }
      if ( (v9 & 0x400) != 0 )
        v15 = sub_100176E0(&v42, (int)&v28, v11, v14, v13);
      else
        v15 = sub_10017850((unsigned int)v41, (int)&v28, v11, v14, v13);
      v16 = v39;
      v17 = (int *)Block;
      v46 = *v15;
      Src = v46;
      v18 = (v31 - (int)Block) / 12;
      if ( v18 )
        v16 = (int *)Block;
      a2 = (char *)v16[1];
      v19 = a4;
      if ( a2 == a4 || (a7 & 0x1000) != 0 )
        break;
      if ( v18 )
      {
        v20 = (int *)Block;
      }
      else
      {
        v17 = v39;
        v20 = v39;
      }
      v21 = *v17;
      v22 = v20[1];
      v9 = v47;
      if ( v21 != v22 )
      {
        v9 = v47 | 0x100;
        v47 |= 0x100u;
      }
      v23 = sub_10013A70((int)a2, a4, (int)&v28, a5, v9 | (v21 != v22 ? 0 : 0x2000), (int)a2) == 0;
      v10 = v45;
      if ( v23 )
        goto LABEL_22;
    }
    v24 = v46;
  }
  else
  {
LABEL_22:
    v24 = Src;
    v17 = (int *)Block;
    v19 = a4;
  }
  if ( (a7 & 0x800) == 0 )
    v24 = *sub_100165F0((void ***)&a7, a2, v19, v24);
  v25 = v44;
  *v44 = v24;
  if ( v17 )
  {
    v26 = v17;
    if ( (unsigned int)(12 * ((v32 - (int)v17) / 12)) >= 0x1000 )
    {
      v17 = (int *)*(v17 - 1);
      if ( (unsigned int)((char *)v26 - (char *)v17 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v17);
  }
  return v25;
}
// 10014950: using guessed type char var_28[4];

//----- (10014B80) --------------------------------------------------------
int __thiscall sub_10014B80(_DWORD *this, char *a2, char *a3, int a4)
{
  int v4; // edi
  int v5; // edx
  char *v6; // esi
  char *v7; // ebx
  char *v9; // ecx
  bool v10; // zf
  int v11; // ebx
  bool v12; // cl
  int v13; // ecx
  unsigned __int8 v14; // bl
  _DWORD *v15; // eax
  void *v16; // ecx
  void **v17; // eax
  unsigned int v18; // edx
  unsigned int v19; // eax
  int v20; // ecx
  char *v21; // eax
  unsigned __int8 v22; // [esp+13h] [ebp-2Dh]
  unsigned __int8 v23; // [esp+14h] [ebp-2Ch] BYREF
  _BYTE v24[3]; // [esp+15h] [ebp-2Bh] BYREF
  _DWORD *v25; // [esp+18h] [ebp-28h]
  char *v26; // [esp+1Ch] [ebp-24h]
  int v27; // [esp+20h] [ebp-20h]
  int v28; // [esp+24h] [ebp-1Ch]
  void *Block[5]; // [esp+28h] [ebp-18h] BYREF
  unsigned int v30; // [esp+3Ch] [ebp-4h]

  v4 = a4;
  v5 = (int)this;
  v25 = this;
  if ( !a4 )
    v4 = this[22];
  v6 = a2;
  v7 = a3;
  if ( a2 != a3 )
  {
    while ( 2 )
    {
      if ( v4 )
      {
        switch ( *(_DWORD *)(v4 + 4) )
        {
          case 1:
          case 8:
          case 9:
          case 0xD:
          case 0xE:
          case 0x14:
            v4 = *(_DWORD *)(v4 + 12);
            continue;
          case 2:
            if ( *(a2 - 1) != 10 )
            {
              do
              {
                if ( *v6 == 10 )
                  break;
                ++v6;
              }
              while ( v6 != a3 );
              if ( v6 != a3 )
                ++v6;
            }
            return (int)v6;
          case 3:
            while ( *v6 != 10 )
            {
              if ( ++v6 == a3 )
                return (int)v6;
            }
            return (int)v6;
          case 6:
            while ( 1 )
            {
              v9 = *(char **)(v4 + 28);
              v26 = v6 + 1;
              if ( sub_10016660(v6, v6 + 1, v9, v9 + 1, v25[28], (char *)v25[23]) != v6 )
                break;
              v6 = v26;
              if ( v26 == a3 )
                return (int)v26;
            }
            return (int)v6;
          case 7:
LABEL_20:
            v10 = (*(_DWORD *)(v5 + 92) & 0x100) == 0;
            v22 = *v6;
            LOBYTE(v27) = *v6;
            if ( !v10 )
              v22 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*(_DWORD *)(v5 + 112) + 4) + 16))(
                      *(_DWORD *)(*(_DWORD *)(v5 + 112) + 4),
                      v27);
            v11 = (int)(v6 + 1);
            if ( *(_DWORD *)(v4 + 20) && sub_10016760(v6, v6 + 1, *(_DWORD **)(v4 + 20)) != v6 )
            {
              v12 = 1;
              goto LABEL_48;
            }
            v13 = *(_DWORD *)(v4 + 32);
            v26 = v6 + 1;
            v28 = v13;
            if ( !v13 )
              goto LABEL_43;
            v14 = v22;
            if ( (v25[23] & 0x800) != 0 )
            {
              v15 = (_DWORD *)v25[28];
              v23 = v22;
              (*(void (__thiscall **)(_DWORD, void **, unsigned __int8 *, _BYTE *))(*(_DWORD *)*v15 + 16))(
                *v15,
                Block,
                &v23,
                v24);
              v16 = Block[0];
              if ( Block[4] == (void *)1 )
              {
                v17 = Block;
                if ( v30 >= 0x10 )
                  v17 = (void **)Block[0];
                v14 = *(_BYTE *)v17;
              }
              else
              {
                v14 = v23;
              }
              if ( v30 >= 0x10 )
              {
                if ( v30 + 1 >= 0x1000 )
                {
                  v16 = (void *)*((_DWORD *)Block[0] - 1);
                  if ( (unsigned int)(Block[0] - v16 - 4) > 0x1F )
                    _invalid_parameter_noinfo_noreturn();
                }
                sub_1001D481(v16);
              }
              v13 = v28;
            }
            v18 = *(_DWORD *)(v13 + 4);
            v19 = 0;
            if ( !v18 )
              goto LABEL_42;
            v20 = *(_DWORD *)(v13 + 8);
            break;
          case 0xC:
          case 0x15:
            v4 = 0;
            continue;
          case 0x10:
            do
            {
              if ( !v4 )
                break;
              v21 = (char *)sub_10014B80(a2, v7, *(_DWORD *)(v4 + 12));
              v4 = *(_DWORD *)(v4 + 24);
              v7 = v21;
            }
            while ( a2 != v21 );
            return (int)v7;
          default:
            return (int)v6;
        }
        do
        {
          if ( *(_BYTE *)(v20 + v19) <= v14 && v14 <= *(_BYTE *)(v20 + v19 + 1) )
          {
            v11 = (int)v26;
            v12 = 1;
            goto LABEL_48;
          }
          v19 += 2;
        }
        while ( v19 < v18 );
LABEL_42:
        v11 = (int)v26;
LABEL_43:
        v12 = *(_DWORD *)(v4 + 24)
           && ((unsigned __int8)(1 << (v22 & 7)) & *(_BYTE *)((v22 >> 3) + *(_DWORD *)(v4 + 24))) != 0;
LABEL_48:
        if ( v12 == (*(_BYTE *)(v4 + 8) & 1) )
        {
          v6 = (char *)v11;
          if ( (char *)v11 != a3 )
          {
            v5 = (int)v25;
            goto LABEL_20;
          }
        }
      }
      break;
    }
  }
  return (int)v6;
}

//----- (10014E00) --------------------------------------------------------
bool __thiscall sub_10014E00(int this, int a2, int a3)
{
  int v4; // eax
  char *v5; // edx
  _DWORD *v6; // ecx
  unsigned int v7; // ebx
  unsigned int v8; // eax
  unsigned int v9; // ebx
  bool result; // al
  unsigned int v11; // edx
  int v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  _DWORD *v16; // edx
  bool v17; // zf
  int v18; // ecx
  int v19; // eax
  unsigned int v20; // [esp-8h] [ebp-20h]
  int v21; // [esp-4h] [ebp-1Ch]
  char *v22; // [esp+10h] [ebp-8h]
  unsigned int v23; // [esp+10h] [ebp-8h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  if ( a2 )
  {
    *(_BYTE *)(a2 + 4) = 1;
    sub_100150E0((_DWORD *)a2, 0);
  }
  v4 = *(_DWORD *)(this + 84);
  v20 = *(_DWORD *)(this + 104);
  *(_DWORD *)(this + 76) = v4;
  *(_DWORD *)this = v4;
  sub_10015180(this + 4, (int)&savedregs, v20, this);
  v5 = *(char **)(this + 24);
  v6 = (_DWORD *)(this + 20);
  v7 = *(_DWORD *)(this + 104);
  v8 = (int)&v5[-*(_DWORD *)(this + 20)] >> 3;
  v22 = v5;
  if ( v7 >= v8 )
  {
    if ( v7 > v8 )
    {
      if ( v7 <= (*(_DWORD *)(this + 28) - *(_DWORD *)(this + 20)) >> 3 )
      {
        v9 = v7 - v8;
        if ( v9 )
        {
          memset(v5, 0, 8 * v9);
          v6 = (_DWORD *)(this + 20);
          v5 = &v22[8 * v9];
        }
        v6[1] = v5;
      }
      else
      {
        sub_10017B90((int)v6, v7, this + 20);
      }
    }
  }
  else
  {
    *(_DWORD *)(this + 24) = *v6 + 8 * v7;
  }
  v21 = *(_DWORD *)(this + 88);
  *(_BYTE *)(this + 116) = 0;
  *(_DWORD *)(this + 120) = 10000000;
  *(_DWORD *)(this + 124) = 1000;
  *(_BYTE *)(this + 101) = a2 != 0;
  *(_BYTE *)(this + 100) = 0;
  result = sub_10015FD0((char **)this, v21);
  if ( result )
  {
    if ( a2 )
    {
      sub_100150E0((_DWORD *)a2, *(_DWORD *)(this + 104));
      v11 = 0;
      v23 = 0;
      if ( *(_DWORD *)(this + 104) )
      {
        v12 = 0;
        do
        {
          v13 = *(_DWORD *)(a2 + 8);
          if ( ((1 << (v23 & 0x1F)) & *(_DWORD *)(*(_DWORD *)(this + 36) + 4 * (v11 >> 5))) != 0 )
          {
            *(_BYTE *)(v12 + v13 + 8) = 1;
            *(_DWORD *)(v12 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v23);
            v14 = *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v23 + 4);
          }
          else
          {
            *(_BYTE *)(v12 + v13 + 8) = 0;
            *(_DWORD *)(v12 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(this + 80);
            v14 = *(_DWORD *)(this + 80);
          }
          v11 = v23 + 1;
          v23 = v11;
          *(_DWORD *)(v12 + *(_DWORD *)(a2 + 8) + 4) = v14;
          v12 += 12;
        }
        while ( v11 < *(_DWORD *)(this + 104) );
      }
      *(_DWORD *)a2 = *(_DWORD *)(this + 76);
      v15 = *(_DWORD *)(this + 76);
      *(_DWORD *)(a2 + 20) = v15;
      v16 = *(_DWORD **)(a2 + 8);
      v17 = v15 == *v16;
      *(_DWORD *)(a2 + 24) = *v16;
      *(_BYTE *)(a2 + 28) = !v17;
      v18 = v16[1];
      *(_DWORD *)(a2 + 32) = v18;
      v19 = *(_DWORD *)(this + 80);
      *(_DWORD *)(a2 + 36) = v19;
      *(_BYTE *)(a2 + 40) = v18 != v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(this + 80);
      *(_DWORD *)(a2 + 48) = *(_DWORD *)(this + 80);
    }
    return 1;
  }
  return result;
}
// 10014E31: variable 'this' is possibly undefined

//----- (10014FA0) --------------------------------------------------------
_DWORD *__fastcall sub_10014FA0(int a1, int a2, _DWORD *a3)
{
  _DWORD *result; // eax
  int v4; // esi

  result = a3;
  if ( a1 != a2 )
  {
    v4 = a1 + 44;
    do
    {
      v4 += 48;
      *result = 0;
      result[1] = 0;
      result[2] = 0;
      result[3] = 0;
      result[4] = 0;
      result[5] = 0;
      *result = *(_DWORD *)(v4 - 92);
      result[1] = *(_DWORD *)(v4 - 88);
      result[2] = *(_DWORD *)(v4 - 84);
      result[3] = *(_DWORD *)(v4 - 80);
      result[4] = *(_DWORD *)(v4 - 76);
      result[5] = *(_DWORD *)(v4 - 72);
      *(_DWORD *)(v4 - 76) = 0;
      *(_DWORD *)(v4 - 72) = 15;
      *(_BYTE *)(v4 - 92) = 0;
      result[6] = 0;
      result[7] = 0;
      result[8] = 0;
      result[9] = 0;
      result[10] = 0;
      *(_DWORD *)((char *)a3 + v4 - a1 - 48) = 0;
      result[6] = *(_DWORD *)(v4 - 68);
      result[7] = *(_DWORD *)(v4 - 64);
      result[8] = *(_DWORD *)(v4 - 60);
      result[9] = *(_DWORD *)(v4 - 56);
      result[10] = *(_DWORD *)(v4 - 52);
      result[11] = *(_DWORD *)(v4 - 48);
      *(_DWORD *)(v4 - 52) = 0;
      result += 12;
      *(_DWORD *)(v4 - 48) = 15;
      *(_BYTE *)(v4 - 68) = 0;
    }
    while ( v4 - 44 != a2 );
  }
  return result;
}

//----- (100150E0) --------------------------------------------------------
unsigned int __thiscall sub_100150E0(_DWORD *this, unsigned int a2)
{
  _DWORD *v2; // edi
  int v3; // ecx
  unsigned int result; // eax
  unsigned int v5; // ebx
  unsigned int v6; // esi

  v2 = this + 2;
  v3 = this[3];
  result = 715827883 * (v3 - *v2);
  v5 = (v3 - *v2) / 12;
  if ( a2 >= v5 )
  {
    if ( a2 > v5 )
    {
      result = (v2[2] - *v2) / 12;
      if ( a2 <= result )
      {
        v6 = a2 - v5;
        if ( a2 != v5 )
        {
          do
          {
            *(_DWORD *)v3 = 0;
            *(_DWORD *)(v3 + 4) = 0;
            *(_BYTE *)(v3 + 8) = 0;
            v3 += 12;
            --v6;
          }
          while ( v6 );
        }
        v2[1] = v3;
      }
      else
      {
        return (unsigned int)sub_10017C70((int)v2, a2, v3);
      }
    }
  }
  else
  {
    result = *v2 + 12 * a2;
    v2[1] = result;
  }
  return result;
}

//----- (10015180) --------------------------------------------------------
int **__userpurge sub_10015180@<eax>(int a1@<ecx>, int a2@<ebp>, unsigned int a3, int a4)
{
  int v5; // edx
  int v6; // esi
  int **result; // eax
  int *v8; // ecx
  int v9; // ecx
  int *v10; // [esp-18h] [ebp-24h] BYREF
  unsigned int *v11; // [esp-10h] [ebp-1Ch] BYREF
  unsigned int v12; // [esp-Ch] [ebp-18h]
  int *v13; // [esp-8h] [ebp-14h]
  char v14; // [esp-4h] [ebp-10h] BYREF
  _DWORD v15[3]; // [esp+0h] [ebp-Ch] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v15[0] = a2;
  v15[1] = retaddr;
  v14 = 0;
  v5 = *(_DWORD *)(a1 + 12);
  if ( v5 >= a3 )
  {
    if ( v5 > a3 )
    {
      v8 = *(int **)a1;
      v12 = 0;
      if ( v5 >= 0 || v12 >= -v5 )
        v13 = &v8[(unsigned int)v5 >> 5];
      else
        v13 = &v8[-((unsigned int)~v5 >> 5) - 1];
      v10 = v8;
      v12 = v5 & 0x1F;
      if ( (a3 & 0x80000000) == 0 )
        v9 = (int)&v8[a3 >> 5];
      else
        v9 = (int)&v8[-(~a3 >> 5) - 1];
      return sub_100155F0((int **)a1, &v10, v9, a3 & 0x1F, (int)v13, v12);
    }
  }
  else
  {
    v11 = *(unsigned int **)a1;
    if ( v5 >= 0 )
      v6 = *(_DWORD *)a1 + 4 * ((unsigned int)v5 >> 5);
    else
      v6 = *(_DWORD *)a1 - (4 * ((unsigned int)~v5 >> 5) + 4);
    v13 = (int *)v6;
    return (int **)sub_10015450((unsigned int **)a1, (int)v15, &v11, a3 - v5, &v14, v6, v5 & 0x1F);
  }
  return result;
}
// 10015180: could not find valid save-restore pair for ebp
// 100151BC: conditional instruction was optimized away because edx.4<0
// 10015262: conditional instruction was optimized away because esi.4<0

//----- (100152B0) --------------------------------------------------------
char __thiscall sub_100152B0(_DWORD *this, __int16 a2)
{
  void *v2; // ecx
  void **v3; // eax
  char v4; // bl
  void *Block[5]; // [esp+Ch] [ebp-18h] BYREF
  unsigned int v7; // [esp+20h] [ebp-4h]

  (*(void (__thiscall **)(_DWORD, void **, __int16 *, char *))(*(_DWORD *)*this + 16))(
    *this,
    Block,
    &a2,
    (char *)&a2 + 1);
  v2 = Block[0];
  if ( Block[4] == (void *)1 )
  {
    v3 = Block;
    if ( v7 >= 0x10 )
      v3 = (void **)Block[0];
    v4 = *(_BYTE *)v3;
  }
  else
  {
    v4 = a2;
  }
  if ( v7 >= 0x10 )
  {
    if ( v7 + 1 >= 0x1000 )
    {
      v2 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v2 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v2);
  }
  return v4;
}

//----- (10015330) --------------------------------------------------------
void *__thiscall sub_10015330(void *Block, char a2)
{
  int v3; // edi
  void **v4; // esi
  void **v5; // esi
  void **v6; // esi
  int v7; // edi
  void **v8; // esi

  v3 = *((_DWORD *)Block + 5);
  *(_DWORD *)Block = &std::_Node_class<char,std::regex_traits<char>>::`vftable';
  while ( v3 )
  {
    v4 = (void **)v3;
    v3 = *(_DWORD *)(v3 + 16);
    free(v4[3]);
    sub_1001D481(v4);
  }
  sub_1001D481(*((void **)Block + 6));
  v5 = (void **)*((_DWORD *)Block + 7);
  if ( v5 )
  {
    free(v5[2]);
    sub_1001D481(v5);
  }
  v6 = (void **)*((_DWORD *)Block + 8);
  if ( v6 )
  {
    free(v6[2]);
    sub_1001D481(v6);
  }
  v7 = *((_DWORD *)Block + 10);
  while ( v7 )
  {
    v8 = (void **)v7;
    v7 = *(_DWORD *)(v7 + 16);
    free(v8[3]);
    sub_1001D481(v8);
  }
  *(_DWORD *)Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004C0D4: using guessed type void *std::_Node_class<char,std::regex_traits<char>>::`vftable';

//----- (10015450) --------------------------------------------------------
unsigned int **__userpurge sub_10015450@<eax>(
        unsigned int **a1@<ecx>,
        int a2@<ebp>,
        unsigned int **a3,
        signed int a4,
        char *a5,
        int a6,
        int a7)
{
  int v8; // eax
  unsigned int *v9; // ecx
  unsigned int *v10; // ecx
  unsigned int *v11; // ecx
  unsigned int v12; // edx
  unsigned int v13; // edx
  unsigned int *v14; // esi
  int v15; // edx
  bool v16; // zf
  unsigned int *v17; // ecx
  int *v19; // ecx
  char v20; // [esp-1Ch] [ebp-28h]
  int v21; // [esp-14h] [ebp-20h]
  int v22; // [esp-10h] [ebp-1Ch]
  unsigned int v23; // [esp-Ch] [ebp-18h]
  char v24; // [esp-8h] [ebp-14h]
  int v25; // [esp-8h] [ebp-14h]
  char v26; // [esp-1h] [ebp-Dh]
  _DWORD v27[3]; // [esp+0h] [ebp-Ch] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v27[0] = a2;
  v27[1] = retaddr;
  v8 = sub_10015840(a1, (int)v27, a4, a6, a7);
  v9 = *a1;
  *a3 = *a1;
  a3[1] = 0;
  if ( v8 >= 0 )
    v10 = &v9[(unsigned int)v8 >> 5];
  else
    v10 = &v9[-((unsigned int)~v8 >> 5) - 1];
  *a3 = v10;
  v11 = *a3;
  a3[1] = (unsigned int *)(v8 & 0x1F);
  v12 = (unsigned int)a3[1];
  if ( a4 >= 0 || v12 >= -a4 )
  {
    v24 = v12 + a4;
    v13 = v12 + a4;
    v14 = &v11[v13 >> 5];
  }
  else
  {
    v13 = a4 + v12;
    v24 = v13;
    v14 = &v11[-(~v13 >> 5) - 1];
  }
  v15 = v13 & 0x1F;
  v16 = v11 == v14;
  v17 = a3[1];
  v20 = v24 & 0x1F;
  v21 = v15;
  v26 = *a5;
  if ( !v16 || v17 != (unsigned int *)v15 )
  {
    v25 = -1 << (char)v17;
    v22 = ~(-1 << (char)v17);
    v23 = **a3;
    if ( *a3 == v14 )
    {
      **a3 = v23 & (v22 | ~(0xFFFFFFFF >> (32 - v15))) | v25 & (v26 != 0 ? 0xFFFFFFFF >> (32 - v15) : 0);
      return a3;
    }
    v19 = (int *)*a3;
    *v19 = v22 & v23 | (v26 != 0 ? v25 : 0);
    memset(v19 + 1, (unsigned __int8)-(v26 != 0), (char *)v14 - (char *)(v19 + 1));
    if ( v21 )
      *v14 = (v26 != 0 ? 0xFFFFFFFF >> (32 - v20) : 0) | *v14 & ~(0xFFFFFFFF >> (32 - v20));
  }
  return a3;
}
// 10015450: could not find valid save-restore pair for ebp

//----- (100155F0) --------------------------------------------------------
int **__thiscall sub_100155F0(int **this, int **a2, int a3, int a4, int a5, int a6)
{
  int *v6; // edi
  int v7; // esi
  int *v8; // edx
  unsigned int v9; // esi
  int v10; // ecx
  bool v11; // sf
  unsigned int v12; // ecx
  int *v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // eax
  int *v16; // edx
  int v17; // eax
  int v18; // eax
  int *v19; // edi
  unsigned int v20; // edx
  unsigned int v21; // esi
  int *v22; // eax
  int **v23; // ecx
  int v24; // edx
  int **result; // eax
  int v26; // [esp-24h] [ebp-30h]
  int *v27; // [esp-20h] [ebp-2Ch]
  int *v29; // [esp-18h] [ebp-24h]
  int *v30; // [esp-18h] [ebp-24h]
  int v31; // [esp-14h] [ebp-20h]

  v6 = *this;
  v29 = *this;
  v26 = (int)this[3];
  if ( v26 )
  {
    v7 = a4 + 32 * ((a3 - (int)v6) >> 2);
    if ( v7 >= 0 )
      v8 = &v6[(unsigned int)v7 >> 5];
    else
      v8 = &v6[-((unsigned int)~v7 >> 5) - 1];
    v9 = v7 & 0x1F;
    v10 = 32 * ((a5 - (int)v6) >> 2);
    v11 = a6 + v10 < 0;
    v12 = a6 + v10;
    v27 = v8;
    if ( v11 && v12 )
    {
      v6 += -(~v12 >> 5) - 1;
      v13 = v29;
      v14 = v12 & 0x1F;
    }
    else
    {
      v15 = v12 >> 5;
      v14 = v12 & 0x1F;
      v6 += v15;
      v13 = v29;
    }
  }
  else
  {
    v13 = *this;
    v14 = 0;
    v8 = v6;
    v9 = 0;
    v27 = v6;
  }
  v31 = v9 + 32 * (v8 - v13);
  if ( v8 != v6 || v9 != v14 )
  {
    if ( v26 >= 0 )
      v30 = &v29[(unsigned int)v26 >> 5];
    else
      v30 = &v29[-((unsigned int)~v26 >> 5) - 1];
    v16 = v27;
    while ( v6 != v30 || v14 != (v26 & 0x1F) )
    {
      v17 = *v16;
      if ( ((1 << v14) & *v6) != 0 )
        v18 = v17 | (1 << v9);
      else
        v18 = v17 & ~(1 << v9);
      *v16 = v18;
      if ( v9 >= 0x1F )
      {
        v9 = 0;
        ++v16;
      }
      else
      {
        ++v9;
      }
      if ( v14 >= 0x1F )
      {
        v14 = 0;
        ++v6;
      }
      else
      {
        ++v14;
      }
    }
    v19 = *this;
    v20 = v9 + 32 * (v16 - *this);
    if ( v20 > 0x7FFFFFFF )
      sub_100143B0();
    v21 = (v20 + 31) >> 5;
    if ( v21 >= this[1] - v19 )
    {
      v23 = this;
    }
    else
    {
      v22 = &v19[v21];
      v23 = this;
      if ( v22 != this[1] )
        this[1] = v22;
    }
    v23[3] = (int *)v20;
    v24 = v20 & 0x1F;
    if ( v24 )
      v19[v21 - 1] &= (1 << v24) - 1;
  }
  *a2 = *this;
  a2[1] = 0;
  if ( v31 >= 0 )
    *a2 += (unsigned int)v31 >> 5;
  else
    *a2 = (int *)((char *)*a2 - 4 - 4 * ((unsigned int)~v31 >> 5));
  a2[1] = (int *)v31;
  result = a2;
  a2[1] = (int *)(v31 & 0x1F);
  return result;
}
// 100155F0: could not find valid save-restore pair for ebp
// 10015650: conditional instruction was optimized away because esi.4<0
// 100156FA: conditional instruction was optimized away because %0x14.4<0
// 100143B0: using guessed type void __noreturn sub_100143B0(void);

//----- (10015840) --------------------------------------------------------
int __userpurge sub_10015840@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, unsigned int a3, int a4, int a5)
{
  _DWORD *v5; // esi
  int v6; // edx
  char *v7; // edi
  int v8; // eax
  unsigned int v9; // edx
  int v10; // ecx
  unsigned int v11; // ecx
  size_t v12; // esi
  char *v13; // edi
  int v14; // ecx
  _DWORD *v16; // edx
  _DWORD *v17; // edi
  int v18; // ecx
  int v19; // eax
  char v20; // dl
  int *v21; // esi
  unsigned int v22; // eax
  int v23; // edx
  _DWORD *v24; // edi
  int v25; // eax
  int v26; // eax
  int v27; // [esp-18h] [ebp-24h] BYREF
  int v28; // [esp-14h] [ebp-20h]
  _DWORD *v29; // [esp-Ch] [ebp-18h]
  unsigned int v30; // [esp-8h] [ebp-14h]
  _DWORD *v31; // [esp-4h] [ebp-10h]
  int v32; // [esp+0h] [ebp-Ch]
  int v33; // [esp+4h] [ebp-8h]
  int retaddr; // [esp+Ch] [ebp+0h]

  v32 = a2;
  v33 = retaddr;
  v5 = a1;
  v30 = (unsigned int)a1;
  v28 = a5 + 32 * ((a4 - *a1) >> 2);
  if ( a3 )
  {
    v6 = a1[3];
    if ( 0x7FFFFFFF - v6 < a3 )
      sub_100143B0();
    v7 = (char *)a1[1];
    v8 = *a1;
    v9 = (a3 + 31 + v6) >> 5;
    v10 = (int)&v7[-*a1];
    v27 = 0;
    v11 = v10 >> 2;
    v31 = v7;
    if ( v9 >= v11 )
    {
      if ( v9 > v11 )
      {
        if ( v9 <= (v5[2] - *v5) >> 2 )
        {
          v29 = 0;
          v12 = 4 * (v9 - v11);
          memset(v7, 0, v12);
          v13 = &v7[v12];
          v5 = (_DWORD *)v30;
          *(_DWORD *)(v30 + 4) = v13;
        }
        else
        {
          sub_10017DF0((int)v5, v9, &v27);
        }
      }
    }
    else
    {
      v5[1] = v8 + 4 * v9;
    }
    v14 = v5[3];
    if ( v14 )
    {
      v16 = (_DWORD *)*v5;
      v31 = (_DWORD *)*v5;
      if ( v14 >= 0 )
        v17 = &v16[(unsigned int)v14 >> 5];
      else
        v17 = &v16[-((unsigned int)~v14 >> 5) - 1];
      v18 = v14 & 0x1F;
      v19 = a3 + v5[3];
      v29 = v17;
      v30 = v19;
      v5[3] = v19;
      if ( v19 >= 0 )
      {
        v20 = v19;
        v21 = &v31[(unsigned int)v19 >> 5];
      }
      else
      {
        v20 = v30;
        v21 = &v31[-(~v30 >> 5) - 1];
      }
      v22 = v28;
      v23 = v20 & 0x1F;
      v30 = 0;
      if ( v28 >= 0 || (v22 = v28, v30 >= -v28) )
      {
        v30 = v22;
        v31 += v22 >> 5;
      }
      else
      {
        v30 = v28;
        v31 += -((unsigned int)~v28 >> 5) - 1;
      }
      v24 = v29;
      v25 = v30 & 0x1F;
      v30 = v25;
      while ( v31 != v24 || v25 != v18 )
      {
        if ( v18 )
        {
          --v18;
        }
        else
        {
          v18 = 31;
          --v24;
        }
        if ( v23 )
        {
          --v23;
        }
        else
        {
          v23 = 31;
          --v21;
        }
        v26 = *v21;
        if ( ((1 << v18) & *v24) != 0 )
          *v21 = v26 | (1 << v23);
        else
          *v21 = v26 & ~(1 << v23);
        v25 = v30;
      }
    }
    else
    {
      v5[3] = a3;
    }
  }
  return v28;
}
// 10015840: could not find valid save-restore pair for ebp
// 10015941: conditional instruction was optimized away because ecx.4<0
// 1001597F: conditional instruction was optimized away because eax.4<0
// 100158E4: conditional instruction was optimized away because %0x1C.4==0
// 100143B0: using guessed type void __noreturn sub_100143B0(void);

//----- (10015A60) --------------------------------------------------------
_DWORD *__stdcall sub_10015A60(unsigned int a1)
{
  size_t v1; // eax
  void *v2; // eax
  void *v3; // ecx
  _DWORD *result; // eax

  if ( a1 > 0x3FFFFFFF )
    goto LABEL_9;
  v1 = 4 * a1;
  if ( 4 * a1 < 0x1000 )
  {
    if ( v1 )
      return operator new(v1);
    else
      return 0;
  }
  if ( v1 + 35 <= v1 )
LABEL_9:
    sub_10001240();
  v2 = operator new(v1 + 35);
  v3 = v2;
  if ( !v2 )
    _invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v2 + 35) & 0xFFFFFFE0);
  *(result - 1) = v3;
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);

//----- (10015AC0) --------------------------------------------------------
char __thiscall sub_10015AC0(int this)
{
  char result; // al
  int v3; // ecx
  _DWORD *v4; // edi
  _DWORD *v5; // ecx
  int v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // edx
  _BYTE *v9; // ecx
  int v10; // edx
  _BYTE *v11; // eax
  _BYTE *v12; // edx
  _BYTE *v13; // ecx
  int v14; // edx
  _DWORD *v15; // ecx
  int v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // edx
  _BYTE *v19; // ecx
  _DWORD *v20; // ecx
  int v21; // eax
  _BYTE *v22; // eax
  _BYTE *v23; // ecx
  _BYTE *v24; // eax
  _BYTE *v25; // eax
  _BYTE *v26; // ecx
  _BYTE *v27; // eax
  char v28; // bl
  _BYTE *v29; // eax
  _BYTE *v30; // ecx
  _BYTE *v31; // eax
  _DWORD *v32; // ecx
  int v33; // eax
  _BYTE *v34; // ecx
  _BYTE *v35; // eax
  _BYTE *v36; // eax
  _BYTE *v37; // ecx
  _BYTE *v38; // eax
  _BYTE *v39; // eax

  result = 0;
  v3 = *(_DWORD *)(this + 76);
  if ( v3 != -1 )
  {
    while ( 1 )
    {
      if ( v3 == 124 )
        return result;
      if ( v3 == 41 )
      {
        if ( *(_DWORD *)(this + 16) )
          return result;
        v4 = (_DWORD *)(this + 80);
        if ( (*(_DWORD *)(this + 80) & 0x10000000) == 0 )
LABEL_142:
          sub_100143C0(5);
LABEL_120:
        if ( v3 == 125 )
        {
          if ( (*v4 & 0x10000000) == 0 )
            sub_100143C0(6);
        }
        else if ( v3 == 93 && (*v4 & 0x10000000) == 0 )
        {
          goto LABEL_143;
        }
        sub_10017090((_DWORD *)(this + 36), *(unsigned __int8 *)(this + 72));
LABEL_126:
        v37 = *(_BYTE **)(this + 8);
        v38 = *(_BYTE **)this;
        if ( *(_BYTE **)this != v37 )
        {
          if ( *v38 == 92 )
          {
            v39 = v38 + 1;
            if ( v39 != v37
              && ((*v4 & 8) == 0 && (*v39 == 40 || *v39 == 41) || (*v4 & 0x10) == 0 && (*v39 == 123 || *v39 == 125)) )
            {
              *(_DWORD *)this = v39;
            }
          }
          ++*(_DWORD *)this;
        }
        goto LABEL_137;
      }
      v4 = (_DWORD *)(this + 80);
      if ( v3 == 46 )
      {
        v5 = operator new(0x14u);
        v5[4] = 0;
        *v5 = &std::_Node_base::`vftable';
        v5[1] = 5;
        v5[2] = 0;
        v5[3] = 0;
        v5[4] = *(_DWORD *)(this + 40);
        v6 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
        if ( v6 )
        {
          v5[3] = v6;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v5;
        }
        *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v5;
        *(_DWORD *)(this + 40) = v5;
        v7 = *(_BYTE **)this;
        v8 = *(_BYTE **)(this + 8);
        if ( *(_BYTE **)this != v8 )
        {
          if ( *v7 == 92 )
          {
            v9 = v7 + 1;
            if ( v7 + 1 != v8 )
            {
              v10 = *(_DWORD *)(this + 80);
              if ( (v10 & 8) != 0 )
              {
LABEL_17:
                if ( (v10 & 0x10) == 0 && (*v9 == 123 || *v9 == 125) )
                  goto LABEL_20;
              }
              else
              {
                if ( *v9 != 40 && *v9 != 41 )
                {
                  v7 = *(_BYTE **)this;
                  goto LABEL_17;
                }
LABEL_20:
                v7 = v9;
              }
            }
          }
          *(_DWORD *)this = v7 + 1;
        }
LABEL_137:
        sub_100143D0((_BYTE *)this);
        goto LABEL_138;
      }
      if ( v3 == 92 )
        break;
      if ( v3 == 91 )
      {
        v22 = *(_BYTE **)this;
        v23 = *(_BYTE **)(this + 8);
        if ( *(_BYTE **)this != v23 )
        {
          if ( *v22 == 92 )
          {
            v24 = v22 + 1;
            if ( v24 != v23
              && ((*v4 & 8) == 0 && (*v24 == 40 || *v24 == 41) || (*v4 & 0x10) == 0 && (*v24 == 123 || *v24 == 125)) )
            {
              *(_DWORD *)this = v24;
            }
          }
          ++*(_DWORD *)this;
        }
        sub_100143D0((_BYTE *)this);
        sub_10016990(this);
        if ( *(_DWORD *)(this + 76) != 93 )
LABEL_143:
          sub_100143C0(4);
        goto LABEL_126;
      }
      if ( v3 != 40 )
      {
        switch ( v3 )
        {
          case '^':
            v32 = operator new(0x14u);
            v32[1] = 2;
            break;
          case '$':
            v32 = operator new(0x14u);
            v32[1] = 3;
            break;
          case '*':
          case '+':
          case '?':
          case '{':
            sub_100143C0(10);
          default:
            goto LABEL_120;
        }
        *v32 = &std::_Node_base::`vftable';
        v32[2] = 0;
        v32[3] = 0;
        v32[4] = 0;
        v32[4] = *(_DWORD *)(this + 40);
        v33 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
        if ( v33 )
        {
          v32[3] = v33;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v32;
        }
        *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v32;
        *(_DWORD *)(this + 40) = v32;
        goto LABEL_104;
      }
      v25 = *(_BYTE **)this;
      v26 = *(_BYTE **)(this + 8);
      if ( *(_BYTE **)this != v26 )
      {
        if ( *v25 == 92 )
        {
          v27 = v25 + 1;
          if ( v27 != v26
            && ((*v4 & 8) == 0 && (*v27 == 40 || *v27 == 41) || (*v4 & 0x10) == 0 && (*v27 == 123 || *v27 == 125)) )
          {
            *(_DWORD *)this = v27;
          }
        }
        ++*(_DWORD *)this;
      }
      sub_100143D0((_BYTE *)this);
      v28 = sub_10016C20(this);
      if ( *(_DWORD *)(this + 76) != 41 )
        goto LABEL_142;
      v29 = *(_BYTE **)this;
      v30 = *(_BYTE **)(this + 8);
      if ( *(_BYTE **)this != v30 )
      {
        if ( *v29 == 92 )
        {
          v31 = v29 + 1;
          if ( v31 != v30
            && ((*v4 & 8) == 0 && (*v31 == 40 || *v31 == 41) || (*v4 & 0x10) == 0 && (*v31 == 123 || *v31 == 125)) )
          {
            *(_DWORD *)this = v31;
          }
        }
        ++*(_DWORD *)this;
      }
      sub_100143D0((_BYTE *)this);
      if ( v28 )
        goto LABEL_138;
LABEL_139:
      v3 = *(_DWORD *)(this + 76);
      result = 1;
      if ( v3 == -1 )
        return result;
    }
    v11 = *(_BYTE **)this;
    v12 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this == v12 )
    {
LABEL_35:
      sub_100143D0((_BYTE *)this);
      if ( (*v4 & 0x80) == 0 || *(_BYTE *)(this + 72) != 98 )
      {
        if ( (*v4 & 0x80) == 0 || *(_BYTE *)(this + 72) != 66 )
        {
          sub_10016AD0(this);
LABEL_138:
          sub_10016E60(this);
          goto LABEL_139;
        }
        v20 = operator new(0x14u);
        v20[4] = 0;
        *v20 = &std::_Node_base::`vftable';
        v20[1] = 4;
        v20[2] = 0;
        v20[3] = 0;
        v20[4] = *(_DWORD *)(this + 40);
        v21 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
        if ( v21 )
        {
          v20[3] = v21;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v20;
        }
        *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v20;
        *(_DWORD *)(this + 40) = v20;
        v20[2] ^= 1u;
LABEL_104:
        v34 = *(_BYTE **)(this + 8);
        v35 = *(_BYTE **)this;
        if ( *(_BYTE **)this != v34 )
        {
          if ( *v35 == 92 )
          {
            v36 = v35 + 1;
            if ( v36 != v34
              && ((*v4 & 8) == 0 && (*v36 == 40 || *v36 == 41) || (*v4 & 0x10) == 0 && (*v36 == 123 || *v36 == 125)) )
            {
              *(_DWORD *)this = v36;
            }
          }
          ++*(_DWORD *)this;
        }
LABEL_115:
        sub_100143D0((_BYTE *)this);
        goto LABEL_139;
      }
      v15 = operator new(0x14u);
      v15[4] = 0;
      *v15 = &std::_Node_base::`vftable';
      v15[1] = 4;
      v15[2] = 0;
      v15[3] = 0;
      v15[4] = *(_DWORD *)(this + 40);
      v16 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
      if ( v16 )
      {
        v15[3] = v16;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v15;
      }
      *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v15;
      *(_DWORD *)(this + 40) = v15;
      v17 = *(_BYTE **)this;
      v18 = *(_BYTE **)(this + 8);
      if ( *(_BYTE **)this == v18 )
        goto LABEL_115;
      if ( *v17 != 92 )
        goto LABEL_50;
      v19 = v17 + 1;
      if ( v17 + 1 == v18 )
        goto LABEL_50;
      if ( (*v4 & 8) == 0 )
      {
        if ( *v19 == 40 || *v19 == 41 )
        {
LABEL_49:
          v17 = v19;
LABEL_50:
          *(_DWORD *)this = v17 + 1;
          sub_100143D0((_BYTE *)this);
          goto LABEL_139;
        }
        v17 = *(_BYTE **)this;
      }
      if ( (*v4 & 0x10) != 0 || *v19 != 123 && *v19 != 125 )
        goto LABEL_50;
      goto LABEL_49;
    }
    if ( *v11 != 92 || (v13 = v11 + 1, v11 + 1 == v12) )
    {
LABEL_34:
      *(_DWORD *)this = v11 + 1;
      goto LABEL_35;
    }
    v14 = *(_DWORD *)(this + 80);
    if ( (v14 & 8) == 0 )
    {
      if ( *v13 == 40 || *v13 == 41 )
      {
LABEL_33:
        v11 = v13;
        goto LABEL_34;
      }
      v11 = *(_BYTE **)this;
    }
    if ( (v14 & 0x10) != 0 || *v13 != 123 && *v13 != 125 )
      goto LABEL_34;
    goto LABEL_33;
  }
  return result;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';

//----- (10015FD0) --------------------------------------------------------
bool __thiscall sub_10015FD0(char **this, int a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  int v8; // eax
  int v9; // eax
  char *v10; // eax
  char *v11; // ecx
  int v12; // eax
  char *v13; // ecx
  char *v14; // eax
  char *v15; // eax
  bool v16; // zf
  char *v17; // edi
  char *v18; // eax
  char *v19; // edx
  char v20; // cl
  int v21; // edx
  char v22; // al
  unsigned __int8 v23; // cl
  unsigned __int8 v24; // ch
  unsigned int v25; // edi
  unsigned int v26; // eax
  int v27; // edx
  int v28; // edi
  char v29; // bl
  char v30; // al
  char *v31; // edi
  char *v32; // eax
  char v33; // bl
  int v34; // eax
  unsigned int i; // edi
  char *v37; // edx
  int v38; // edi
  unsigned int v39; // ecx
  char v40; // dl
  char *v41; // ecx
  unsigned int v42; // edi
  char *v43; // eax
  char *v44; // ecx
  char *v45; // edx
  char *v46; // eax
  char v47; // al
  _DWORD *v48; // edx
  char *v49; // [esp+Ch] [ebp-2Ch] BYREF
  void *Block[4]; // [esp+10h] [ebp-28h] BYREF
  char *v51; // [esp+20h] [ebp-18h]
  int v52; // [esp+24h] [ebp-14h]
  int v53; // [esp+28h] [ebp-10h]
  int v54; // [esp+34h] [ebp-4h]
  int v55; // [esp+40h] [ebp+8h]

  v3 = (int)this[31];
  if ( v3 > 0 )
  {
    v4 = v3 - 1;
    this[31] = (char *)v4;
    if ( v4 <= 0 )
      std::_Xregex_error(12);
  }
  v5 = (int)this[30];
  if ( v5 > 0 )
  {
    v6 = v5 - 1;
    this[30] = (char *)v6;
    if ( v6 <= 0 )
      std::_Xregex_error(11);
  }
  v7 = a2;
  LOBYTE(v53) = 0;
  if ( !a2 )
  {
LABEL_72:
    v33 = v53;
    goto LABEL_73;
  }
  while ( 2 )
  {
    v8 = *(_DWORD *)(v7 + 4);
    switch ( v8 )
    {
      case 1:
      case 8:
      case 9:
      case 17:
      case 20:
        goto LABEL_68;
      case 2:
        v53 = (int)this[24];
        if ( (v53 & 0x100) != 0 || *this != this[19] )
        {
          v9 = (int)*this;
          LOBYTE(v9) = *(*this - 1) != 10;
          v53 = v9;
        }
        else
        {
          LOBYTE(v9) = v53 & 1;
          v53 &= 0xFFFFFF01;
        }
        goto LABEL_69;
      case 3:
        v9 = (int)*this;
        if ( *this == this[20] )
        {
          v9 = (unsigned int)this[24] >> 1;
          LOBYTE(v9) = ((unsigned int)this[24] & 2) != 0;
        }
        else
        {
          LOBYTE(v9) = *(_BYTE *)v9 != 10;
        }
        v53 = v9;
        goto LABEL_69;
      case 4:
        v10 = this[24];
        if ( ((unsigned __int16)v10 & 0x100) == 0 )
        {
          v11 = *this;
          if ( *this == this[19] )
          {
            if ( v11 == this[20] )
            {
              v9 = (((unsigned __int8)v10 & 0xC) == 0) == (*(_DWORD *)(v7 + 8) & 1);
              v53 = v9;
              goto LABEL_69;
            }
            if ( ((unsigned __int8)v10 & 4) == 0 )
            {
              v12 = (unsigned __int8)*v11;
              goto LABEL_21;
            }
            goto LABEL_26;
          }
        }
        v13 = *this;
        if ( *this == this[20] )
        {
          if ( ((unsigned __int8)v10 & 8) == 0 )
          {
            v12 = (unsigned __int8)*(v13 - 1);
LABEL_21:
            if ( byte_1004C100[v12] )
            {
              LOBYTE(v9) = (*(_DWORD *)(v7 + 8) & 1) == 1;
              v53 = (unsigned __int8)v9;
              goto LABEL_69;
            }
          }
LABEL_26:
          LOBYTE(v9) = (*(_DWORD *)(v7 + 8) & 1) == 0;
          v53 = (unsigned __int8)v9;
          goto LABEL_69;
        }
        LOBYTE(v9) = (byte_1004C100[(unsigned __int8)*(v13 - 1)] != byte_1004C100[(unsigned __int8)*v13]) == (*(_DWORD *)(v7 + 8) & 1);
        v53 = (unsigned __int8)v9;
LABEL_69:
        if ( (_BYTE)v9 )
          goto LABEL_72;
        goto LABEL_70;
      case 5:
        v14 = *this;
        if ( *this == this[20] || *v14 == 10 || *v14 == 13 )
          goto LABEL_105;
        *this = v14 + 1;
        goto LABEL_68;
      case 6:
        v15 = sub_10016660(
                *this,
                this[20],
                *(char **)(v7 + 28),
                (char *)(*(_DWORD *)(v7 + 28) + *(_DWORD *)(v7 + 24)),
                (int)this[28],
                this[23]);
        if ( v15 == *this )
          goto LABEL_105;
        *this = v15;
        goto LABEL_68;
      case 7:
        if ( *this == this[20] )
          goto LABEL_105;
        v16 = ((unsigned int)this[23] & 0x100) == 0;
        LOBYTE(v52) = **this;
        if ( !v16 )
          LOBYTE(v52) = (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)this[28] + 1) + 16))(
                          *((_DWORD *)this[28] + 1),
                          v52);
        v17 = *this;
        v55 = (int)(*this + 1);
        if ( *(_DWORD *)(v7 + 20) )
        {
          v18 = sub_10016760(v17, this[20], *(_DWORD **)(v7 + 20));
          if ( v18 != v17 )
          {
            v19 = v18;
            v20 = 1;
            goto LABEL_56;
          }
        }
        v21 = *(_DWORD *)(v7 + 32);
        v51 = (char *)v21;
        if ( v21 )
        {
          if ( ((unsigned int)this[23] & 0x800) != 0 )
          {
            v22 = sub_100152B0(this[28], v52);
            v21 = (int)v51;
            v23 = v22;
            v24 = v52;
          }
          else
          {
            v24 = v52;
            v23 = v52;
          }
          v25 = *(_DWORD *)(v21 + 4);
          v26 = 0;
          if ( v25 )
          {
            v27 = *(_DWORD *)(v21 + 8);
            while ( *(_BYTE *)(v27 + v26) > v23 || v23 > *(_BYTE *)(v27 + v26 + 1) )
            {
              v26 += 2;
              if ( v26 >= v25 )
                goto LABEL_51;
            }
LABEL_53:
            v20 = 1;
            goto LABEL_55;
          }
        }
        else
        {
          v24 = v52;
        }
LABEL_51:
        v28 = *(_DWORD *)(v7 + 24);
        if ( v28 && ((unsigned __int8)(1 << (v24 & 7)) & *(_BYTE *)((v24 >> 3) + v28)) != 0 )
          goto LABEL_53;
        v20 = 0;
LABEL_55:
        v19 = (char *)v55;
LABEL_56:
        if ( v20 != (*(_BYTE *)(v7 + 8) & 1) )
        {
          *this = v19;
          LOBYTE(v53) = 0;
LABEL_70:
          if ( !v7 )
            goto LABEL_72;
          v7 = *(_DWORD *)(v7 + 12);
          a2 = v7;
          if ( !v7 )
            goto LABEL_72;
          continue;
        }
LABEL_105:
        v33 = 1;
LABEL_73:
        v34 = (int)this[31];
        if ( v34 > 0 )
          this[31] = (char *)(v34 + 1);
        return v33 == 0;
      case 10:
      case 11:
        v51 = *this;
        v29 = v8 == 11;
        sub_10016900(&v49, this);
        v54 = 0;
        v30 = sub_10015FD0(*(_DWORD *)(a2 + 20));
        v31 = (char *)Block[0];
        if ( v30 == v29 )
        {
          *this = v49;
          if ( this + 1 != (char **)Block )
          {
            sub_10018060((void **)this + 1, v31, (Block[1] - (void *)v31) >> 2);
            this[4] = (char *)Block[3];
          }
          LOBYTE(v53) = 1;
        }
        else
        {
          *this = v51;
        }
        v54 = -1;
        if ( v31 )
        {
          v32 = v31;
          if ( ((Block[2] - (void *)v31) & 0xFFFFFFFC) >= 0x1000 )
          {
            v31 = (char *)*((_DWORD *)v31 - 1);
            if ( (unsigned int)(v32 - v31 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          sub_1001D481(v31);
        }
        v7 = a2;
        goto LABEL_68;
      case 12:
        goto LABEL_88;
      case 13:
        *(_DWORD *)&this[5][8 * *(_DWORD *)(v7 + 20)] = *this;
        for ( i = (unsigned int)this[4]; *(_DWORD *)(v7 + 20) < i; *(_DWORD *)v37 &= ~(1 << (i & 0x1F)) )
          v37 = &this[1][4 * (--i >> 5)];
        goto LABEL_68;
      case 14:
        v38 = *(_DWORD *)(v7 + 20);
        if ( *((_BYTE *)this + 101) || *(_DWORD *)(v38 + 20) )
        {
          v39 = *(_DWORD *)(v38 + 20);
          v40 = v39 & 0x1F;
          v41 = &this[1][4 * (v39 >> 5)];
          *(_DWORD *)v41 |= 1 << v40;
          *(_DWORD *)&this[5][8 * *(_DWORD *)(v38 + 20) + 4] = *this;
        }
        goto LABEL_68;
      case 15:
        v42 = *(_DWORD *)(v7 + 20);
        if ( ((1 << (*(_BYTE *)(v7 + 20) & 0x1F)) & *(_DWORD *)&this[1][4 * (v42 >> 5)]) == 0 )
          goto LABEL_68;
        v43 = this[5];
        v44 = *this;
        v45 = *(char **)&v43[8 * v42];
        v46 = *(char **)&v43[8 * v42 + 4];
        if ( v45 != v46 )
        {
          v44 = sub_10016660(v44, this[20], v45, v46, (int)this[28], this[23]);
          if ( v44 == *this )
            goto LABEL_105;
        }
        *this = v44;
        goto LABEL_68;
      case 16:
        if ( !sub_10017200((int)this, v7) )
          goto LABEL_87;
        goto LABEL_88;
      case 18:
        v47 = sub_10017400((int)this, (_DWORD *)v7, (*(_DWORD *)(v7 + 8) & 2) != 0, 0);
        goto LABEL_90;
      case 19:
        v48 = *(_DWORD **)(v7 + 20);
        if ( v48[9] )
          goto LABEL_88;
        v47 = sub_10017400((int)this, v48, (v48[2] & 2) != 0, *(_DWORD *)&this[16][8 * v48[8]]);
LABEL_90:
        if ( v47 )
          goto LABEL_88;
        LOBYTE(v53) = 1;
        v7 = 0;
        goto LABEL_68;
      case 21:
        if ( ((unsigned int)this[24] & 0x2020) != 0 && this[19] == *this || *((_BYTE *)this + 116) && *this != this[20] )
        {
LABEL_87:
          LOBYTE(v53) = 1;
LABEL_88:
          v7 = 0;
          goto LABEL_68;
        }
        if ( *((_BYTE *)this + 100) && !sub_10017640(this) )
          goto LABEL_88;
        this[8] = *this;
        if ( this + 9 != this + 1 )
        {
          sub_10018060((void **)this + 9, this[1], (this[2] - this[1]) >> 2);
          this[12] = this[4];
        }
        if ( this + 13 != this + 5 )
          sub_10017F00((void **)this + 13, this[5], (this[6] - this[5]) >> 3);
        *((_BYTE *)this + 100) = 1;
        v7 = 0;
LABEL_68:
        LOBYTE(v9) = v53;
        goto LABEL_69;
      default:
        std::_Xregex_error(13);
    }
  }
}
// 1001C04E: using guessed type void __cdecl __noreturn std::_Xregex_error(_DWORD);

//----- (10016580) --------------------------------------------------------
int **__thiscall sub_10016580(_DWORD *this, int **a2, _DWORD *a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int *v6; // ecx
  int **v7; // edx
  int *v8; // eax
  int **result; // eax
  int *v10; // edx
  int *v11; // ecx

  v4 = this[3];
  v5 = a4 & this[6];
  v6 = (int *)this[1];
  v7 = (int **)(v4 + 8 * v5);
  v8 = v7[1];
  if ( v8 == v6 )
  {
    result = a2;
    *a2 = v6;
    a2[1] = 0;
  }
  else
  {
    v10 = *v7;
    if ( *a3 == v8[2] )
    {
LABEL_6:
      v11 = (int *)*v8;
      a2[1] = v8;
      result = a2;
      *a2 = v11;
    }
    else
    {
      while ( v8 != v10 )
      {
        v8 = (int *)v8[1];
        if ( *a3 == v8[2] )
          goto LABEL_6;
      }
      *a2 = v8;
      result = a2;
      a2[1] = 0;
    }
  }
  return result;
}

//----- (100165F0) --------------------------------------------------------
void ***__fastcall sub_100165F0(void ***a1, char *a2, char *a3, void **Src)
{
  char *v4; // esi
  char v5; // bl
  unsigned int v6; // ecx
  unsigned int v7; // edx
  _DWORD *v8; // eax
  void ***v10; // [esp+4h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-8h]

  v4 = a2;
  v10 = a1;
  if ( a2 != a3 )
  {
    do
    {
      v5 = *v4;
      v6 = (unsigned int)Src[4];
      v7 = (unsigned int)Src[5];
      if ( v6 >= v7 )
      {
        LOBYTE(v11) = 0;
        sub_100068E0(Src, v6, v11, *v4);
      }
      else
      {
        Src[4] = (void *)(v6 + 1);
        v8 = Src;
        if ( v7 >= 0x10 )
          v8 = *Src;
        *((_BYTE *)v8 + v6) = v5;
        *((_BYTE *)v8 + v6 + 1) = 0;
      }
      ++v4;
    }
    while ( v4 != a3 );
    a1 = v10;
  }
  *a1 = Src;
  return a1;
}
// 1001663B: variable 'v11' is possibly undefined

//----- (10016660) --------------------------------------------------------
char *__fastcall sub_10016660(char *a1, char *a2, char *a3, char *a4, int a5, char *a6)
{
  char *v7; // esi
  char *v8; // ecx
  char *v9; // edi
  char *v10; // eax
  char v11; // al
  char v12; // al
  char v13; // bl
  char *v15; // ebx
  char *v16; // eax
  char v17; // cl
  char v18; // al
  char *v19; // edi
  char *v20; // edx
  char *v21; // eax
  char v22; // cl
  char v23; // al
  char v24; // [esp+Ch] [ebp-Ch]
  char v25; // [esp+10h] [ebp-8h]

  v7 = a1;
  if ( ((unsigned __int16)a6 & 0x100) != 0 )
  {
    v8 = a3;
    v9 = v7;
    v10 = a4;
    if ( v7 != a2 )
    {
      while ( v8 != v10 )
      {
        v11 = *v8;
        a6 = v8 + 1;
        v25 = v11;
        v12 = *v9++;
        v24 = v12;
        v13 = (*(int (__thiscall **)(_DWORD, char))(**(_DWORD **)(a5 + 4) + 16))(*(_DWORD *)(a5 + 4), v25);
        if ( (*(unsigned __int8 (__thiscall **)(_DWORD, char))(**(_DWORD **)(a5 + 4) + 16))(*(_DWORD *)(a5 + 4), v24) != v13 )
          return v7;
        v8 = a6;
        v10 = a4;
        if ( v9 == a2 )
          goto LABEL_6;
      }
      return v9;
    }
LABEL_6:
    if ( v8 == v10 )
      return v9;
    return v7;
  }
  if ( ((unsigned __int16)a6 & 0x800) == 0 )
  {
    v19 = a3;
    v20 = a1;
    v21 = a4;
    if ( a1 == a2 )
    {
LABEL_19:
      if ( v19 != v21 )
        return v7;
    }
    else
    {
      while ( v19 != v21 )
      {
        v22 = *v19++;
        v23 = *v20++;
        if ( v23 != v22 )
          return v7;
        v21 = a4;
        if ( v20 == a2 )
          goto LABEL_19;
      }
    }
    return v20;
  }
  v9 = a1;
  v15 = a3;
  a6 = (char *)a5;
  v16 = a4;
  if ( a1 != a2 )
  {
    while ( v15 != v16 )
    {
      v17 = *v15++;
      v18 = *v9++;
      if ( !sub_100182C0(&a6, v18, v17) )
        return v7;
      v16 = a4;
      if ( v9 == a2 )
        goto LABEL_13;
    }
    return v9;
  }
LABEL_13:
  if ( v15 == v16 )
    return v9;
  return v7;
}

//----- (10016760) --------------------------------------------------------
char *__fastcall sub_10016760(char *a1, char *a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char *v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // ebx
  unsigned int v7; // edi
  char *v8; // esi
  unsigned int v9; // edx
  _BYTE *v10; // eax
  char v11; // cl
  unsigned int v15; // [esp+14h] [ebp-4h]

  v3 = a3;
  v4 = a1;
  if ( a3 )
  {
    while ( 1 )
    {
      v5 = v3[2];
      v6 = 0;
      v15 = v5;
      if ( v5 )
        break;
LABEL_11:
      v3 = (_DWORD *)v3[4];
      a3 = v3;
      if ( !v3 )
        return v4;
    }
    v7 = *v3;
    while ( 1 )
    {
      v8 = v4;
      v9 = 0;
      if ( v7 )
      {
        v10 = (_BYTE *)(v6 + v3[3]);
        do
        {
          v11 = *v8++;
          if ( v11 != *v10 )
            break;
          ++v9;
          ++v10;
        }
        while ( v9 < v7 );
        v3 = a3;
        v5 = v15;
      }
      v4 = a2;
      if ( v8 == a2 )
        break;
      v4 = a1;
      v6 += v7;
      if ( v6 >= v5 )
        goto LABEL_11;
    }
  }
  return v4;
}

//----- (100167D0) --------------------------------------------------------
char *__thiscall sub_100167D0(int this, unsigned int a2, int a3)
{
  unsigned int v4; // ecx
  unsigned int v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  void *v8; // eax
  _DWORD *v9; // esi
  void *v10; // eax
  char *result; // eax
  int v12; // [esp+Ch] [ebp-4h]

  if ( a2 > 0x1FFFFFFF )
    sub_10008240();
  v12 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  v4 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3;
  v5 = (unsigned int)((*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3) >> 1;
  if ( v4 > 0x1FFFFFFF - v5 )
    goto LABEL_21;
  v6 = v5 + v4;
  if ( v5 + v4 >= a2 )
  {
    if ( v6 > 0x1FFFFFFF )
      goto LABEL_21;
  }
  else
  {
    v6 = a2;
  }
  v7 = 8 * v6;
  if ( 8 * v6 < 0x1000 )
  {
    if ( v7 )
      v9 = operator new(8 * v6);
    else
      v9 = 0;
    goto LABEL_13;
  }
  if ( v7 + 35 <= v7 )
LABEL_21:
    sub_10001240();
  v8 = operator new(v7 + 35);
  if ( !v8 )
    goto LABEL_23;
  v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
  *(v9 - 1) = v8;
LABEL_13:
  if ( a2 != v12 )
    memset(&v9[2 * v12], 0, 8 * (a2 - v12));
  memmove(v9, *(const void **)this, *(_DWORD *)(this + 4) - *(_DWORD *)this);
  v10 = *(void **)this;
  if ( *(_DWORD *)this )
  {
    if ( ((*(_DWORD *)(this + 8) - (_DWORD)v10) & 0xFFFFFFF8) < 0x1000 )
    {
LABEL_19:
      sub_1001D481(v10);
      goto LABEL_20;
    }
    if ( (unsigned int)v10 - *((_DWORD *)v10 - 1) - 4 <= 0x1F )
    {
      v10 = (void *)*((_DWORD *)v10 - 1);
      goto LABEL_19;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_20:
  *(_DWORD *)this = v9;
  *(_DWORD *)(this + 4) = &v9[2 * a2];
  result = (char *)&v9[v7 / 4];
  *(_DWORD *)(this + 8) = &v9[v7 / 4];
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10016900) --------------------------------------------------------
_DWORD *__thiscall sub_10016900(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ecx
  unsigned int v4; // esi
  _DWORD *v5; // eax
  char *v6; // edi
  const void *v7; // eax
  signed int v8; // esi

  v3 = a2;
  *this = *a2;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  v4 = (v3[2] - v3[1]) >> 2;
  if ( v4 )
  {
    if ( v4 > 0x3FFFFFFF )
      sub_10008240();
    v5 = sub_10015A60(v4);
    this[1] = v5;
    this[2] = v5;
    this[3] = &v5[v4];
    v6 = (char *)this[1];
    v7 = (const void *)a2[1];
    v8 = a2[2] - (_DWORD)v7;
    memmove(v6, v7, v8);
    v3 = a2;
    this[2] = &v6[4 * (v8 >> 2)];
  }
  this[4] = v3[4];
  return this;
}
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10016990) --------------------------------------------------------
int __thiscall sub_10016990(int this)
{
  _BYTE *v2; // eax
  _BYTE *v3; // edx
  _BYTE *v4; // ecx
  int v5; // edx
  int v6; // edi
  _DWORD *v7; // ecx
  _BYTE *v8; // eax
  _BYTE *v9; // edx
  _BYTE *v10; // ecx
  int v11; // edx
  unsigned __int8 v13; // [esp+17h] [ebp-1h]

  sub_10018D90((_DWORD *)(this + 36));
  if ( *(_DWORD *)(this + 76) == 94 )
  {
    *(_DWORD *)(*(_DWORD *)(this + 40) + 8) ^= 1u;
    v2 = *(_BYTE **)this;
    v3 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this == v3 )
    {
LABEL_14:
      sub_100143D0((_BYTE *)this);
      goto LABEL_15;
    }
    if ( *v2 != 92 || (v4 = v2 + 1, v2 + 1 == v3) )
    {
LABEL_13:
      *(_DWORD *)this = v2 + 1;
      goto LABEL_14;
    }
    v5 = *(_DWORD *)(this + 80);
    if ( (v5 & 8) == 0 )
    {
      if ( *v4 == 40 || *v4 == 41 )
      {
LABEL_12:
        v2 = v4;
        goto LABEL_13;
      }
      v2 = *(_BYTE **)this;
    }
    if ( (v5 & 0x10) != 0 || *v4 != 123 && *v4 != 125 )
      goto LABEL_13;
    goto LABEL_12;
  }
LABEL_15:
  if ( (*(_DWORD *)(this + 80) & 0x20000000) != 0 && *(_DWORD *)(this + 76) == 93 )
  {
    v13 = 93;
    if ( (*(_DWORD *)(this + 44) & 0x100) != 0 )
      v13 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*(_DWORD *)(this + 48) + 4) + 16))(
              *(_DWORD *)(*(_DWORD *)(this + 48) + 4),
              93);
    v6 = *(_DWORD *)(this + 40);
    v7 = *(_DWORD **)(v6 + 24);
    if ( !v7 )
    {
      v7 = operator new(0x20u);
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = 0;
      v7[4] = 0;
      v7[5] = 0;
      v7[6] = 0;
      v7[7] = 0;
      *(_DWORD *)(v6 + 24) = v7;
    }
    *((_BYTE *)v7 + (v13 >> 3)) |= 1 << (v13 & 7);
    v8 = *(_BYTE **)this;
    v9 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this == v9 )
      goto LABEL_33;
    if ( *v8 != 92 || (v10 = v8 + 1, v8 + 1 == v9) )
    {
LABEL_32:
      *(_DWORD *)this = v8 + 1;
LABEL_33:
      sub_100143D0((_BYTE *)this);
      return sub_100184F0(this);
    }
    v11 = *(_DWORD *)(this + 80);
    if ( (v11 & 8) == 0 )
    {
      if ( *v10 == 40 || *v10 == 41 )
      {
LABEL_31:
        v8 = v10;
        goto LABEL_32;
      }
      v8 = *(_BYTE **)this;
    }
    if ( (v11 & 0x10) != 0 || *v10 != 123 && *v10 != 125 )
      goto LABEL_32;
    goto LABEL_31;
  }
  return sub_100184F0(this);
}

//----- (10016AD0) --------------------------------------------------------
char __thiscall sub_10016AD0(int this)
{
  int v2; // edx
  unsigned int v3; // ebx
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax

  if ( (*(_DWORD *)(this + 80) & 0x100) == 0 || sub_100193C0(this, 10, 0x7FFFFFFF, 3) == 0x7FFFFFFF )
  {
    if ( sub_10018820(this) )
    {
      LOBYTE(v5) = sub_10017090((_DWORD *)(this + 36), *(unsigned __int8 *)(this + 68));
    }
    else if ( (*(_DWORD *)(this + 80) & 0x20000) == 0 || (LOBYTE(v5) = sub_10018430(this, 1), !(_BYTE)v5) )
    {
      sub_100143C0(2);
    }
  }
  else
  {
    v3 = *(_DWORD *)(this + 68);
    v4 = *(_DWORD *)(this + 80);
    if ( v3 )
    {
      if ( (v4 & 0x200) != 0 && v3 > 9
        || *(_DWORD *)(this + 12) < v3
        || *(_DWORD *)(this + 32) <= v3
        || ((1 << (*(_BYTE *)(this + 68) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(this + 20) + 4 * (v3 >> 5))) == 0 )
      {
        sub_100143C0(3);
      }
      v6 = operator new(0x18u);
      v6[4] = 0;
      v6[1] = 15;
      v6[2] = 0;
      v6[3] = 0;
      *v6 = &std::_Node_back::`vftable';
      v6[5] = v3;
      v6[4] = *(_DWORD *)(this + 40);
      v7 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
      if ( v7 )
      {
        v6[3] = v7;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v6;
      }
      v5 = *(_DWORD *)(this + 40);
      *(_DWORD *)(v5 + 12) = v6;
      *(_DWORD *)(this + 40) = v6;
    }
    else
    {
      if ( (v4 & 0x100000) == 0 )
        sub_100143C0(2);
      LOBYTE(v2) = *(_DWORD *)(this + 68);
      LOBYTE(v5) = sub_10017090((_DWORD *)(this + 36), v2);
    }
  }
  return v5;
}
// 10016B1B: variable 'v2' is possibly undefined
// 1004C0A8: using guessed type void *std::_Node_back::`vftable';

//----- (10016C20) --------------------------------------------------------
char __thiscall sub_10016C20(int this)
{
  int v2; // ecx
  _BYTE *v3; // eax
  _BYTE *v4; // ebx
  _BYTE *v5; // edx
  _BYTE *v6; // eax
  _BYTE *v7; // edx
  int v8; // esi
  _BYTE *v9; // ecx
  int v10; // edx
  char result; // al
  int v12; // esi
  _DWORD *v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // esi
  _DWORD *v17; // ecx
  int v18; // eax
  unsigned int v19; // eax
  _DWORD *v20; // ecx
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  ++*(_DWORD *)(this + 16);
  v2 = *(_DWORD *)(this + 80);
  if ( (v2 & 0x8000000) == 0 && *(_DWORD *)(this + 76) == 41 )
    sub_100143C0(5);
  if ( (v2 & 0x20) != 0 && *(_DWORD *)(this + 76) == 63 )
  {
    v3 = *(_BYTE **)this;
    v4 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this == v4 )
      goto LABEL_17;
    if ( *v3 != 92 || (v5 = v3 + 1, v3 + 1 == v4) )
    {
LABEL_16:
      *(_DWORD *)this = v3 + 1;
LABEL_17:
      sub_100143D0((_BYTE *)this);
      v6 = *(_BYTE **)this;
      v7 = *(_BYTE **)(this + 8);
      v8 = *(_DWORD *)(this + 76);
      if ( *(_BYTE **)this == v7 )
        goto LABEL_29;
      if ( *v6 != 92 || (v9 = v6 + 1, v6 + 1 == v7) )
      {
LABEL_28:
        *(_DWORD *)this = v6 + 1;
LABEL_29:
        sub_100143D0((_BYTE *)this);
        if ( v8 != 58 )
        {
          if ( v8 == 33 )
          {
            sub_10018CA0((_DWORD *)this, 1u);
            --*(_DWORD *)(this + 16);
            return 0;
          }
          else
          {
            if ( v8 != 61 )
              sub_100143C0(14);
            sub_10018CA0((_DWORD *)this, 0);
            --*(_DWORD *)(this + 16);
            return 0;
          }
        }
LABEL_35:
        sub_10018BB0((_DWORD *)this);
        --*(_DWORD *)(this + 16);
        return 1;
      }
      v10 = *(_DWORD *)(this + 80);
      if ( (v10 & 8) == 0 )
      {
        if ( *v9 == 40 || *v9 == 41 )
        {
LABEL_27:
          v6 = v9;
          goto LABEL_28;
        }
        v6 = *(_BYTE **)this;
      }
      if ( (v10 & 0x10) != 0 || *v9 != 123 && *v9 != 125 )
        goto LABEL_28;
      goto LABEL_27;
    }
    if ( (v2 & 8) == 0 )
    {
      if ( *v5 == 40 || *v5 == 41 )
      {
LABEL_15:
        v3 = v5;
        goto LABEL_16;
      }
      v3 = *(_BYTE **)this;
    }
    if ( (v2 & 0x10) != 0 || *v5 != 123 && *v5 != 125 )
      goto LABEL_16;
    goto LABEL_15;
  }
  if ( (*(_DWORD *)(this + 64) & 0x200) != 0 )
    goto LABEL_35;
  v12 = *(_DWORD *)(this + 12) + 1;
  *(_DWORD *)(this + 12) = v12;
  v13 = operator new(0x18u);
  v13[4] = 0;
  v13[1] = 13;
  v13[2] = 0;
  v13[3] = 0;
  *v13 = &std::_Node_capture::`vftable';
  v13[5] = v12;
  v13[4] = *(_DWORD *)(this + 40);
  v14 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
  if ( v14 )
  {
    v13[3] = v14;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v13;
  }
  *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v13;
  *(_DWORD *)(this + 40) = v13;
  sub_10014620(this);
  v15 = v13[1];
  if ( v15 == 8 )
  {
    v16 = 9;
  }
  else if ( v15 == 10 || (v16 = 14, v15 == 11) )
  {
    v16 = 12;
  }
  v17 = operator new(0x18u);
  v17[4] = 0;
  v17[1] = v16;
  v17[2] = 0;
  v17[3] = 0;
  *v17 = &std::_Node_end_group::`vftable';
  v17[5] = v13;
  v17[4] = *(_DWORD *)(this + 40);
  v18 = *(_DWORD *)(*(_DWORD *)(this + 40) + 12);
  if ( v18 )
  {
    v17[3] = v18;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 40) + 12) + 16) = v17;
  }
  *(_DWORD *)(*(_DWORD *)(this + 40) + 12) = v17;
  *(_DWORD *)(this + 40) = v17;
  sub_10015180(this + 20, (int)&savedregs, *(_DWORD *)(this + 12) + 1, (int)v17);
  v19 = v13[5];
  v20 = (_DWORD *)(*(_DWORD *)(this + 20) + 4 * (v19 >> 5));
  *v20 |= 1 << (v19 & 0x1F);
  result = 1;
  --*(_DWORD *)(this + 16);
  return result;
}
// 10014620: using guessed type int __thiscall sub_10014620(_DWORD);
// 1004A9C0: using guessed type void *std::_Node_capture::`vftable';
// 1004C204: using guessed type void *std::_Node_end_group::`vftable';

//----- (10016E60) --------------------------------------------------------
int __thiscall sub_10016E60(int this)
{
  int result; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  _BYTE *v5; // ecx
  int v6; // edx
  int v7; // edx
  _BYTE *v8; // eax
  _BYTE *v9; // ecx
  _BYTE *v10; // eax
  _BYTE *v11; // edx
  _BYTE *v12; // ecx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  _BYTE *v16; // eax
  _BYTE *v17; // edx
  _BYTE *v18; // ecx
  int v19; // edx
  unsigned __int8 v20; // [esp+Ch] [ebp-Ch]
  int v21; // [esp+10h] [ebp-8h]
  int v22; // [esp+14h] [ebp-4h]

  v22 = 0;
  v21 = -1;
  result = *(_DWORD *)(this + 76);
  if ( result != 42 )
  {
    switch ( result )
    {
      case '+':
        v22 = 1;
        break;
      case '?':
        v21 = 1;
        break;
      case '{':
        v10 = *(_BYTE **)this;
        v11 = *(_BYTE **)(this + 8);
        if ( *(_BYTE **)this != v11 )
        {
          if ( *v10 == 92 )
          {
            v12 = v10 + 1;
            if ( v10 + 1 != v11 )
            {
              if ( (v13 = *(_DWORD *)(this + 80), (v13 & 8) == 0) && (*v12 == 40 || *v12 == 41)
                || (v13 & 0x10) == 0 && (*v12 == 123 || *v12 == 125) )
              {
                ++v10;
              }
            }
          }
          *(_DWORD *)this = v10 + 1;
        }
        sub_100143D0((_BYTE *)this);
        if ( sub_100193C0(this, 10, 0x7FFFFFFF, 7) == 0x7FFFFFFF )
          sub_100143C0(7);
        v14 = *(_DWORD *)(this + 68);
        v22 = v14;
        if ( *(_DWORD *)(this + 76) == 44 )
        {
          v16 = *(_BYTE **)this;
          v17 = *(_BYTE **)(this + 8);
          if ( *(_BYTE **)this != v17 )
          {
            if ( *v16 == 92 )
            {
              v18 = v16 + 1;
              if ( v16 + 1 != v17 )
              {
                if ( (v19 = *(_DWORD *)(this + 80), (v19 & 8) == 0) && (*v18 == 40 || *v18 == 41)
                  || (v19 & 0x10) == 0 && (*v18 == 123 || *v18 == 125) )
                {
                  ++v16;
                }
              }
            }
            *(_DWORD *)this = v16 + 1;
          }
          sub_100143D0((_BYTE *)this);
          if ( *(_DWORD *)(this + 76) == 125 )
          {
            v15 = -1;
          }
          else
          {
            if ( sub_100193C0(this, 10, 0x7FFFFFFF, 7) == 0x7FFFFFFF )
              sub_100143C0(7);
            v15 = *(_DWORD *)(this + 68);
            v21 = v15;
          }
          v14 = v22;
        }
        else
        {
          v15 = *(_DWORD *)(this + 68);
          v21 = v15;
        }
        if ( *(_DWORD *)(this + 76) != 125 || v15 != -1 && v15 < v14 )
          sub_100143C0(7);
        break;
      default:
        return result;
    }
  }
  *(_DWORD *)(*(_DWORD *)(this + 40) + 8) |= 4u;
  v3 = *(_BYTE **)this;
  v4 = *(_BYTE **)(this + 8);
  if ( *(_BYTE **)this != v4 )
  {
    if ( *v3 == 92 )
    {
      v5 = v3 + 1;
      if ( v3 + 1 != v4 )
      {
        if ( (v6 = *(_DWORD *)(this + 80), (v6 & 8) == 0) && (*v5 == 40 || *v5 == 41)
          || (v6 & 0x10) == 0 && (*v5 == 123 || *v5 == 125) )
        {
          ++v3;
        }
      }
    }
    *(_DWORD *)this = v3 + 1;
  }
  sub_100143D0((_BYTE *)this);
  v7 = *(_DWORD *)(this + 80);
  if ( (v7 & 0x400) != 0 && *(_DWORD *)(this + 76) == 63 )
  {
    v8 = *(_BYTE **)this;
    v20 = 0;
    if ( *(_DWORD *)this != *(_DWORD *)(this + 8) )
    {
      if ( *v8 == 92 )
      {
        v9 = v8 + 1;
        if ( v8 + 1 != *(_BYTE **)(this + 8)
          && ((v7 & 8) == 0 && (*v9 == 40 || *v9 == 41) || (v7 & 0x10) == 0 && (*v9 == 123 || *v9 == 125)) )
        {
          ++v8;
        }
      }
      *(_DWORD *)this = v8 + 1;
    }
    sub_100143D0((_BYTE *)this);
  }
  else
  {
    v20 = 1;
  }
  return sub_10018E20((_DWORD *)(this + 36), v22, v21, v20);
}

//----- (10017090) --------------------------------------------------------
int __thiscall sub_10017090(_DWORD *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // eax
  int v6; // eax
  char v7; // bl
  void *v8; // ecx
  void **v9; // eax
  int v10; // esi
  unsigned int v11; // eax
  void *v12; // eax
  int result; // eax
  char v14; // [esp+10h] [ebp-20h] BYREF
  char v15[3]; // [esp+11h] [ebp-1Fh] BYREF
  _DWORD *v16; // [esp+14h] [ebp-1Ch]
  void *Block[5]; // [esp+18h] [ebp-18h] BYREF
  unsigned int v18; // [esp+2Ch] [ebp-4h]

  v3 = this[1];
  if ( *(_DWORD *)(v3 + 4) != 6 || (*(_BYTE *)(v3 + 8) & 4) != 0 )
  {
    v4 = operator new(0x20u);
    v16 = v4;
    v4[1] = 6;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = 0;
    *v4 = &std::_Node_str<char>::`vftable';
    v4[5] = 0;
    v4[6] = 0;
    v4[7] = 0;
    v4[4] = this[1];
    v5 = *(_DWORD *)(this[1] + 12);
    if ( v5 )
    {
      v4[3] = v5;
      *(_DWORD *)(*(_DWORD *)(this[1] + 12) + 16) = v4;
    }
    *(_DWORD *)(this[1] + 12) = v4;
    this[1] = v4;
  }
  v6 = this[2];
  if ( (v6 & 0x100) != 0 )
  {
    v7 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this[3] + 4) + 16))(*(_DWORD *)(this[3] + 4), a2);
  }
  else if ( (v6 & 0x800) != 0 )
  {
    v14 = a2;
    (*(void (__thiscall **)(_DWORD, void **, char *, char *))(**(_DWORD **)this[3] + 16))(
      *(_DWORD *)this[3],
      Block,
      &v14,
      v15);
    v8 = Block[0];
    if ( Block[4] == (void *)1 )
    {
      v9 = Block;
      if ( v18 >= 0x10 )
        v9 = (void **)Block[0];
      v7 = *(_BYTE *)v9;
    }
    else
    {
      v7 = v14;
    }
    if ( v18 >= 0x10 )
    {
      if ( v18 + 1 >= 0x1000 )
      {
        v8 = (void *)*((_DWORD *)Block[0] - 1);
        if ( (unsigned int)(Block[0] - v8 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_1001D481(v8);
    }
  }
  else
  {
    v7 = a2;
  }
  v10 = this[1];
  v11 = *(_DWORD *)(v10 + 24);
  v16 = (_DWORD *)v11;
  if ( *(_DWORD *)(v10 + 20) <= v11 )
  {
    v12 = realloc(*(void **)(v10 + 28), v11 + 16);
    if ( !v12 )
      sub_1001BFF1();
    *(_DWORD *)(v10 + 28) = v12;
    *(_DWORD *)(v10 + 20) = v16 + 4;
  }
  result = *(_DWORD *)(v10 + 28);
  *(_BYTE *)(*(_DWORD *)(v10 + 24) + result) = v7;
  ++*(_DWORD *)(v10 + 24);
  return result;
}
// 1001BFF1: using guessed type void __noreturn sub_1001BFF1(void);
// 1004A9E8: using guessed type void *std::_Node_str<char>::`vftable';
// 10017090: using guessed type char var_1F[3];

//----- (10017200) --------------------------------------------------------
char __thiscall sub_10017200(int this, int a2)
{
  void **v3; // esi
  void **v4; // edi
  char v5; // bl
  int v7; // eax
  int v8; // ecx
  int v9; // [esp+Ch] [ebp-54h] BYREF
  void *v10[3]; // [esp+10h] [ebp-50h] BYREF
  int v11; // [esp+1Ch] [ebp-44h]
  void *v12[3]; // [esp+20h] [ebp-40h] BYREF
  int v13; // [esp+2Ch] [ebp-34h] BYREF
  void *v14; // [esp+30h] [ebp-30h] BYREF
  int v15; // [esp+34h] [ebp-2Ch]
  int v16; // [esp+3Ch] [ebp-24h]
  void *Src; // [esp+40h] [ebp-20h] BYREF
  int v18; // [esp+44h] [ebp-1Ch]
  int v19; // [esp+4Ch] [ebp-14h]
  int v20; // [esp+50h] [ebp-10h]
  int v21; // [esp+5Ch] [ebp-4h]
  int i; // [esp+68h] [ebp+8h]

  sub_100181C0(&v13, (_DWORD *)this);
  v21 = 0;
  if ( a2 )
  {
    v3 = (void **)(this + 4);
    v4 = (void **)(this + 20);
    while ( 1 )
    {
      *(_DWORD *)this = v13;
      if ( v3 != &v14 )
      {
        sub_10018060((void **)(this + 4), (char *)v14, (v15 - (int)v14) >> 2);
        *(_DWORD *)(this + 16) = v16;
      }
      if ( v4 != &Src )
        sub_10017F00((void **)(this + 20), (char *)Src, (v18 - (int)Src) >> 3);
      if ( (unsigned __int8)sub_10015FD0(*(_DWORD *)(a2 + 12)) )
        break;
      a2 = *(_DWORD *)(a2 + 24);
      if ( !a2 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(this + 108) )
    {
      sub_100181C0(&v9, (_DWORD *)this);
      LOBYTE(v21) = 1;
      v7 = *(_DWORD *)(a2 + 24);
      v20 = *(_DWORD *)this - v13;
      for ( i = v7; i; i = *(_DWORD *)(i + 24) )
      {
        *(_DWORD *)this = v13;
        if ( v3 != &v14 )
        {
          sub_10018060((void **)(this + 4), (char *)v14, (v15 - (int)v14) >> 2);
          *(_DWORD *)(this + 16) = v16;
        }
        if ( v4 != &Src )
          sub_10017F00((void **)(this + 20), (char *)Src, (v18 - (int)Src) >> 3);
        if ( (unsigned __int8)sub_10015FD0(*(_DWORD *)(i + 12)) )
        {
          v8 = *(_DWORD *)this;
          v19 = *(_DWORD *)this - v13;
          if ( v20 < v19 )
          {
            v9 = v8;
            if ( v10 != v3 )
            {
              sub_10018060(v10, (char *)*v3, (*(_DWORD *)(this + 8) - *(_DWORD *)(this + 4)) >> 2);
              v11 = *(_DWORD *)(this + 16);
            }
            if ( v12 != v4 )
              sub_10017F00(v12, (char *)*v4, (*(_DWORD *)(this + 24) - *(_DWORD *)(this + 20)) >> 3);
            v20 = v19;
          }
        }
      }
      *(_DWORD *)this = v9;
      if ( v3 != v10 )
      {
        sub_10018060((void **)(this + 4), (char *)v10[0], (v10[1] - v10[0]) >> 2);
        *(_DWORD *)(this + 16) = v11;
      }
      if ( v4 != v12 )
        sub_10017F00((void **)(this + 20), (char *)v12[0], (v12[1] - v12[0]) >> 3);
      v5 = 1;
      sub_10014220(&v9);
    }
    else
    {
      v5 = 1;
    }
  }
  else
  {
LABEL_9:
    v5 = 0;
  }
  sub_10014220(&v13);
  return v5;
}
// 10015FD0: using guessed type _DWORD __stdcall sub_10015FD0(_DWORD);

//----- (10017400) --------------------------------------------------------
char __thiscall sub_10017400(int this, _DWORD *a2, char a3, int a4)
{
  int v7; // ecx
  int v8; // eax
  void **v9; // edx
  int *v10; // ebx
  void *v11; // eax
  bool v12; // al
  int v13; // edx
  int v14; // eax
  int v15; // [esp+8h] [ebp-3Ch] BYREF
  void *v16; // [esp+Ch] [ebp-38h] BYREF
  int v17; // [esp+10h] [ebp-34h]
  int v18; // [esp+18h] [ebp-2Ch]
  void *Src; // [esp+1Ch] [ebp-28h] BYREF
  int v20; // [esp+20h] [ebp-24h]
  void **v21; // [esp+28h] [ebp-1Ch]
  int v22; // [esp+2Ch] [ebp-18h]
  void *v23; // [esp+30h] [ebp-14h] BYREF
  bool v24; // [esp+37h] [ebp-Dh]
  int v25; // [esp+40h] [ebp-4h]
  char v26; // [esp+4Fh] [ebp+Bh]

  if ( a2[9] == 1 )
    return sub_100190E0((void **)this, a2, a3);
  v26 = 0;
  sub_100181C0(&v15, (_DWORD *)this);
  v25 = 0;
  v7 = a2[8];
  v8 = *(_DWORD *)(this + 64);
  v9 = *(void ***)(v8 + 8 * v7 + 4);
  v10 = (int *)(v8 + 8 * v7);
  v22 = *v10;
  v11 = *(void **)this;
  v21 = v9;
  v23 = v11;
  v12 = !a4 || *v9 != v11;
  v13 = a2[6];
  v24 = v12;
  if ( v13 >= 0 && v13 <= a4 )
    goto LABEL_28;
  if ( a4 < a2[5] )
  {
    if ( v12 )
    {
      *v10 = a4 + 1;
      v10[1] = (int)&v23;
      v14 = a2[3];
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  if ( a3 )
  {
    if ( v12 )
    {
      *v10 = a4 + 1;
      v10[1] = (int)&v23;
      v26 = sub_10015FD0(a2[3]);
      if ( v26 )
        goto LABEL_34;
    }
    else if ( a4 > 1 )
    {
      goto LABEL_30;
    }
    *v10 = v22;
    v10[1] = (int)v21;
    *(_DWORD *)this = v15;
    if ( (void **)(this + 4) != &v16 )
    {
      sub_10018060((void **)(this + 4), (char *)v16, (v17 - (int)v16) >> 2);
      *(_DWORD *)(this + 16) = v18;
    }
    if ( (void **)(this + 20) != &Src )
      sub_10017F00((void **)(this + 20), (char *)Src, (v20 - (int)Src) >> 3);
LABEL_28:
    v14 = *(_DWORD *)(a2[7] + 12);
    goto LABEL_29;
  }
  v26 = sub_10015FD0(*(_DWORD *)(a2[7] + 12));
  if ( v26 )
    goto LABEL_34;
  if ( !v24 )
  {
LABEL_30:
    *(_DWORD *)this = v15;
    if ( (void **)(this + 4) != &v16 )
    {
      sub_10018060((void **)(this + 4), (char *)v16, (v17 - (int)v16) >> 2);
      *(_DWORD *)(this + 16) = v18;
    }
    if ( (void **)(this + 20) != &Src )
      sub_10017F00((void **)(this + 20), (char *)Src, (v20 - (int)Src) >> 3);
    goto LABEL_34;
  }
  *(_DWORD *)this = v15;
  if ( (void **)(this + 4) != &v16 )
  {
    sub_10018060((void **)(this + 4), (char *)v16, (v17 - (int)v16) >> 2);
    *(_DWORD *)(this + 16) = v18;
  }
  if ( (void **)(this + 20) != &Src )
    sub_10017F00((void **)(this + 20), (char *)Src, (v20 - (int)Src) >> 3);
  *v10 = a4 + 1;
  v10[1] = (int)&v23;
  v14 = a2[3];
LABEL_29:
  v26 = sub_10015FD0(v14);
  if ( !v26 )
    goto LABEL_30;
LABEL_34:
  *v10 = v22;
  v10[1] = (int)v21;
  sub_10014220(&v15);
  return v26;
}
// 10015FD0: using guessed type _DWORD __stdcall sub_10015FD0(_DWORD);

//----- (10017640) --------------------------------------------------------
bool __thiscall sub_10017640(_DWORD *this)
{
  unsigned int v2; // eax
  int i; // esi
  int v4; // ebx
  int v5; // ebx
  int v6; // edx
  int v7; // ecx
  int v8; // edx

  v2 = 0;
  if ( !this[26] )
    return 0;
  for ( i = 0; ; i += 8 )
  {
    v4 = 1 << (v2 & 0x1F);
    if ( (v4 & *(_DWORD *)(this[9] + 4 * (v2 >> 5))) == 0 || (v4 & *(_DWORD *)(this[1] + 4 * (v2 >> 5))) == 0 )
      goto LABEL_7;
    v5 = this[5];
    v6 = *(_DWORD *)(i + this[13]);
    v7 = *(_DWORD *)(i + v5);
    if ( v6 != v7 )
      break;
    v8 = this[13];
    if ( *(_DWORD *)(i + v8 + 4) != *(_DWORD *)(i + v5 + 4) )
      return *(_DWORD *)(v8 + 8 * v2 + 4) - this[19] < *(_DWORD *)(v5 + 8 * v2 + 4) - this[19];
LABEL_7:
    if ( ++v2 >= this[26] )
      return 0;
  }
  return v6 - this[19] < v7 - this[19];
}

//----- (100176E0) --------------------------------------------------------
void ***__fastcall sub_100176E0(void ***a1, int a2, void **Src, char *a4, char *a5)
{
  int v5; // eax
  char *v6; // esi
  int v7; // ebx
  void **v8; // ecx
  char v9; // dl
  char **v10; // edi
  char *v11; // edi
  unsigned int v12; // ebx
  unsigned int v13; // edi
  unsigned int v14; // ebx
  void *v15; // ecx
  void ***result; // eax
  void **v17; // [esp+18h] [ebp-1Ch] BYREF
  void **v18; // [esp+1Ch] [ebp-18h] BYREF
  int v19; // [esp+20h] [ebp-14h]
  char v20[4]; // [esp+24h] [ebp-10h]
  int v21; // [esp+28h] [ebp-Ch]
  void ***v22; // [esp+2Ch] [ebp-8h]
  int v23; // [esp+30h] [ebp-4h]

  v5 = (int)a5;
  v6 = a4;
  v7 = a2;
  v23 = a2;
  v22 = a1;
  if ( a4 != a5 )
  {
    v8 = Src;
    while ( 1 )
    {
      v9 = *v6++;
      if ( v9 == 38 )
      {
        v10 = *(char ***)(v7 + 8);
        if ( (*(_DWORD *)(v7 + 12) - (int)v10) / 12 )
        {
          v8 = *sub_100165F0(&v18, *v10, v10[1], v8);
          Src = v8;
        }
        goto LABEL_21;
      }
      if ( v9 == 92 )
      {
        if ( v6 == (char *)v5 )
        {
          result = v22;
          *v22 = v8;
          return result;
        }
        v9 = *v6++;
        if ( (unsigned __int8)(v9 - 48) <= 9u )
        {
          v13 = v9 - 48;
          if ( v13 < (*(_DWORD *)(v7 + 12) - *(_DWORD *)(v7 + 8)) / 12 )
          {
            v8 = *sub_100165F0(
                    &v17,
                    *(char **)(*(_DWORD *)(v7 + 8) + 12 * v13),
                    *(char **)(*(_DWORD *)(v7 + 8) + 12 * v13 + 4),
                    v8);
            Src = v8;
          }
          goto LABEL_21;
        }
        v11 = (char *)v8[4];
        v14 = (unsigned int)v8[5];
        v20[0] = v9;
        if ( (unsigned int)v11 >= v14 )
        {
          LOBYTE(v19) = 0;
          sub_100068E0(v8, (int)v8, v19, v20[0]);
          goto LABEL_20;
        }
        v8[4] = v11 + 1;
        if ( v14 >= 0x10 )
        {
          v15 = *v8;
          v11[(_DWORD)v15] = v9;
          v11[(_DWORD)v15 + 1] = 0;
          goto LABEL_20;
        }
      }
      else
      {
        v11 = (char *)v8[4];
        v12 = (unsigned int)v8[5];
        if ( (unsigned int)v11 >= v12 )
        {
          LOBYTE(v21) = 0;
          sub_100068E0(v8, (int)v8, v21, v9);
          goto LABEL_20;
        }
        v8[4] = v11 + 1;
        if ( v12 >= 0x10 )
          v8 = (void **)*v8;
      }
      v11[(_DWORD)v8] = v9;
      v11[(_DWORD)v8 + 1] = 0;
LABEL_20:
      v7 = v23;
      v8 = Src;
LABEL_21:
      v5 = (int)a5;
      if ( v6 == a5 )
      {
        result = v22;
        *v22 = v8;
        return result;
      }
    }
  }
  *a1 = Src;
  return a1;
}

//----- (10017850) --------------------------------------------------------
void ***__fastcall sub_10017850(unsigned int a1, int a2, void **Src, char *a4, char *a5)
{
  int v6; // edx
  char *v7; // edi
  void **v8; // esi
  unsigned int v9; // edx
  unsigned int v10; // ebx
  char v11; // cl
  unsigned int v12; // edx
  char **v13; // ebx
  unsigned int v14; // ebx
  char v15; // dl
  unsigned int v16; // ecx
  unsigned int v17; // edx
  char *v18; // eax
  unsigned int v19; // edx
  char *v20; // eax
  unsigned int v21; // edx
  unsigned int v22; // ecx
  unsigned int v23; // edx
  char *v24; // eax
  char v25; // dl
  unsigned int v26; // ebx
  void ***result; // eax
  unsigned int v28; // ecx
  unsigned int v29; // edx
  void ***v30; // ebx
  void ***v31; // ecx
  void **v32; // [esp+14h] [ebp-3Ch] BYREF
  void **v33; // [esp+18h] [ebp-38h] BYREF
  void **v34; // [esp+1Ch] [ebp-34h] BYREF
  void **v35; // [esp+20h] [ebp-30h] BYREF
  int v36; // [esp+24h] [ebp-2Ch]
  char v37[4]; // [esp+28h] [ebp-28h]
  int v38; // [esp+2Ch] [ebp-24h]
  int v39; // [esp+30h] [ebp-20h]
  int v40; // [esp+34h] [ebp-1Ch]
  int v41; // [esp+38h] [ebp-18h]
  int v42; // [esp+3Ch] [ebp-14h]
  int v43; // [esp+40h] [ebp-10h]
  int v44; // [esp+44h] [ebp-Ch]
  int v45; // [esp+48h] [ebp-8h]
  void ***v46; // [esp+4Ch] [ebp-4h]
  char v47; // [esp+5Fh] [ebp+Fh]

  v6 = (int)a5;
  v7 = a4;
  v45 = a2;
  v46 = (void ***)a1;
  if ( a4 == a5 )
  {
    *(_DWORD *)a1 = Src;
    return (void ***)a1;
  }
  v8 = Src;
  while ( 1 )
  {
    LOBYTE(a1) = *v7++;
    if ( (_BYTE)a1 != 36 )
    {
      v9 = (unsigned int)v8[4];
      v10 = (unsigned int)v8[5];
      LOBYTE(v44) = a1;
      if ( v9 >= v10 )
      {
        LOBYTE(v43) = 0;
        sub_100068E0(v8, a1, v43, v44);
      }
      else
      {
        v8[4] = (void *)(v9 + 1);
        if ( v10 >= 0x10 )
          v8 = (void **)*v8;
        *((_BYTE *)v8 + v9) = a1;
        *((_BYTE *)v8 + v9 + 1) = 0;
      }
LABEL_57:
      v8 = Src;
      goto LABEL_58;
    }
    if ( v7 == (char *)v6 )
      break;
    v11 = *v7;
    if ( *v7 == 36 )
    {
      a1 = (unsigned int)v8[4];
      v12 = (unsigned int)v8[5];
      if ( a1 >= v12 )
      {
        LOBYTE(v42) = 0;
        sub_100068E0(v8, a1, v42, 36);
        ++v7;
      }
      else
      {
        v8[4] = (void *)(a1 + 1);
        if ( v12 >= 0x10 )
          v8 = (void **)*v8;
        *(_WORD *)((char *)v8 + a1) = 36;
        ++v7;
      }
      goto LABEL_57;
    }
    switch ( v11 )
    {
      case '`':
        ++v7;
        v8 = *sub_100165F0(&v35, *(char **)(a2 + 20), *(char **)(a2 + 24), v8);
        Src = v8;
        break;
      case '\'':
        ++v7;
        v8 = *sub_100165F0(&v34, *(char **)(a2 + 32), *(char **)(a2 + 36), v8);
        Src = v8;
        break;
      case '&':
        ++v7;
        v13 = *(char ***)(a2 + 8);
        a1 = *(_DWORD *)(a2 + 12) - (_DWORD)v13;
        if ( (int)a1 / 12 )
        {
          v8 = *sub_100165F0(&v33, *v13, v13[1], v8);
          Src = v8;
        }
        break;
      default:
        if ( (unsigned __int8)(v11 - 48) > 9u )
        {
          v22 = (unsigned int)v8[4];
          v23 = (unsigned int)v8[5];
          if ( v22 >= v23 )
          {
            LOBYTE(v38) = 0;
            sub_100068E0(v8, v22, v38, 36);
          }
          else
          {
            v8[4] = (void *)(v22 + 1);
            v24 = (char *)v8;
            if ( v23 >= 0x10 )
              v24 = (char *)*v8;
            *(_WORD *)&v24[v22] = 36;
          }
          v25 = *v7++;
          a1 = (unsigned int)v8[4];
          v26 = (unsigned int)v8[5];
          v37[0] = v25;
          if ( a1 >= v26 )
          {
            LOBYTE(v36) = 0;
            sub_100068E0(v8, a1, v36, v37[0]);
          }
          else
          {
            v8[4] = (void *)(a1 + 1);
            if ( v26 >= 0x10 )
              v8 = (void **)*v8;
            *((_BYTE *)v8 + a1) = v25;
            *((_BYTE *)v8 + a1 + 1) = 0;
          }
        }
        else
        {
          ++v7;
          v14 = v11 - 48;
          if ( v7 == (char *)v6 || (v15 = *v7, (unsigned __int8)(*v7 - 48) > 9u) )
          {
            v47 = 0;
          }
          else
          {
            v47 = 1;
            ++v7;
            v14 = v15 + 2 * (5 * v14 - 24);
          }
          if ( v14 )
          {
            a1 = *(_DWORD *)(v45 + 12) - *(_DWORD *)(v45 + 8);
            if ( v14 < (int)a1 / 12 )
            {
              v8 = *sub_100165F0(
                      &v32,
                      *(char **)(*(_DWORD *)(v45 + 8) + 12 * v14),
                      *(char **)(*(_DWORD *)(v45 + 8) + 12 * v14 + 4),
                      v8);
              Src = v8;
            }
            break;
          }
          v16 = (unsigned int)v8[4];
          v17 = (unsigned int)v8[5];
          if ( v16 >= v17 )
          {
            LOBYTE(v41) = 0;
            sub_100068E0(v8, v16, v41, 36);
          }
          else
          {
            v8[4] = (void *)(v16 + 1);
            v18 = (char *)v8;
            if ( v17 >= 0x10 )
              v18 = (char *)*v8;
            *(_WORD *)&v18[v16] = 36;
          }
          a1 = (unsigned int)v8[4];
          v19 = (unsigned int)v8[5];
          if ( a1 >= v19 )
          {
            LOBYTE(v40) = 0;
            sub_100068E0(v8, a1, v40, 48);
          }
          else
          {
            v8[4] = (void *)(a1 + 1);
            v20 = (char *)v8;
            if ( v19 >= 0x10 )
              v20 = (char *)*v8;
            *(_WORD *)&v20[a1] = 48;
          }
          if ( v47 )
          {
            a1 = (unsigned int)v8[4];
            v21 = (unsigned int)v8[5];
            if ( a1 >= v21 )
            {
              LOBYTE(v39) = 0;
              sub_100068E0(v8, a1, v39, 48);
            }
            else
            {
              v8[4] = (void *)(a1 + 1);
              if ( v21 >= 0x10 )
                v8 = (void **)*v8;
              *(_WORD *)((char *)v8 + a1) = 48;
            }
          }
        }
        goto LABEL_57;
    }
LABEL_58:
    v6 = (int)a5;
    a2 = v45;
    if ( v7 == a5 )
    {
      result = v46;
      *v46 = v8;
      return result;
    }
  }
  v28 = (unsigned int)v8[4];
  v29 = (unsigned int)v8[5];
  if ( v28 >= v29 )
  {
    LOBYTE(a5) = 0;
    sub_100068E0(v8, v28, (int)a5, 36);
    v31 = v46;
    *v46 = Src;
    return v31;
  }
  else
  {
    v8[4] = (void *)(v28 + 1);
    if ( v29 >= 0x10 )
      v8 = (void **)*v8;
    v30 = v46;
    *(_WORD *)((char *)v8 + v28) = 36;
    *v30 = Src;
    return v30;
  }
}
// 100178AD: variable 'a1' is possibly undefined

//----- (10017B90) --------------------------------------------------------
_DWORD *__thiscall sub_10017B90(int this, unsigned int a2, int a3)
{
  unsigned int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // ebx
  _DWORD *v8; // eax
  _DWORD *result; // eax
  int v10; // [esp+Ch] [ebp-4h]
  _DWORD *v11; // [esp+18h] [ebp+8h]

  if ( a2 > 0x1FFFFFFF )
    sub_10008240();
  v10 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  v5 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3;
  v6 = (unsigned int)((*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3) >> 1;
  if ( v5 <= 0x1FFFFFFF - v6 )
  {
    v7 = v6 + v5;
    if ( v6 + v5 < a2 )
      v7 = a2;
  }
  else
  {
    v7 = 0x1FFFFFFF;
  }
  v11 = sub_100183D0(v7);
  if ( a2 != v10 )
    memset(&v11[2 * v10], 0, 8 * (a2 - v10));
  memmove(v11, *(const void **)this, *(_DWORD *)(this + 4) - *(_DWORD *)this);
  v8 = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    if ( ((*(_DWORD *)(this + 8) - (_DWORD)v8) & 0xFFFFFFF8) >= 0x1000 )
    {
      if ( (unsigned int)v8 - *(v8 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v8 = (_DWORD *)*(v8 - 1);
    }
    sub_1001D481(v8);
  }
  *(_DWORD *)this = v11;
  *(_DWORD *)(this + 4) = &v11[2 * a2];
  result = &v11[2 * v7];
  *(_DWORD *)(this + 8) = result;
  return result;
}
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10017C70) --------------------------------------------------------
char *__thiscall sub_10017C70(int this, unsigned int a2, int a3)
{
  unsigned int v4; // ecx
  unsigned int v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  void *v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  unsigned int v11; // ecx
  void *v12; // edi
  char *result; // eax
  int v14; // [esp+Ch] [ebp-8h]

  if ( a2 > 0x15555555 )
    sub_10008240();
  v14 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) / 12;
  v4 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) / 12;
  v5 = v4 >> 1;
  if ( v4 > 357913941 - (v4 >> 1) )
    goto LABEL_21;
  v6 = v5 + v4;
  if ( v5 + v4 >= a2 )
  {
    if ( v6 > 0x15555555 )
      goto LABEL_21;
  }
  else
  {
    v6 = a2;
  }
  v7 = 12 * v6;
  if ( 12 * v6 < 0x1000 )
  {
    if ( v7 )
      v9 = operator new(12 * v6);
    else
      v9 = 0;
    goto LABEL_13;
  }
  if ( v7 + 35 <= v7 )
LABEL_21:
    sub_10001240();
  v8 = operator new(v7 + 35);
  if ( !v8 )
    goto LABEL_23;
  v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
  *(v9 - 1) = v8;
LABEL_13:
  v10 = &v9[3 * v14];
  v11 = a2 - v14;
  if ( a2 != v14 )
  {
    do
    {
      *v10 = 0;
      v10 += 3;
      *(v10 - 2) = 0;
      *((_BYTE *)v10 - 4) = 0;
      --v11;
    }
    while ( v11 );
  }
  memmove(v9, *(const void **)this, *(_DWORD *)(this + 4) - *(_DWORD *)this);
  v12 = *(void **)this;
  if ( v12 )
  {
    if ( (unsigned int)(12 * ((*(_DWORD *)(this + 8) - (int)v12) / 12)) < 0x1000 )
    {
LABEL_19:
      sub_1001D481(v12);
      goto LABEL_20;
    }
    if ( (unsigned int)v12 - *((_DWORD *)v12 - 1) - 4 <= 0x1F )
    {
      v12 = (void *)*((_DWORD *)v12 - 1);
      goto LABEL_19;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_20:
  *(_DWORD *)this = v9;
  *(_DWORD *)(this + 4) = &v9[3 * a2];
  result = (char *)&v9[v7 / 4];
  *(_DWORD *)(this + 8) = &v9[v7 / 4];
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10017DF0) --------------------------------------------------------
char *__thiscall sub_10017DF0(int this, unsigned int a2, _DWORD *a3)
{
  unsigned int v4; // ecx
  unsigned int v5; // edx
  unsigned int v6; // ebx
  char *v7; // eax
  unsigned int v8; // edx
  char *v9; // ecx
  unsigned int v10; // edi
  _DWORD *v11; // eax
  char *result; // eax
  int v13; // [esp+10h] [ebp-8h]
  char *v14; // [esp+14h] [ebp-4h]

  if ( a2 > 0x3FFFFFFF )
    sub_10008240();
  v13 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
  v4 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
  v5 = (unsigned int)((*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2) >> 1;
  if ( v4 <= 0x3FFFFFFF - v5 )
  {
    v6 = v5 + v4;
    if ( v5 + v4 < a2 )
      v6 = a2;
  }
  else
  {
    v6 = 0x3FFFFFFF;
  }
  v7 = (char *)sub_10015A60(v6);
  v8 = a2 - v13;
  v14 = v7;
  v9 = &v7[4 * v13];
  v10 = a2;
  if ( *a3 )
  {
    if ( v8 )
    {
      do
      {
        v9 += 4;
        *((_DWORD *)v9 - 1) = *a3;
        --v8;
      }
      while ( v8 );
      v10 = a2;
    }
  }
  else
  {
    memset(v9, 0, 4 * v8);
  }
  memmove(v14, *(const void **)this, *(_DWORD *)(this + 4) - *(_DWORD *)this);
  v11 = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    if ( ((*(_DWORD *)(this + 8) - (_DWORD)v11) & 0xFFFFFFFC) >= 0x1000 )
    {
      if ( (unsigned int)v11 - *(v11 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v11 = (_DWORD *)*(v11 - 1);
    }
    sub_1001D481(v11);
  }
  *(_DWORD *)this = v14;
  *(_DWORD *)(this + 4) = &v14[4 * v10];
  result = &v14[4 * v6];
  *(_DWORD *)(this + 8) = result;
  return result;
}
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10017F00) --------------------------------------------------------
char *__thiscall sub_10017F00(void **this, char *Src, unsigned int a3)
{
  char *v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // edi
  _DWORD *v8; // edi
  char *result; // eax
  unsigned int v10; // eax
  int v11; // esi
  size_t v12; // ebx
  char *v13; // esi
  char *v14; // [esp-14h] [ebp-28h]
  char *v15; // [esp+Ch] [ebp-8h]
  int v17; // [esp+20h] [ebp+Ch]
  int v18; // [esp+20h] [ebp+Ch]

  v5 = (char *)*this;
  v15 = v5;
  v6 = ((_BYTE *)this[2] - v5) >> 3;
  if ( a3 <= v6 )
  {
    v10 = ((_BYTE *)this[1] - v5) >> 3;
    v18 = v10;
    if ( a3 <= v10 )
    {
      memmove(v5, Src, 8 * a3);
      result = &v15[8 * a3];
      this[1] = result;
    }
    else
    {
      v11 = 8 * v10;
      memmove(v5, Src, 8 * v10);
      v12 = 8 * (a3 - v18);
      v14 = &Src[v11];
      v13 = (char *)this[1];
      memmove(v13, v14, v12);
      result = &v13[v12];
      this[1] = &v13[v12];
    }
  }
  else
  {
    if ( a3 > 0x1FFFFFFF )
      sub_10008240();
    if ( v6 <= 0x1FFFFFFF - (v6 >> 1) )
    {
      v7 = v6 + (v6 >> 1);
      v17 = v7;
      if ( v7 < a3 )
      {
        v7 = a3;
        v17 = a3;
      }
    }
    else
    {
      v7 = 0x1FFFFFFF;
      v17 = 0x1FFFFFFF;
    }
    if ( v5 )
    {
      if ( 8 * v6 >= 0x1000 )
      {
        if ( (unsigned int)&v5[-*((_DWORD *)v5 - 1) - 4] > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v5 = (char *)*((_DWORD *)v5 - 1);
      }
      sub_1001D481(v5);
      *this = 0;
      this[1] = 0;
      this[2] = 0;
    }
    v8 = sub_100183D0(v7);
    *this = v8;
    this[1] = v8;
    this[2] = &v8[2 * v17];
    memmove(v8, Src, 8 * a3);
    result = (char *)&v8[2 * a3];
    this[1] = result;
  }
  return result;
}
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10018060) --------------------------------------------------------
char *__thiscall sub_10018060(void **this, char *Src, unsigned int a3)
{
  char *v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // edi
  _DWORD *v8; // edi
  char *result; // eax
  unsigned int v10; // eax
  int v11; // esi
  size_t v12; // ebx
  char *v13; // esi
  char *v14; // [esp-14h] [ebp-28h]
  char *v15; // [esp+Ch] [ebp-8h]
  int v17; // [esp+20h] [ebp+Ch]
  int v18; // [esp+20h] [ebp+Ch]

  v5 = (char *)*this;
  v15 = v5;
  v6 = ((_BYTE *)this[2] - v5) >> 2;
  if ( a3 <= v6 )
  {
    v10 = ((_BYTE *)this[1] - v5) >> 2;
    v18 = v10;
    if ( a3 <= v10 )
    {
      memmove(v5, Src, 4 * a3);
      result = &v15[4 * a3];
      this[1] = result;
    }
    else
    {
      v11 = 4 * v10;
      memmove(v5, Src, 4 * v10);
      v12 = 4 * (a3 - v18);
      v14 = &Src[v11];
      v13 = (char *)this[1];
      memmove(v13, v14, v12);
      result = &v13[v12];
      this[1] = &v13[v12];
    }
  }
  else
  {
    if ( a3 > 0x3FFFFFFF )
      sub_10008240();
    if ( v6 <= 0x3FFFFFFF - (v6 >> 1) )
    {
      v7 = v6 + (v6 >> 1);
      v17 = v7;
      if ( v7 < a3 )
      {
        v7 = a3;
        v17 = a3;
      }
    }
    else
    {
      v7 = 0x3FFFFFFF;
      v17 = 0x3FFFFFFF;
    }
    if ( v5 )
    {
      if ( 4 * v6 >= 0x1000 )
      {
        if ( (unsigned int)&v5[-*((_DWORD *)v5 - 1) - 4] > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v5 = (char *)*((_DWORD *)v5 - 1);
      }
      sub_1001D481(v5);
      *this = 0;
      this[1] = 0;
      this[2] = 0;
    }
    v8 = sub_10015A60(v7);
    *this = v8;
    this[1] = v8;
    this[2] = &v8[v17];
    memmove(v8, Src, 4 * a3);
    result = (char *)&v8[a3];
    this[1] = result;
  }
  return result;
}
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (100181C0) --------------------------------------------------------
_DWORD *__thiscall sub_100181C0(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // esi
  _DWORD *v4; // eax
  char *v5; // edi
  const void *v6; // eax
  signed int v7; // esi

  sub_10016900(this, a2);
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  v3 = (a2[6] - a2[5]) >> 3;
  if ( v3 )
  {
    if ( v3 > 0x1FFFFFFF )
      sub_10008240();
    v4 = sub_100183D0((a2[6] - a2[5]) >> 3);
    this[5] = v4;
    this[6] = v4;
    this[7] = &v4[2 * v3];
    v5 = (char *)this[5];
    v6 = (const void *)a2[5];
    v7 = a2[6] - (_DWORD)v6;
    memmove(v5, v6, v7);
    this[6] = &v5[8 * (v7 >> 3)];
  }
  return this;
}
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (100182C0) --------------------------------------------------------
bool __thiscall sub_100182C0(_DWORD *this, char a2, char a3)
{
  _DWORD *v3; // esi
  void *v4; // ecx
  void **v5; // eax
  char v6; // bh
  int v7; // ecx
  void *v8; // ecx
  void **v9; // eax
  char v10; // bl
  char v12; // [esp+14h] [ebp-3Ch] BYREF
  _BYTE v13[3]; // [esp+15h] [ebp-3Bh] BYREF
  char v14; // [esp+18h] [ebp-38h] BYREF
  char v15[7]; // [esp+19h] [ebp-37h] BYREF
  void *Block[4]; // [esp+20h] [ebp-30h] BYREF
  int v17; // [esp+30h] [ebp-20h]
  unsigned int v18; // [esp+34h] [ebp-1Ch]
  void *v19[5]; // [esp+38h] [ebp-18h] BYREF
  unsigned int v20; // [esp+4Ch] [ebp-4h]

  v3 = (_DWORD *)*this;
  v12 = a3;
  (*(void (__thiscall **)(_DWORD, void **, char *, _BYTE *))(*(_DWORD *)*v3 + 16))(*v3, Block, &v12, v13);
  v4 = Block[0];
  if ( v17 == 1 )
  {
    v5 = Block;
    if ( v18 >= 0x10 )
      v5 = (void **)Block[0];
    v6 = *(_BYTE *)v5;
  }
  else
  {
    v6 = v12;
  }
  if ( v18 >= 0x10 )
  {
    if ( v18 + 1 >= 0x1000 )
    {
      v4 = (void *)*((_DWORD *)Block[0] - 1);
      if ( (unsigned int)(Block[0] - v4 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v4);
  }
  v7 = *v3;
  v17 = 0;
  v18 = 15;
  LOBYTE(Block[0]) = 0;
  v14 = a2;
  (*(void (__thiscall **)(int, void **, char *, char *))(*(_DWORD *)v7 + 16))(v7, v19, &v14, v15);
  v8 = v19[0];
  if ( v19[4] == (void *)1 )
  {
    v9 = v19;
    if ( v20 >= 0x10 )
      v9 = (void **)v19[0];
    v10 = *(_BYTE *)v9;
  }
  else
  {
    v10 = v14;
  }
  if ( v20 >= 0x10 )
  {
    if ( v20 + 1 >= 0x1000 )
    {
      v8 = (void *)*((_DWORD *)v19[0] - 1);
      if ( (unsigned int)(v19[0] - v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v8);
  }
  return v10 == v6;
}
// 100182C0: using guessed type char var_37[7];

//----- (100183D0) --------------------------------------------------------
_DWORD *__stdcall sub_100183D0(unsigned int a1)
{
  size_t v1; // eax
  void *v2; // eax
  void *v3; // ecx
  _DWORD *result; // eax

  if ( a1 > 0x1FFFFFFF )
    goto LABEL_9;
  v1 = 8 * a1;
  if ( 8 * a1 < 0x1000 )
  {
    if ( v1 )
      return operator new(v1);
    else
      return 0;
  }
  if ( v1 + 35 <= v1 )
LABEL_9:
    sub_10001240();
  v2 = operator new(v1 + 35);
  v3 = v2;
  if ( !v2 )
    _invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v2 + 35) & 0xFFFFFFE0);
  *(result - 1) = v3;
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);

//----- (10018430) --------------------------------------------------------
char __thiscall sub_10018430(int this, char a2)
{
  char *v3; // ecx
  unsigned __int16 v4; // bx
  char *v5; // eax
  char *v6; // edx
  _BYTE *v7; // ecx
  int v8; // edx

  v3 = *(char **)this;
  if ( v3 == *(char **)(this + 8) )
    return 0;
  v4 = sub_10019AF0(*(_DWORD ***)(this + 60), v3, v3 + 1, BYTE1(*(_DWORD *)(this + 64)) & 1);
  if ( !v4 )
    return 0;
  if ( a2 )
    sub_10018D90((_DWORD *)(this + 36));
  sub_10019990(
    (_DWORD *)(this + 36),
    v4,
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 60) + 4) + 12) + 2 * *(unsigned __int8 *)(this + 72)) & 1);
  v5 = *(char **)this;
  v6 = *(char **)(this + 8);
  if ( *(char **)this != v6 )
  {
    if ( *v5 == 92 )
    {
      v7 = v5 + 1;
      if ( v5 + 1 != v6 )
      {
        if ( (v8 = *(_DWORD *)(this + 80), (v8 & 8) == 0) && (*v7 == 40 || *v7 == 41)
          || (v8 & 0x10) == 0 && (*v7 == 123 || *v7 == 125) )
        {
          ++v5;
        }
      }
    }
    *(_DWORD *)this = v5 + 1;
  }
  sub_100143D0((_BYTE *)this);
  return 1;
}

//----- (100184F0) --------------------------------------------------------
int __thiscall sub_100184F0(int this)
{
  int result; // eax
  unsigned __int8 v3; // bl
  _BYTE *v4; // eax
  _BYTE *v5; // edx
  _BYTE *v6; // ecx
  int v7; // edx
  unsigned __int8 v8; // bl
  int v9; // eax
  int v10; // edx
  void *v11; // ecx
  void **v12; // eax
  char v13; // bh
  _DWORD *v14; // eax
  void *v15; // ecx
  void **v16; // eax
  bool v17; // zf
  int v18; // edi
  _DWORD *v19; // ecx
  unsigned __int8 v20; // bl
  int v21; // edi
  _DWORD *v22; // ecx
  unsigned int v23; // edx
  unsigned __int8 v24; // bl
  int v25; // esi
  _DWORD *v26; // ecx
  _BYTE *v27; // ecx
  unsigned __int8 v28; // [esp+18h] [ebp-28h] BYREF
  char v29[3]; // [esp+19h] [ebp-27h] BYREF
  int v30; // [esp+1Ch] [ebp-24h]
  int v31; // [esp+20h] [ebp-20h]
  _DWORD *v32; // [esp+24h] [ebp-1Ch]
  void *Block[4]; // [esp+28h] [ebp-18h] BYREF
  int v34; // [esp+38h] [ebp-8h]
  unsigned int v35; // [esp+3Ch] [ebp-4h]

  result = sub_100194C0(this);
  if ( !result )
    return result;
  while ( 1 )
  {
    if ( result == 2 )
      goto LABEL_47;
    if ( !*(_DWORD *)(this + 68) && (*(_DWORD *)(this + 80) & 0x100000) == 0 )
      sub_100143C0(2);
    v3 = *(_BYTE *)(this + 68);
    if ( *(_DWORD *)(this + 76) != 45 )
    {
      v17 = (*(_DWORD *)(this + 44) & 0x100) == 0;
      LOBYTE(v31) = *(_BYTE *)(this + 68);
      if ( !v17 )
        v3 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*(_DWORD *)(this + 48) + 4) + 16))(
               *(_DWORD *)(*(_DWORD *)(this + 48) + 4),
               v31);
      v18 = *(_DWORD *)(this + 40);
      v19 = *(_DWORD **)(v18 + 24);
      if ( !v19 )
      {
        v19 = operator new(0x20u);
        v32 = v19;
        *v19 = 0;
        v19[1] = 0;
        v19[2] = 0;
        v19[3] = 0;
        v19[4] = 0;
        v19[5] = 0;
        v19[6] = 0;
        v19[7] = 0;
        *(_DWORD *)(v18 + 24) = v19;
      }
      *((_BYTE *)v19 + (v3 >> 3)) |= 1 << (v3 & 7);
      goto LABEL_47;
    }
    v4 = *(_BYTE **)this;
    v5 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this != v5 )
    {
      if ( *v4 != 92 )
        goto LABEL_17;
      v6 = v4 + 1;
      if ( v4 + 1 == v5 )
        goto LABEL_17;
      v7 = *(_DWORD *)(this + 80);
      if ( (v7 & 8) == 0 )
      {
        if ( *v6 == 40 || *v6 == 41 )
        {
LABEL_16:
          v4 = v6;
LABEL_17:
          *(_DWORD *)this = v4 + 1;
          goto LABEL_18;
        }
        v4 = *(_BYTE **)this;
      }
      if ( (v7 & 0x10) != 0 || *v6 != 123 && *v6 != 125 )
        goto LABEL_17;
      goto LABEL_16;
    }
LABEL_18:
    sub_100143D0((_BYTE *)this);
    v8 = *(_BYTE *)(this + 68);
    LOBYTE(v30) = v8;
    v9 = sub_100194C0(this);
    if ( !v9 )
      break;
    if ( v9 == 2 )
      goto LABEL_61;
    if ( (*(_DWORD *)(this + 64) & 0x800) != 0 )
    {
      v28 = *(_BYTE *)(this + 68);
      (*(void (__thiscall **)(_DWORD, void **, unsigned __int8 *, char *))(***(_DWORD ***)(this + 60) + 16))(
        **(_DWORD **)(this + 60),
        Block,
        &v28,
        v29);
      v11 = Block[0];
      if ( v34 == 1 )
      {
        v12 = Block;
        if ( v35 >= 0x10 )
          v12 = (void **)Block[0];
        v13 = *(_BYTE *)v12;
      }
      else
      {
        v13 = v28;
      }
      if ( v35 >= 0x10 )
      {
        if ( v35 + 1 >= 0x1000 )
        {
          v11 = (void *)*((_DWORD *)Block[0] - 1);
          if ( (unsigned int)(Block[0] - v11 - 4) > 0x1F )
LABEL_60:
            _invalid_parameter_noinfo_noreturn();
        }
        sub_1001D481(v11);
      }
      *(_DWORD *)(this + 68) = v13;
      v14 = *(_DWORD **)(this + 60);
      v28 = v8;
      (*(void (__thiscall **)(_DWORD, void **, unsigned __int8 *, char *))(*(_DWORD *)*v14 + 16))(
        *v14,
        Block,
        &v28,
        v29);
      v10 = v35;
      v15 = Block[0];
      if ( v34 == 1 )
      {
        v16 = Block;
        if ( v35 >= 0x10 )
          v16 = (void **)Block[0];
        v8 = *(_BYTE *)v16;
      }
      else
      {
        v8 = v28;
      }
      if ( v35 >= 0x10 )
      {
        if ( v35 + 1 >= 0x1000 )
        {
          v15 = (void *)*((_DWORD *)Block[0] - 1);
          if ( (unsigned int)(Block[0] - v15 - 4) > 0x1F )
            goto LABEL_60;
        }
        sub_1001D481(v15);
      }
      LOBYTE(v30) = v8;
    }
    LOBYTE(v10) = *(_BYTE *)(this + 68);
    if ( (unsigned __int8)v10 < v8 )
LABEL_61:
      sub_100143C0(8);
    sub_10019820((_DWORD *)(this + 36), v30, v10);
LABEL_47:
    result = sub_100194C0(this);
    if ( !result )
      return result;
  }
  v17 = (*(_DWORD *)(this + 44) & 0x100) == 0;
  v20 = *(_BYTE *)(this + 68);
  LOBYTE(v31) = v20;
  if ( !v17 )
    v20 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*(_DWORD *)(this + 48) + 4) + 16))(
            *(_DWORD *)(*(_DWORD *)(this + 48) + 4),
            v31);
  v21 = *(_DWORD *)(this + 40);
  v22 = *(_DWORD **)(v21 + 24);
  if ( !v22 )
  {
    v22 = operator new(0x20u);
    v32 = v22;
    *v22 = 0;
    v22[1] = 0;
    v22[2] = 0;
    v22[3] = 0;
    v22[4] = 0;
    v22[5] = 0;
    v22[6] = 0;
    v22[7] = 0;
    *(_DWORD *)(v21 + 24) = v22;
  }
  v23 = v20;
  v24 = 45;
  *((_BYTE *)v22 + (v23 >> 3)) |= 1 << (v23 & 7);
  if ( (*(_DWORD *)(this + 44) & 0x100) != 0 )
    v24 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*(_DWORD *)(this + 48) + 4) + 16))(
            *(_DWORD *)(*(_DWORD *)(this + 48) + 4),
            45);
  v25 = *(_DWORD *)(this + 40);
  v26 = *(_DWORD **)(v25 + 24);
  if ( !v26 )
  {
    v26 = operator new(0x20u);
    v32 = v26;
    *v26 = 0;
    v26[1] = 0;
    v26[2] = 0;
    v26[3] = 0;
    v26[4] = 0;
    v26[5] = 0;
    v26[6] = 0;
    v26[7] = 0;
    *(_DWORD *)(v25 + 24) = v26;
  }
  v27 = (char *)v26 + (v24 >> 3);
  result = (unsigned __int8)*v27 | (1 << (v24 & 7));
  *v27 = result;
  return result;
}
// 100186A7: variable 'v10' is possibly undefined

//----- (10018820) --------------------------------------------------------
char __thiscall sub_10018820(int this)
{
  int v2; // ecx
  char v3; // al
  int v4; // eax
  char v5; // al
  _BYTE *v6; // eax
  _BYTE *v7; // ebx
  _BYTE *v8; // edx
  char v9; // dl
  _BYTE *v10; // edx
  _BYTE *v11; // eax
  _BYTE *v12; // ecx
  int v13; // ebx
  _BYTE *v14; // eax
  _BYTE *v15; // edi
  _BYTE *v16; // edx
  int v17; // eax
  _BYTE *v18; // eax
  _BYTE *v19; // edx
  _BYTE *v20; // eax
  unsigned int v21; // eax
  char result; // al
  unsigned int v23; // ecx
  unsigned int v24; // eax
  _BYTE *v25; // edx
  _BYTE *v26; // eax
  _BYTE *v27; // eax

  if ( *(_DWORD *)(this + 76) == -1 )
    sub_100143C0(2);
  if ( (*(_DWORD *)(this + 80) & 0x10000) != 0 && sub_100197B0((_DWORD *)this, *(_BYTE *)(this + 72)) )
    goto LABEL_25;
  v2 = *(_DWORD *)(this + 80);
  if ( (v2 & 0x8000) != 0 )
  {
    v3 = *(_BYTE *)(this + 72);
    if ( v3 == 97 )
    {
      v4 = 7;
LABEL_24:
      *(_DWORD *)(this + 68) = v4;
LABEL_25:
      v10 = *(_BYTE **)(this + 8);
      v11 = *(_BYTE **)this;
      if ( *(_BYTE **)this != v10 )
      {
        if ( *v11 == 92 )
        {
          v12 = v11 + 1;
          if ( v11 + 1 != v10 )
          {
            if ( (v13 = *(_DWORD *)(this + 80), (v13 & 8) == 0) && (*v12 == 40 || *v12 == 41)
              || (v13 & 0x10) == 0 && (*v12 == 123 || *v12 == 125) )
            {
              ++v11;
            }
          }
        }
        *(_DWORD *)this = v11 + 1;
      }
      sub_100143D0((_BYTE *)this);
LABEL_71:
      v21 = *(_DWORD *)(this + 68);
      if ( v21 <= 0xFF )
      {
        *(_DWORD *)(this + 68) = (char)v21;
        return 1;
      }
LABEL_94:
      sub_100143C0(2);
    }
    if ( v3 == 98 )
    {
      v4 = 8;
      goto LABEL_24;
    }
  }
  v5 = *(_BYTE *)(this + 72);
  if ( v5 != 99 )
  {
    if ( v5 != 120 )
    {
      if ( v5 != 117 || (v2 & 0x800) == 0 )
        goto LABEL_68;
      v18 = *(_BYTE **)this;
      v19 = *(_BYTE **)(this + 8);
      if ( *(_BYTE **)this != v19 )
      {
        if ( *v18 == 92 )
        {
          v20 = v18 + 1;
          if ( v20 != v19
            && ((v2 & 8) == 0 && (*v20 == 40 || *v20 == 41) || (v2 & 0x10) == 0 && (*v20 == 123 || *v20 == 125)) )
          {
            *(_DWORD *)this = v20;
          }
        }
        ++*(_DWORD *)this;
      }
      sub_100143D0((_BYTE *)this);
      v17 = sub_100193C0(this, 16, 4, 2);
LABEL_52:
      if ( v17 )
        goto LABEL_94;
      goto LABEL_71;
    }
    if ( (v2 & 0x1000) == 0 )
      goto LABEL_68;
    v14 = *(_BYTE **)this;
    v15 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this == v15 )
    {
LABEL_51:
      sub_100143D0((_BYTE *)this);
      v17 = sub_100193C0(this, 16, 2, 2);
      goto LABEL_52;
    }
    if ( *v14 != 92 || (v16 = v14 + 1, v14 + 1 == v15) )
    {
LABEL_50:
      *(_DWORD *)this = v14 + 1;
      goto LABEL_51;
    }
    if ( (v2 & 8) == 0 )
    {
      if ( *v16 == 40 || *v16 == 41 )
      {
LABEL_49:
        v14 = v16;
        goto LABEL_50;
      }
      v14 = *(_BYTE **)this;
    }
    if ( (v2 & 0x10) != 0 || *v16 != 123 && *v16 != 125 )
      goto LABEL_50;
    goto LABEL_49;
  }
  if ( (v2 & 0x40000) != 0 )
  {
    v6 = *(_BYTE **)this;
    v7 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this != v7 )
    {
      if ( *v6 == 92 )
      {
        v8 = v6 + 1;
        if ( v6 + 1 != v7
          && ((v2 & 8) == 0 && (*v8 == 40 || *v8 == 41) || (v2 & 0x10) == 0 && (*v8 == 123 || *v8 == 125)) )
        {
          ++v6;
        }
      }
      *(_DWORD *)this = v6 + 1;
    }
    sub_100143D0((_BYTE *)this);
    v9 = *(_BYTE *)(this + 72);
    if ( (*(_WORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 60) + 4) + 12) + 2 * (unsigned __int8)v9) & 0x103) == 0 )
      sub_100143C0(2);
    v4 = v9 % 32;
    goto LABEL_24;
  }
LABEL_68:
  if ( (v2 & 0x2000) != 0 && sub_100193C0(this, 8, 3, 2) != 3 )
  {
    if ( !*(_DWORD *)(this + 68) )
      goto LABEL_94;
    goto LABEL_71;
  }
  v23 = *(_DWORD *)(this + 80);
  if ( (v23 & 0x400000) != 0 )
  {
    switch ( *(_BYTE *)(this + 72) )
    {
      case 'D':
      case 'S':
      case 'W':
      case 'c':
      case 'd':
      case 's':
      case 'w':
        goto LABEL_91;
      default:
        goto LABEL_79;
    }
  }
  switch ( *(_BYTE *)(this + 72) )
  {
    case '"':
    case '/':
      v24 = HIBYTE(v23);
      goto LABEL_78;
    case '$':
    case '*':
    case '.':
    case '[':
    case '\\':
    case '^':
    case '|':
      goto LABEL_79;
    case '(':
    case ')':
    case '+':
    case '?':
    case '{':
    case '}':
      v24 = v23 >> 23;
LABEL_78:
      if ( (v24 & 1) == 0 )
        goto LABEL_91;
LABEL_79:
      v25 = *(_BYTE **)(this + 8);
      *(_DWORD *)(this + 68) = *(char *)(this + 72);
      v26 = *(_BYTE **)this;
      if ( *(_BYTE **)this != v25 )
      {
        if ( *v26 == 92 )
        {
          v27 = v26 + 1;
          if ( v27 != v25
            && ((v23 & 8) == 0 && (*v27 == 40 || *v27 == 41) || (v23 & 0x10) == 0 && (*v27 == 123 || *v27 == 125)) )
          {
            *(_DWORD *)this = v27;
          }
        }
        ++*(_DWORD *)this;
      }
      sub_100143D0((_BYTE *)this);
      result = 1;
      break;
    default:
LABEL_91:
      result = 0;
      break;
  }
  return result;
}

//----- (10018BB0) --------------------------------------------------------
int __thiscall sub_10018BB0(_DWORD *this)
{
  _DWORD *v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // ebx
  _DWORD *v6; // ecx
  int v7; // eax
  int result; // eax

  v2 = operator new(0x14u);
  v2[4] = 0;
  *v2 = &std::_Node_base::`vftable';
  v2[1] = 8;
  v2[2] = 0;
  v2[3] = 0;
  v2[4] = this[10];
  v3 = *(_DWORD *)(this[10] + 12);
  if ( v3 )
  {
    v2[3] = v3;
    *(_DWORD *)(*(_DWORD *)(this[10] + 12) + 16) = v2;
  }
  *(_DWORD *)(this[10] + 12) = v2;
  this[10] = v2;
  sub_10014620(this);
  v4 = v2[1];
  if ( v4 == 8 )
  {
    v5 = 9;
  }
  else if ( v4 == 10 || (v5 = 14, v4 == 11) )
  {
    v5 = 12;
  }
  v6 = operator new(0x18u);
  v6[1] = v5;
  v6[4] = 0;
  v6[2] = 0;
  v6[3] = 0;
  *v6 = &std::_Node_end_group::`vftable';
  v6[5] = v2;
  v6[4] = this[10];
  v7 = *(_DWORD *)(this[10] + 12);
  if ( v7 )
  {
    v6[3] = v7;
    *(_DWORD *)(*(_DWORD *)(this[10] + 12) + 16) = v6;
  }
  result = this[10];
  *(_DWORD *)(result + 12) = v6;
  this[10] = v6;
  return result;
}
// 10014620: using guessed type int __thiscall sub_10014620(_DWORD);
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004C204: using guessed type void *std::_Node_end_group::`vftable';

//----- (10018CA0) --------------------------------------------------------
int __thiscall sub_10018CA0(_DWORD *this, unsigned __int8 a2)
{
  _DWORD *v3; // esi
  _DWORD *v4; // ecx
  int v5; // eax
  int result; // eax

  v3 = operator new(0x18u);
  v3[1] = a2 + 10;
  v3[2] = 0;
  v3[3] = 0;
  v3[4] = 0;
  *v3 = &std::_Node_assert::`vftable';
  v3[5] = 0;
  v4 = operator new(0x14u);
  *v4 = &std::_Node_base::`vftable';
  v4[1] = 1;
  v4[2] = 0;
  v4[3] = 0;
  v4[4] = 0;
  v3[4] = this[10];
  v5 = *(_DWORD *)(this[10] + 12);
  if ( v5 )
  {
    v3[3] = v5;
    *(_DWORD *)(*(_DWORD *)(this[10] + 12) + 16) = v3;
  }
  *(_DWORD *)(this[10] + 12) = v3;
  v3[5] = v4;
  v4[4] = v3;
  this[10] = v4;
  sub_10014620(this);
  result = sub_100148C0(this + 9, (int)v3);
  this[10] = v3;
  return result;
}
// 10014620: using guessed type int __thiscall sub_10014620(_DWORD);
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004C090: using guessed type void *std::_Node_assert::`vftable';

//----- (10018D90) --------------------------------------------------------
int __thiscall sub_10018D90(_DWORD *this)
{
  _DWORD *v2; // edx
  int v3; // eax
  int result; // eax

  v2 = operator new(0x2Cu);
  v2[4] = 0;
  v2[1] = 7;
  v2[2] = 0;
  v2[3] = 0;
  *v2 = &std::_Node_class<char,std::regex_traits<char>>::`vftable';
  v2[5] = 0;
  v2[6] = 0;
  v2[7] = 0;
  v2[8] = 0;
  *((_WORD *)v2 + 18) = 0;
  v2[10] = 0;
  v2[4] = this[1];
  v3 = *(_DWORD *)(this[1] + 12);
  if ( v3 )
  {
    v2[3] = v3;
    *(_DWORD *)(*(_DWORD *)(this[1] + 12) + 16) = v2;
  }
  result = this[1];
  *(_DWORD *)(result + 12) = v2;
  this[1] = v2;
  return result;
}
// 1004C0D4: using guessed type void *std::_Node_class<char,std::regex_traits<char>>::`vftable';

//----- (10018E20) --------------------------------------------------------
int __thiscall sub_10018E20(_DWORD *this, int a2, int a3, unsigned __int8 a4)
{
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD *v7; // edi
  int v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  int v11; // eax
  int result; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // ecx
  int v16; // esi
  int v17; // eax
  _DWORD *v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+10h] [ebp-4h]
  _DWORD *v20; // [esp+10h] [ebp-4h]
  _DWORD *v21; // [esp+10h] [ebp-4h]
  _DWORD *v22; // [esp+1Ch] [ebp+8h]
  _DWORD *v23; // [esp+20h] [ebp+Ch]

  v5 = (_DWORD *)this[1];
  if ( v5[1] == 6 && v5[6] != 1 )
  {
    v6 = v5[7];
    LOBYTE(v19) = *(_BYTE *)(--v5[6] + v6);
    sub_10017090(this, v19);
  }
  v7 = (_DWORD *)this[1];
  v8 = v7[1];
  if ( v8 == 9 || v8 == 14 )
    v7 = (_DWORD *)v7[5];
  if ( a2 || a3 != 1 )
  {
    v18 = operator new(0x18u);
    v18[1] = 19;
    v18[2] = 0;
    v18[3] = 0;
    v18[4] = 0;
    *v18 = &std::_Node_end_rep::`vftable';
    v18[5] = 0;
    v21 = operator new(0x28u);
    v16 = *(_DWORD *)(*this + 24);
    *(_DWORD *)(*this + 24) = v16 + 1;
    v21[2] = 2 * a4;
    v21[5] = a2;
    v21[1] = 18;
    v21[3] = 0;
    v21[4] = 0;
    *v21 = &std::_Node_rep::`vftable';
    v21[6] = a3;
    v21[7] = v18;
    v21[8] = v16;
    v21[9] = -1;
    v18[5] = v21;
    v18[4] = this[1];
    v17 = *(_DWORD *)(this[1] + 12);
    if ( v17 )
    {
      v18[3] = v17;
      *(_DWORD *)(*(_DWORD *)(this[1] + 12) + 16) = v18;
    }
    *(_DWORD *)(this[1] + 12) = v18;
    this[1] = v18;
    *(_DWORD *)(v7[4] + 12) = v21;
    result = v7[4];
    v21[4] = result;
    v7[4] = v21;
    v21[3] = v7;
  }
  else
  {
    v23 = operator new(0x14u);
    v23[1] = 17;
    v23[2] = 0;
    v23[3] = 0;
    v23[4] = 0;
    *v23 = &std::_Node_endif::`vftable';
    v20 = operator new(0x1Cu);
    v20[1] = 16;
    v20[2] = 0;
    v20[3] = 0;
    v20[4] = 0;
    *v20 = &std::_Node_if::`vftable';
    v20[5] = v23;
    v20[6] = 0;
    v22 = operator new(0x1Cu);
    v22[1] = 16;
    v22[2] = 0;
    v22[3] = 0;
    v22[4] = 0;
    *v22 = &std::_Node_if::`vftable';
    v22[5] = v23;
    v22[6] = 0;
    v9 = operator new(0x14u);
    *v9 = &std::_Node_base::`vftable';
    v9[1] = 8;
    v9[2] = 0;
    v9[3] = 0;
    v9[4] = 0;
    v10 = operator new(0x18u);
    v10[5] = v9;
    v10[1] = 9;
    v10[2] = 0;
    v10[3] = 0;
    v10[4] = 0;
    *v10 = &std::_Node_end_group::`vftable';
    v22[3] = v9;
    v9[4] = v22;
    v9[3] = v10;
    v10[4] = v9;
    v10[3] = v23;
    v20[6] = v22;
    v23[4] = this[1];
    v11 = *(_DWORD *)(this[1] + 12);
    if ( v11 )
    {
      v23[3] = v11;
      *(_DWORD *)(*(_DWORD *)(this[1] + 12) + 16) = v23;
    }
    *(_DWORD *)(this[1] + 12) = v23;
    this[1] = v23;
    *(_DWORD *)(v7[4] + 12) = v20;
    result = v7[4];
    v20[4] = result;
    v7[4] = v20;
    v20[3] = v7;
    if ( !a4 )
    {
      v13 = v22[3];
      v14 = v7[4];
      v7[4] = *(_DWORD *)(v13 + 16);
      *(_DWORD *)(v13 + 16) = v14;
      v15 = v20[3];
      result = v22[3];
      v20[3] = result;
      v22[3] = v15;
    }
  }
  return result;
}
// 10018E4E: variable 'v19' is possibly undefined
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';
// 1004ACC0: using guessed type void *std::_Node_end_rep::`vftable';
// 1004C098: using guessed type void *std::_Node_rep::`vftable';
// 1004C0A0: using guessed type void *std::_Node_endif::`vftable';
// 1004C0DC: using guessed type void *std::_Node_if::`vftable';
// 1004C204: using guessed type void *std::_Node_end_group::`vftable';

//----- (100190E0) --------------------------------------------------------
char __thiscall sub_100190E0(void **this, _DWORD *a2, char a3)
{
  int v4; // edi
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  char v10; // bl
  int v11; // edx
  void **v12; // edi
  char *v13; // ecx
  void **v14; // eax
  void *v16; // [esp+Ch] [ebp-54h] BYREF
  void *v17; // [esp+10h] [ebp-50h] BYREF
  int v18; // [esp+14h] [ebp-4Ch]
  void *v19; // [esp+1Ch] [ebp-44h]
  void *Src[3]; // [esp+20h] [ebp-40h] BYREF
  void *v21; // [esp+2Ch] [ebp-34h] BYREF
  void *v22[3]; // [esp+30h] [ebp-30h] BYREF
  void *v23; // [esp+3Ch] [ebp-24h]
  void *v24[3]; // [esp+40h] [ebp-20h] BYREF
  void *v25; // [esp+4Ch] [ebp-14h]
  void *v26; // [esp+50h] [ebp-10h]
  int v27; // [esp+5Ch] [ebp-4h]
  void *v28; // [esp+68h] [ebp+8h]
  char v29; // [esp+6Bh] [ebp+Bh]
  void **v30; // [esp+6Ch] [ebp+Ch]

  v4 = 0;
  sub_100181C0(&v16, this);
  v27 = 0;
  if ( (int)a2[5] <= 0 )
  {
LABEL_6:
    sub_100181C0(&v21, this);
    LOBYTE(v27) = 1;
    v29 = 0;
    v6 = a2[7];
    v26 = *this;
    if ( (unsigned __int8)sub_10015FD0(*(_DWORD *)(v6 + 12)) )
    {
      if ( !a3 )
      {
LABEL_34:
        v10 = 1;
LABEL_43:
        sub_10014220(&v21);
        goto LABEL_44;
      }
      v21 = *this;
      if ( v22 != this + 1 )
      {
        sub_10018060(v22, (char *)this[1], ((_BYTE *)this[2] - (_BYTE *)this[1]) >> 2);
        v23 = this[4];
      }
      if ( v24 != this + 5 )
        sub_10017F00(v24, (char *)this[5], ((_BYTE *)this[6] - (_BYTE *)this[5]) >> 3);
      v29 = 1;
    }
    v7 = (int)v26;
    while ( 1 )
    {
      v8 = a2[6];
      if ( v8 != -1 )
      {
        v9 = v4++;
        if ( v9 >= v8 )
          break;
        v7 = (int)v26;
      }
      *this = (void *)v7;
      if ( this + 1 != &v17 )
      {
        sub_10018060(this + 1, (char *)v17, (v18 - (int)v17) >> 2);
        this[4] = v19;
      }
      if ( !(unsigned __int8)sub_10015FD0(a2[3]) )
        break;
      v25 = *this;
      if ( (unsigned __int8)sub_10015FD0(*(_DWORD *)(a2[7] + 12)) )
      {
        if ( !a3 )
          goto LABEL_34;
        v21 = *this;
        if ( v22 != this + 1 )
        {
          sub_10018060(v22, (char *)this[1], ((_BYTE *)this[2] - (_BYTE *)this[1]) >> 2);
          v23 = this[4];
        }
        if ( v24 != this + 5 )
          sub_10017F00(v24, (char *)this[5], ((_BYTE *)this[6] - (_BYTE *)this[5]) >> 3);
        v29 = 1;
      }
      v7 = (int)v25;
      if ( v26 == v25 )
        break;
      v26 = v25;
    }
    if ( v29 )
    {
      v11 = (int)v21;
      v12 = v24;
      v13 = (char *)v22[0];
      v14 = v22;
    }
    else
    {
      v11 = (int)v16;
      v12 = Src;
      v13 = (char *)v17;
      v14 = &v17;
    }
    v30 = v14;
    *this = (void *)v11;
    if ( this + 1 != v14 )
    {
      sub_10018060(this + 1, v13, ((_BYTE *)v14[1] - v13) >> 2);
      this[4] = v30[3];
    }
    if ( this + 5 != v12 )
      sub_10017F00(this + 5, (char *)*v12, ((_BYTE *)v12[1] - (_BYTE *)*v12) >> 3);
    v10 = v29;
    goto LABEL_43;
  }
  while ( 1 )
  {
    v28 = *this;
    if ( !(unsigned __int8)sub_10015FD0(a2[3]) )
      break;
    if ( v28 == *this )
      v4 = a2[5] - 1;
    if ( ++v4 >= a2[5] )
      goto LABEL_6;
  }
  *this = v16;
  if ( this + 1 != &v17 )
  {
    sub_10018060(this + 1, (char *)v17, (v18 - (int)v17) >> 2);
    this[4] = v19;
  }
  if ( this + 5 != Src )
    sub_10017F00(this + 5, (char *)Src[0], (Src[1] - Src[0]) >> 3);
  v10 = 0;
LABEL_44:
  sub_10014220(&v16);
  return v10;
}
// 10015FD0: using guessed type _DWORD __stdcall sub_10015FD0(_DWORD);

//----- (10019360) --------------------------------------------------------
void **__thiscall sub_10019360(void **Block, char a2)
{
  free(Block[7]);
  *Block = &std::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004A9C8: using guessed type void *std::_Node_base::`vftable';

//----- (100193C0) --------------------------------------------------------
int __thiscall sub_100193C0(int this, int a2, int a3, int a4)
{
  int v4; // edx
  int v6; // ebx
  char v7; // cl
  int v8; // ecx
  int v9; // edi
  _BYTE *v10; // eax
  _BYTE *v11; // edx
  _BYTE *v12; // ecx
  int v13; // edx

  v4 = a3;
  *(_DWORD *)(this + 68) = 0;
  if ( a3 )
  {
    v6 = a2;
    while ( 1 )
    {
      v7 = *(_BYTE *)(this + 72);
      if ( v6 == 8 )
      {
        if ( (unsigned __int8)(v7 - 48) > 7u )
          return v4;
      }
      else if ( v7 < 48 || v7 > 57 )
      {
        if ( v6 != 16 )
          return v4;
        if ( (unsigned __int8)(v7 - 97) > 5u )
        {
          if ( (unsigned __int8)(v7 - 65) > 5u )
            return v4;
          v8 = v7 - 55;
        }
        else
        {
          v8 = v7 - 87;
        }
        goto LABEL_13;
      }
      v8 = v7 - 48;
LABEL_13:
      if ( v8 != -1 )
      {
        v9 = *(_DWORD *)(this + 68);
        if ( v9 > (0x7FFFFFFF - v8) / v6 )
          sub_100143C0(a4);
        --a3;
        v10 = *(_BYTE **)this;
        v11 = *(_BYTE **)(this + 8);
        *(_DWORD *)(this + 68) = v8 + v6 * v9;
        if ( v10 != v11 )
        {
          if ( *v10 == 92 )
          {
            v12 = v10 + 1;
            if ( v10 + 1 != v11 )
            {
              if ( (v13 = *(_DWORD *)(this + 80), (v13 & 8) == 0) && (*v12 == 40 || *v12 == 41)
                || (v13 & 0x10) == 0 && (*v12 == 123 || *v12 == 125) )
              {
                ++v10;
              }
            }
          }
          v6 = a2;
          *(_DWORD *)this = v10 + 1;
        }
        sub_100143D0((_BYTE *)this);
        v4 = a3;
        if ( a3 )
          continue;
      }
      return v4;
    }
  }
  return v4;
}

//----- (100194C0) --------------------------------------------------------
int __thiscall sub_100194C0(int this)
{
  int v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  _BYTE *v5; // ecx
  int v6; // edx
  int v7; // ecx
  _BYTE *v8; // eax
  _BYTE *v9; // edi
  _BYTE *v10; // edx
  char v12; // al
  int v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // edx
  _BYTE *v16; // ecx
  int v17; // ebx
  bool v18; // zf
  _BYTE *v19; // eax
  _BYTE *v20; // edx
  _BYTE *v21; // ecx
  int v22; // edx
  int v23; // edi
  _BYTE *v24; // eax
  _BYTE *v25; // edx
  _BYTE *v26; // ecx
  int v27; // edx
  _BYTE *v28; // edx
  int v29; // edx

  v2 = *(_DWORD *)(this + 76);
  if ( v2 != 92 )
  {
    if ( v2 != 91 )
    {
      if ( v2 == 93 || v2 == -1 )
        return 0;
      v28 = *(_BYTE **)(this + 8);
      *(_DWORD *)(this + 68) = *(char *)(this + 72);
      v14 = *(_BYTE **)this;
      if ( *(_BYTE **)this != v28 )
      {
        if ( *v14 != 92 )
          goto LABEL_95;
        v16 = v14 + 1;
        if ( v14 + 1 == v28 )
          goto LABEL_95;
        v29 = *(_DWORD *)(this + 80);
        if ( (v29 & 8) == 0 )
        {
          if ( *v16 == 40 || *v16 == 41 )
            goto LABEL_94;
          v14 = *(_BYTE **)this;
        }
        v18 = (v29 & 0x10) == 0;
        goto LABEL_91;
      }
LABEL_96:
      sub_100143D0((_BYTE *)this);
      return 1;
    }
    v19 = *(_BYTE **)this;
    v20 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this != v20 )
    {
      if ( *v19 == 92 )
      {
        v21 = v19 + 1;
        if ( v19 + 1 != v20 )
        {
          if ( (v22 = *(_DWORD *)(this + 80), (v22 & 8) == 0) && (*v21 == 40 || *v21 == 41)
            || (v22 & 0x10) == 0 && (*v21 == 123 || *v21 == 125) )
          {
            ++v19;
          }
        }
      }
      *(_DWORD *)this = v19 + 1;
    }
    sub_100143D0((_BYTE *)this);
    v23 = *(_DWORD *)(this + 76);
    if ( v23 != 58 && v23 != 61 && v23 != 46 )
    {
      *(_DWORD *)(this + 68) = 91;
      return 1;
    }
    v24 = *(_BYTE **)this;
    v25 = *(_BYTE **)(this + 8);
    if ( *(_BYTE **)this == v25 )
    {
LABEL_80:
      sub_100143D0((_BYTE *)this);
      sub_10019C50(this, v23);
      return 2;
    }
    if ( *v24 != 92 || (v26 = v24 + 1, v24 + 1 == v25) )
    {
LABEL_79:
      *(_DWORD *)this = v24 + 1;
      goto LABEL_80;
    }
    v27 = *(_DWORD *)(this + 80);
    if ( (v27 & 8) == 0 )
    {
      if ( *v26 == 40 || *v26 == 41 )
      {
LABEL_78:
        v24 = v26;
        goto LABEL_79;
      }
      v24 = *(_BYTE **)this;
    }
    if ( (v27 & 0x10) != 0 || *v26 != 123 && *v26 != 125 )
      goto LABEL_79;
    goto LABEL_78;
  }
  v3 = *(_BYTE **)this;
  v4 = *(_BYTE **)(this + 8);
  if ( *(_BYTE **)this != v4 )
  {
    if ( *v3 == 92 )
    {
      v5 = v3 + 1;
      if ( v3 + 1 != v4 )
      {
        if ( (v6 = *(_DWORD *)(this + 80), (v6 & 8) == 0) && (*v5 == 40 || *v5 == 41)
          || (v6 & 0x10) == 0 && (*v5 == 123 || *v5 == 125) )
        {
          ++v3;
        }
      }
    }
    *(_DWORD *)this = v3 + 1;
  }
  sub_100143D0((_BYTE *)this);
  v7 = *(_DWORD *)(this + 80);
  if ( (v7 & 0x200000) == 0 )
  {
    if ( (v7 & 0x10000) != 0 && sub_100197B0((_DWORD *)this, *(_BYTE *)(this + 72)) )
    {
LABEL_44:
      v14 = *(_BYTE **)this;
      v15 = *(_BYTE **)(this + 8);
      if ( *(_BYTE **)this != v15 )
      {
        if ( *v14 != 92 )
          goto LABEL_95;
        v16 = v14 + 1;
        if ( v14 + 1 == v15 )
          goto LABEL_95;
        v17 = *(_DWORD *)(this + 80);
        if ( (v17 & 8) != 0 || *v16 != 40 && *v16 != 41 )
        {
          v18 = (v17 & 0x10) == 0;
LABEL_91:
          if ( !v18 || *v16 != 123 && *v16 != 125 )
            goto LABEL_95;
        }
LABEL_94:
        v14 = v16;
LABEL_95:
        *(_DWORD *)this = v14 + 1;
        goto LABEL_96;
      }
      goto LABEL_96;
    }
    if ( (*(_DWORD *)(this + 80) & 0x8000) != 0 )
    {
      v12 = *(_BYTE *)(this + 72);
      if ( v12 == 97 )
      {
        v13 = 7;
LABEL_43:
        *(_DWORD *)(this + 68) = v13;
        goto LABEL_44;
      }
      if ( v12 == 98 )
      {
        v13 = 8;
        goto LABEL_43;
      }
    }
    *(_DWORD *)(this + 68) = 92;
    return 1;
  }
  if ( (v7 & 0x4000) != 0 && *(_BYTE *)(this + 72) == 92 )
  {
    v8 = *(_BYTE **)this;
    v9 = *(_BYTE **)(this + 8);
    *(_DWORD *)(this + 68) = 92;
    if ( v8 != v9 )
    {
      if ( *v8 == 92 )
      {
        v10 = v8 + 1;
        if ( v8 + 1 != v9
          && ((v7 & 8) == 0 && (*v10 == 40 || *v10 == 41) || (v7 & 0x10) == 0 && (*v10 == 123 || *v10 == 125)) )
        {
          ++v8;
        }
      }
      *(_DWORD *)this = v8 + 1;
    }
    sub_100143D0((_BYTE *)this);
    return 1;
  }
  if ( (v7 & 0x20000) != 0 && sub_10018430(this, 0) )
    return 2;
  if ( sub_100193C0(this, 10, 0x7FFFFFFF, 2) != 0x7FFFFFFF )
  {
    if ( *(_DWORD *)(this + 68) )
      sub_100143C0(2);
    return 1;
  }
  return sub_10018820(this) != 0;
}

//----- (100197B0) --------------------------------------------------------
char __thiscall sub_100197B0(_DWORD *this, char a2)
{
  switch ( a2 )
  {
    case 'f':
      this[17] = 12;
      return 1;
    case 'n':
      this[17] = 10;
      return 1;
    case 'r':
      this[17] = 13;
      return 1;
    case 't':
      this[17] = 9;
      return 1;
    case 'v':
      this[17] = 11;
      return 1;
    default:
      return 0;
  }
}

//----- (10019820) --------------------------------------------------------
unsigned int __thiscall sub_10019820(_DWORD *this, int a2, int a3)
{
  unsigned int v4; // ebx
  unsigned int result; // eax
  int v6; // edi
  _DWORD *v7; // eax
  _BYTE *v8; // edx
  char v9; // al
  int v10; // ecx
  unsigned int *v11; // esi
  unsigned int v12; // ecx
  void **v13; // eax
  void *v14; // ecx
  int v15; // esi
  unsigned int v16; // ebx
  size_t v17; // ebx
  void *v18; // eax
  unsigned int v19; // [esp+14h] [ebp+8h]
  unsigned int v20; // [esp+18h] [ebp+Ch]

  if ( (this[2] & 0x100) != 0 )
  {
    v4 = (*(char (__thiscall **)(_DWORD, int))(**(_DWORD **)(this[3] + 4) + 16))(*(_DWORD *)(this[3] + 4), a2);
    result = (*(char (__thiscall **)(_DWORD, int))(**(_DWORD **)(this[3] + 4) + 16))(*(_DWORD *)(this[3] + 4), a3);
  }
  else
  {
    v4 = (unsigned __int8)a2;
    result = (unsigned __int8)a3;
  }
  v6 = this[1];
  v19 = result;
  if ( result >= v4 )
  {
    do
    {
      if ( result >= this[4] )
        break;
      v7 = *(_DWORD **)(v6 + 24);
      if ( !v7 )
      {
        v7 = operator new(0x20u);
        *v7 = 0;
        v7[1] = 0;
        v7[2] = 0;
        v7[3] = 0;
        v7[4] = 0;
        v7[5] = 0;
        v7[6] = 0;
        v7[7] = 0;
        *(_DWORD *)(v6 + 24) = v7;
      }
      v8 = (char *)v7 + (v4 >> 3);
      v9 = v4++ & 7;
      v10 = (unsigned __int8)*v8 | (1 << v9);
      result = v19;
      *v8 = v10;
    }
    while ( v4 <= v19 );
    if ( result >= v4 )
    {
      if ( result - v4 >= this[5] )
      {
        v11 = *(unsigned int **)(v6 + 32);
        if ( !v11 )
        {
          v11 = (unsigned int *)operator new(0xCu);
          *v11 = 0;
          v11[1] = 0;
          v11[2] = 0;
          *(_DWORD *)(v6 + 32) = v11;
        }
        v12 = v11[1];
        v13 = (void **)(v11 + 2);
        if ( *v11 <= v12 )
        {
          v20 = v12 + 16;
          v14 = realloc(*v13, v12 + 16);
          if ( !v14 )
            sub_1001BFF1();
          v13 = (void **)(v11 + 2);
          v11[2] = (unsigned int)v14;
          *v11 = v20;
        }
        *((_BYTE *)*v13 + v11[1]++) = v4;
        v15 = *(_DWORD *)(v6 + 32);
        v16 = *(_DWORD *)(v15 + 4);
        if ( *(_DWORD *)v15 <= v16 )
        {
          v17 = v16 + 16;
          v18 = realloc(*(void **)(v15 + 8), v17);
          if ( !v18 )
            sub_1001BFF1();
          *(_DWORD *)(v15 + 8) = v18;
          *(_DWORD *)v15 = v17;
        }
        result = *(_DWORD *)(v15 + 4);
        *(_BYTE *)(*(_DWORD *)(v15 + 8) + result) = v19;
        ++*(_DWORD *)(v15 + 4);
      }
      else
      {
        do
          result = sub_10019A50(this, v4++);
        while ( v4 <= v19 );
      }
    }
  }
  return result;
}
// 1001BFF1: using guessed type void __noreturn sub_1001BFF1(void);

//----- (10019990) --------------------------------------------------------
_DWORD *__thiscall sub_10019990(_DWORD *this, unsigned __int16 a2, char a3)
{
  _DWORD *result; // eax
  unsigned int v4; // ebx
  int v5; // esi
  int v6; // eax
  char v7; // al
  _DWORD *v8; // eax

  result = this;
  v4 = 0;
  v5 = this[1];
  do
  {
    v6 = result[3];
    if ( a2 == 0xFFFF )
      v7 = (_BYTE)v4 == 95 || (*(_WORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 2 * (unsigned __int8)v4) & 0x107) != 0;
    else
      v7 = (a2 & *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 2 * (unsigned __int8)v4)) != 0;
    if ( v7 != a3 )
    {
      v8 = *(_DWORD **)(v5 + 24);
      if ( !v8 )
      {
        v8 = operator new(0x20u);
        *v8 = 0;
        v8[1] = 0;
        v8[2] = 0;
        v8[3] = 0;
        v8[4] = 0;
        v8[5] = 0;
        v8[6] = 0;
        v8[7] = 0;
        *(_DWORD *)(v5 + 24) = v8;
      }
      *((_BYTE *)v8 + (v4 >> 3)) |= 1 << (v4 & 7);
    }
    result = this;
    ++v4;
  }
  while ( v4 < 0x100 );
  return result;
}

//----- (10019A50) --------------------------------------------------------
int __thiscall sub_10019A50(_DWORD *this, int a2)
{
  char v3; // bl
  int v4; // edi
  void *v5; // esi
  unsigned int v6; // eax
  void *v7; // eax
  int result; // eax
  unsigned int v9; // [esp+14h] [ebp+8h]

  if ( (this[2] & 0x100) != 0 )
    v3 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this[3] + 4) + 16))(*(_DWORD *)(this[3] + 4), a2);
  else
    v3 = a2;
  v4 = this[1];
  v5 = *(void **)(v4 + 28);
  if ( !v5 )
  {
    v5 = operator new(0xCu);
    *(_DWORD *)v5 = 0;
    *((_DWORD *)v5 + 1) = 0;
    *((_DWORD *)v5 + 2) = 0;
    *(_DWORD *)(v4 + 28) = v5;
  }
  v6 = *((_DWORD *)v5 + 1);
  if ( *(_DWORD *)v5 <= v6 )
  {
    v9 = v6 + 16;
    v7 = realloc(*((void **)v5 + 2), v6 + 16);
    if ( !v7 )
      sub_1001BFF1();
    *((_DWORD *)v5 + 2) = v7;
    *(_DWORD *)v5 = v9;
  }
  result = *((_DWORD *)v5 + 1);
  *(_BYTE *)(*((_DWORD *)v5 + 2) + result) = v3;
  ++*((_DWORD *)v5 + 1);
  return result;
}
// 1001BFF1: using guessed type void __noreturn sub_1001BFF1(void);

//----- (10019AF0) --------------------------------------------------------
int __thiscall sub_10019AF0(_DWORD **this, char *a2, char *a3, char a4)
{
  int v4; // edx
  char *v5; // ecx
  char *v6; // ebx
  char *v7; // esi
  int v8; // eax
  char *v9; // edi
  char *v10; // esi
  char v11; // bl
  unsigned int v12; // edx
  int result; // eax
  char v14; // [esp+4h] [ebp-10h]
  char v15; // [esp+8h] [ebp-Ch]
  int v17; // [esp+10h] [ebp-4h]

  v4 = 0;
  v17 = 0;
  if ( "alnum" )
  {
    v5 = a3;
    v6 = a2;
    v7 = (char *)(a3 - a2);
    v8 = 0;
    do
    {
      if ( v7 == (char *)dword_1004AB90[v8] )
      {
        v9 = (&off_1004AB88)[v8];
        v10 = v6;
        if ( v6 == v5 )
          break;
        while ( 1 )
        {
          v15 = *v9;
          v14 = *v10;
          v11 = (*(int (__thiscall **)(_DWORD *, char))(*this[1] + 16))(this[1], v15);
          if ( (*(unsigned __int8 (__thiscall **)(_DWORD *, char))(*this[1] + 16))(this[1], v14) != v11 )
            break;
          ++v10;
          ++v9;
          if ( v10 == a3 )
          {
            v4 = v17;
            goto LABEL_8;
          }
        }
        v5 = a3;
        v4 = v17;
        v6 = a2;
        v7 = (char *)(a3 - a2);
      }
      v17 = ++v4;
      v8 = 4 * v4;
    }
    while ( (&off_1004AB88)[4 * v4] );
  }
LABEL_8:
  v12 = 16 * v4;
  result = 0;
  if ( (&off_1004AB88)[v12 / 4] )
    result = (unsigned __int16)word_1004AB94[v12 / 2];
  if ( a4 )
  {
    if ( (result & 3) != 0 )
      return result | 3;
  }
  return result;
}
// 1004AB88: using guessed type char *off_1004AB88;
// 1004AB90: using guessed type int dword_1004AB90[];
// 1004AB94: using guessed type __int16 word_1004AB94[];

//----- (10019BC0) --------------------------------------------------------
unsigned int __thiscall sub_10019BC0(unsigned int *this, size_t Size)
{
  void *v3; // eax
  void *v4; // ecx
  unsigned int v5; // eax
  unsigned int result; // eax
  void *v7; // eax

  if ( Size > 0x7FFFFFFF )
    sub_10008240();
  if ( Size < 0x1000 )
  {
    if ( Size )
    {
      v7 = operator new(Size);
      *this = (unsigned int)v7;
      this[1] = (unsigned int)v7;
      result = (unsigned int)v7 + Size;
      this[2] = result;
    }
    else
    {
      *this = 0;
      this[1] = 0;
      result = 0;
      this[2] = 0;
    }
  }
  else
  {
    if ( Size + 35 <= Size )
      sub_10001240();
    v3 = operator new(Size + 35);
    v4 = v3;
    if ( !v3 )
      _invalid_parameter_noinfo_noreturn();
    v5 = ((unsigned int)v3 + 35) & 0xFFFFFFE0;
    *(_DWORD *)(v5 - 4) = v4;
    *this = v5;
    this[1] = v5;
    result = Size + v5;
    this[2] = result;
  }
  return result;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);
// 10008240: using guessed type void __noreturn sub_10008240(void);

//----- (10019C50) --------------------------------------------------------
int __thiscall sub_10019C50(int this, int a2)
{
  int v2; // edx
  int v4; // edi
  int v5; // ecx
  _DWORD *v6; // ebx
  char *v7; // eax
  int v8; // eax
  char *v9; // eax
  char *v10; // edx
  _BYTE *v11; // ecx
  int v12; // edx
  unsigned __int16 v13; // ax
  char *v14; // eax
  char *v15; // edx
  _BYTE *v16; // ecx
  int v17; // edx
  char *v18; // eax
  char *v19; // edx
  _BYTE *v20; // ecx
  int v21; // edx
  _DWORD *v23; // [esp+Ch] [ebp-8h]
  char *v24; // [esp+10h] [ebp-4h]

  v2 = a2;
  if ( a2 == 58 )
  {
    v4 = 1;
  }
  else if ( a2 == 61 )
  {
    v4 = 0;
  }
  else
  {
    v4 = a2 != 46 ? 0xE : 0;
  }
  v5 = *(_DWORD *)(this + 76);
  v6 = 0;
  v7 = *(char **)this;
  v24 = *(char **)this;
  v23 = 0;
  if ( v5 != 58 )
  {
    v8 = v5;
    do
    {
      v5 = v8;
      if ( v8 == 61 || v8 == 46 || v8 == -1 )
        break;
      v9 = *(char **)this;
      v10 = *(char **)(this + 8);
      if ( *(char **)this != v10 )
      {
        if ( *v9 == 92 )
        {
          v11 = v9 + 1;
          if ( v9 + 1 != v10 )
          {
            if ( (v12 = *(_DWORD *)(this + 80), (v12 & 8) == 0) && (*v11 == 40 || *v11 == 41)
              || (v12 & 0x10) == 0 && (*v11 == 123 || *v11 == 125) )
            {
              ++v9;
            }
          }
        }
        v6 = v23;
        *(_DWORD *)this = v9 + 1;
      }
      sub_100143D0((_BYTE *)this);
      v5 = *(_DWORD *)(this + 76);
      v6 = (_DWORD *)((char *)v6 + 1);
      v23 = v6;
      v8 = v5;
    }
    while ( v5 != 58 );
    v2 = a2;
    v7 = v24;
  }
  if ( v5 != v2 )
    sub_100143C0(v4);
  switch ( v2 )
  {
    case ':':
      v13 = sub_10019AF0(*(_DWORD ***)(this + 60), v24, *(char **)this, BYTE1(*(_DWORD *)(this + 64)) & 1);
      if ( !v13 )
        sub_100143C0(1);
      sub_10019990((_DWORD *)(this + 36), v13, 0);
      break;
    case '=':
      if ( v24 == *(char **)this )
        sub_100143C0(0);
      sub_10019E40(this + 36, v24, *(_DWORD *)this, (size_t)v24);
      break;
    case '.':
      if ( v7 == *(char **)this )
        sub_100143C0(0);
      sub_1001A000(v24, *(char **)this, v6, (_DWORD **)(*(_DWORD *)(this + 40) + 20));
      break;
  }
  v14 = *(char **)this;
  v15 = *(char **)(this + 8);
  if ( *(char **)this != v15 )
  {
    if ( *v14 == 92 )
    {
      v16 = v14 + 1;
      if ( v14 + 1 != v15 )
      {
        if ( (v17 = *(_DWORD *)(this + 80), (v17 & 8) == 0) && (*v16 == 40 || *v16 == 41)
          || (v17 & 0x10) == 0 && (*v16 == 123 || *v16 == 125) )
        {
          ++v14;
        }
      }
    }
    *(_DWORD *)this = v14 + 1;
  }
  sub_100143D0((_BYTE *)this);
  if ( *(_DWORD *)(this + 76) != 93 )
    sub_100143C0(v4);
  v18 = *(char **)this;
  v19 = *(char **)(this + 8);
  if ( *(char **)this != v19 )
  {
    if ( *v18 == 92 )
    {
      v20 = v18 + 1;
      if ( v18 + 1 != v19 )
      {
        if ( (v21 = *(_DWORD *)(this + 80), (v21 & 8) == 0) && (*v20 == 40 || *v20 == 41)
          || (v21 & 0x10) == 0 && (*v20 == 123 || *v20 == 125) )
        {
          ++v18;
        }
      }
    }
    *(_DWORD *)this = v18 + 1;
  }
  return sub_100143D0((_BYTE *)this);
}

//----- (10019E40) --------------------------------------------------------
void __thiscall sub_10019E40(int this, void *Src, size_t Size, size_t a4)
{
  int v4; // esi
  int v5; // edi
  unsigned int v6; // ebx
  _DWORD *v7; // ecx
  int v8; // eax
  void **v9; // edx
  void *v10; // esi
  unsigned int v11; // esi
  bool v12; // cf
  unsigned __int8 v13; // cl
  unsigned __int8 v14; // cl
  unsigned __int8 v15; // al
  int v16; // eax
  char v17; // bl
  _BYTE *v18; // edx
  _DWORD *v19; // ecx
  unsigned int v20; // ebx
  void *v21; // edx
  void *Block; // [esp+Ch] [ebp-48h] BYREF
  unsigned int v23; // [esp+20h] [ebp-34h]
  void *v24[5]; // [esp+24h] [ebp-30h] BYREF
  unsigned int v25; // [esp+38h] [ebp-1Ch]
  _DWORD *v26; // [esp+3Ch] [ebp-18h]
  int v27; // [esp+40h] [ebp-14h]
  int v28; // [esp+50h] [ebp-4h]
  unsigned int Srca; // [esp+5Ch] [ebp+8h]

  v4 = this;
  v27 = this;
  v5 = *(_DWORD *)(this + 4);
  sub_1001A0B0(*(_DWORD **)(this + 12), (int)v24, Src, Size);
  LOBYTE(v6) = 0;
  v28 = 0;
  Srca = 0;
  while ( 1 )
  {
    v7 = *(_DWORD **)(v4 + 12);
    HIBYTE(Size) = v6;
    v8 = sub_1001A0B0(v7, (int)&Block, (char *)&Size + 3, (size_t)&a4);
    v9 = v24;
    if ( v25 >= 0x10 )
      v9 = (void **)v24[0];
    v10 = *(void **)(v8 + 16);
    if ( *(_DWORD *)(v8 + 20) >= 0x10u )
      v8 = *(_DWORD *)v8;
    if ( v10 != v24[4] )
      goto LABEL_22;
    v12 = (unsigned int)v10 < 4;
    v11 = (unsigned int)v10 - 4;
    if ( v12 )
    {
LABEL_10:
      if ( v11 == -4 )
        goto LABEL_19;
    }
    else
    {
      while ( *(void **)v8 == *v9 )
      {
        v8 += 4;
        ++v9;
        v12 = v11 < 4;
        v11 -= 4;
        if ( v12 )
          goto LABEL_10;
      }
    }
    v12 = *(_BYTE *)v8 < *(_BYTE *)v9;
    if ( *(_BYTE *)v8 != *(_BYTE *)v9
      || v11 != -3
      && ((v13 = *(_BYTE *)(v8 + 1), v12 = v13 < *((_BYTE *)v9 + 1), v13 != *((_BYTE *)v9 + 1))
       || v11 != -2
       && ((v14 = *(_BYTE *)(v8 + 2), v12 = v14 < *((_BYTE *)v9 + 2), v14 != *((_BYTE *)v9 + 2))
        || v11 != -1 && (v15 = *(_BYTE *)(v8 + 3), v12 = v15 < *((_BYTE *)v9 + 3), v15 != *((_BYTE *)v9 + 3)))) )
    {
      v16 = v12 ? -1 : 1;
      goto LABEL_20;
    }
LABEL_19:
    v16 = 0;
LABEL_20:
    if ( !v16 )
    {
      v17 = 1;
      goto LABEL_23;
    }
LABEL_22:
    v17 = 0;
LABEL_23:
    if ( v23 >= 0x10 )
    {
      v18 = Block;
      if ( v23 + 1 >= 0x1000 )
      {
        v18 = (_BYTE *)*((_DWORD *)Block - 1);
        if ( (unsigned int)((_BYTE *)Block - v18 - 4) > 0x1F )
          goto LABEL_39;
      }
      sub_1001D481(v18);
    }
    if ( v17 )
    {
      v19 = *(_DWORD **)(v5 + 24);
      if ( !v19 )
      {
        v19 = operator new(0x20u);
        v26 = v19;
        *v19 = 0;
        v19[1] = 0;
        v19[2] = 0;
        v19[3] = 0;
        v19[4] = 0;
        v19[5] = 0;
        v19[6] = 0;
        v19[7] = 0;
        *(_DWORD *)(v5 + 24) = v19;
      }
      v20 = Srca;
      *((_BYTE *)v19 + (Srca >> 3)) |= 1 << (Srca & 7);
    }
    else
    {
      v20 = Srca;
    }
    v6 = v20 + 1;
    Srca = v6;
    if ( v6 >= 0x100 )
      break;
    v4 = v27;
  }
  if ( v25 >= 0x10 )
  {
    v21 = v24[0];
    if ( v25 + 1 >= 0x1000 )
    {
      v21 = (void *)*((_DWORD *)v24[0] - 1);
      if ( (unsigned int)(v24[0] - v21 - 4) > 0x1F )
LABEL_39:
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v21);
  }
}

//----- (1001A000) --------------------------------------------------------
_DWORD *__stdcall sub_1001A000(char *a1, char *a2, _DWORD *a3, _DWORD **a4)
{
  _DWORD *v4; // ebx
  _DWORD *v5; // edi
  _DWORD *result; // eax
  _DWORD *v7; // esi
  char *i; // edi
  char v9; // al
  unsigned int v10; // eax
  unsigned int v11; // ebx
  void *v12; // eax
  char v13; // [esp+1Fh] [ebp+13h]

  v4 = a4;
  v5 = *a4;
  if ( !*a4 )
    goto LABEL_7;
  result = a3;
  do
  {
    v7 = v5;
    if ( (unsigned int)a3 >= *v5 )
      break;
    v4 = v5 + 4;
    v5 = (_DWORD *)v5[4];
    v7 = v5;
  }
  while ( v5 );
  v5 = v7;
  if ( !v7 || a3 != (_DWORD *)*v7 )
  {
LABEL_7:
    result = operator new(0x14u);
    *result = a3;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    *v4 = result;
    result[4] = v5;
    v7 = (_DWORD *)*v4;
  }
  for ( i = a1; i != a2; ++v7[2] )
  {
    v9 = *i++;
    v13 = v9;
    v10 = v7[2];
    if ( v7[1] <= v10 )
    {
      v11 = v10 + 16;
      v12 = realloc((void *)v7[3], v10 + 16);
      if ( !v12 )
        sub_1001BFF1();
      v7[3] = v12;
      v7[1] = v11;
    }
    result = (_DWORD *)v7[3];
    *((_BYTE *)result + v7[2]) = v13;
  }
  return result;
}
// 1001BFF1: using guessed type void __noreturn sub_1001BFF1(void);

//----- (1001A0B0) --------------------------------------------------------
int __thiscall sub_1001A0B0(_DWORD *this, int a2, void *Src, size_t Size)
{
  int v4; // ebx
  _DWORD *v5; // edi
  char *v6; // edx
  size_t v7; // eax
  unsigned int v8; // ecx
  _DWORD *v9; // eax
  void *v10; // eax
  unsigned int v11; // ecx
  void *v12; // edx
  char *v13; // eax
  void *Block[4]; // [esp+Ch] [ebp-48h] BYREF
  int v16; // [esp+1Ch] [ebp-38h]
  unsigned int v17; // [esp+20h] [ebp-34h]
  void *v18; // [esp+24h] [ebp-30h] BYREF
  int v19; // [esp+28h] [ebp-2Ch]
  int v20; // [esp+2Ch] [ebp-28h]
  int v21; // [esp+30h] [ebp-24h]
  _DWORD *v22; // [esp+34h] [ebp-20h]
  _DWORD *v23; // [esp+38h] [ebp-1Ch]
  int v24; // [esp+3Ch] [ebp-18h]
  _DWORD *v25; // [esp+40h] [ebp-14h]
  int v26; // [esp+50h] [ebp-4h]
  size_t Sizea; // [esp+64h] [ebp+10h]

  v25 = this;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  v26 = 0;
  v21 = 1;
  if ( Src == (void *)Size )
    return a2;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v18 = 0;
  v7 = Size - (_DWORD)Src;
  v19 = 0;
  v20 = 0;
  Sizea = v7;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  if ( v7 )
  {
    sub_10019BC0((unsigned int *)&v18, v7);
    v5 = v18;
    memmove(v18, Src, Sizea);
    v6 = (char *)v5 + Sizea;
    v4 = v20;
    v24 = (int)v5 + Sizea;
    v19 = (int)v5 + Sizea;
    v23 = v5;
    v22 = v5;
  }
  v26 = 1;
  (*(void (__thiscall **)(_DWORD, _DWORD *, char *))(*(_DWORD *)v25[1] + 12))(v25[1], v5, v6);
  (*(void (__thiscall **)(_DWORD, void **, _DWORD *, int))(*(_DWORD *)*v25 + 16))(
    *v25,
    Block,
    v5,
    (int)v22 + v24 - (_DWORD)v23);
  if ( (void **)a2 == Block )
  {
    v11 = v17;
  }
  else
  {
    v8 = *(_DWORD *)(a2 + 20);
    if ( v8 >= 0x10 )
    {
      v9 = *(_DWORD **)a2;
      if ( v8 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v9 - *(v9 - 1) - 4 > 0x1F )
          goto LABEL_21;
        v9 = (_DWORD *)*(v9 - 1);
      }
      sub_1001D481(v9);
    }
    v10 = Block[0];
    v11 = 15;
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 15;
    *(_BYTE *)a2 = 0;
    *(_DWORD *)a2 = v10;
    *(void **)(a2 + 4) = Block[1];
    *(void **)(a2 + 8) = Block[2];
    *(void **)(a2 + 12) = Block[3];
    *(_DWORD *)(a2 + 16) = v16;
    *(_DWORD *)(a2 + 20) = v17;
    v16 = 0;
    v17 = 15;
    LOBYTE(Block[0]) = 0;
  }
  if ( v11 < 0x10 )
    goto LABEL_16;
  v12 = Block[0];
  if ( v11 + 1 >= 0x1000 )
  {
    v12 = (void *)*((_DWORD *)Block[0] - 1);
    if ( (unsigned int)(Block[0] - v12 - 4) > 0x1F )
LABEL_21:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_1001D481(v12);
LABEL_16:
  if ( v5 )
  {
    v13 = (char *)v5;
    if ( (unsigned int)(v4 - (_DWORD)v5) >= 0x1000 )
    {
      v5 = (_DWORD *)*(v5 - 1);
      if ( (unsigned int)(v13 - (char *)v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_1001D481(v5);
  }
  return a2;
}

//----- (1001A290) --------------------------------------------------------
void __thiscall sub_1001A290(_DWORD *this)
{
  *this = &AddressLookupTableObject::`vftable';
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';

//----- (1001A2A0) --------------------------------------------------------
_DWORD *__thiscall sub_1001A2A0(_DWORD *Block, char a2)
{
  *Block = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';

//----- (1001A2D0) --------------------------------------------------------
_DWORD *__thiscall sub_1001A2D0(_DWORD *Block, char a2)
{
  *Block = &Direct3DIndexBuffer8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C244: using guessed type void *Direct3DIndexBuffer8::`vftable';

//----- (1001A300) --------------------------------------------------------
int __stdcall sub_1001A300(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi
  unsigned int v9; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C218;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_14:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_14;
  }
  v5 = a2;
  v4 = &unk_1004C228;
  v9 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v9 < 4;
    v9 -= 4;
    if ( v7 )
      goto LABEL_14;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001A3D0) --------------------------------------------------------
int __cdecl sub_1001A3D0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 8))(*(_DWORD *)(a1 + 12));
}

//----- (1001A3F0) --------------------------------------------------------
int __cdecl sub_1001A3F0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 16))(*(_DWORD *)(a1 + 12));
}

//----- (1001A410) --------------------------------------------------------
int __cdecl sub_1001A410(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 20))(*(_DWORD *)(a1 + 12));
}

//----- (1001A430) --------------------------------------------------------
int __cdecl sub_1001A430(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 24))(*(_DWORD *)(a1 + 12));
}

//----- (1001A450) --------------------------------------------------------
int __cdecl sub_1001A450(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 28))(*(_DWORD *)(a1 + 12));
}

//----- (1001A470) --------------------------------------------------------
int __cdecl sub_1001A470(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 32))(*(_DWORD *)(a1 + 12));
}

//----- (1001A490) --------------------------------------------------------
int __cdecl sub_1001A490(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 36))(*(_DWORD *)(a1 + 12));
}

//----- (1001A4B0) --------------------------------------------------------
int __stdcall sub_1001A4B0(int a1)
{
  return 7;
}

//----- (1001A4C0) --------------------------------------------------------
int __stdcall sub_1001A4C0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  char v7[8]; // [esp+8h] [ebp-14h] BYREF
  int v8; // [esp+10h] [ebp-Ch]

  v5 = a5;
  if ( (a5 & 0x2000) != 0 )
  {
    (*(void (__stdcall **)(_DWORD, char *))(**(_DWORD **)(a1 + 12) + 52))(*(_DWORD *)(a1 + 12), v7);
    if ( (v8 & 0x200) == 0 || (v8 & 8) == 0 )
      v5 = a5 ^ 0x2000;
  }
  return (*(int (__stdcall **)(_DWORD, int, int, int, int))(**(_DWORD **)(a1 + 12) + 44))(
           *(_DWORD *)(a1 + 12),
           a2,
           a3,
           a4,
           v5);
}
// 1001A4C0: using guessed type char var_14[8];

//----- (1001A520) --------------------------------------------------------
int __cdecl sub_1001A520(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 48))(*(_DWORD *)(a1 + 12));
}

//----- (1001A540) --------------------------------------------------------
int __cdecl sub_1001A540(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 52))(*(_DWORD *)(a1 + 12));
}

//----- (1001A560) --------------------------------------------------------
int __thiscall sub_1001A560(_DWORD *this, unsigned __int8 *a2)
{
  char v3[8]; // [esp+0h] [ebp-8h] BYREF

  return *(_DWORD *)sub_1001A580(this, (int)v3, a2) + 12;
}
// 1001A560: using guessed type char var_8[8];

//----- (1001A580) --------------------------------------------------------
int __thiscall sub_1001A580(_DWORD *this, int a2, unsigned __int8 *a3)
{
  int result; // eax
  int **v5; // eax
  int *v6; // ecx
  int **v7; // esi
  unsigned int v8; // ebx
  int v9; // ecx
  bool v10; // sf
  int v11; // ecx
  double v12; // st6
  double v13; // st6
  unsigned int v14; // eax
  int *v15; // edx
  int *v16; // ebx
  int v17; // eax
  int v18; // ecx
  int *v19; // edi
  int v20; // esi
  int *v21[3]; // [esp+18h] [ebp-30h] BYREF
  int **v22; // [esp+24h] [ebp-24h]
  int v23; // [esp+28h] [ebp-20h]
  int **v24; // [esp+2Ch] [ebp-1Ch]
  __int64 v25; // [esp+30h] [ebp-18h] BYREF
  int v26; // [esp+38h] [ebp-10h]
  int v27; // [esp+44h] [ebp-4h]
  float v28; // [esp+54h] [ebp+Ch]
  float v29; // [esp+54h] [ebp+Ch]
  float v30; // [esp+54h] [ebp+Ch]
  float v31; // [esp+54h] [ebp+Ch]
  float v32; // [esp+54h] [ebp+Ch]

  v26 = 16777619 * (a3[3] ^ (16777619 * (a3[2] ^ (16777619 * (a3[1] ^ (16777619 * (*a3 ^ 0x811C9DC5)))))));
  sub_10016580(this, (int **)&v25, a3, v26);
  if ( HIDWORD(v25) )
  {
    result = a2;
    *(_DWORD *)a2 = HIDWORD(v25);
    *(_BYTE *)(a2 + 4) = 0;
    return result;
  }
  if ( this[2] == 0xFFFFFFF )
    sub_1001C00E((int)"unordered_map/set too long");
  v24 = (int **)(this + 1);
  v21[2] = this + 1;
  v27 = 0;
  v22 = 0;
  v5 = (int **)operator new(0x10u);
  v6 = *(int **)a3;
  v7 = v5;
  v23 = (int)v5;
  v22 = v5;
  v5[2] = v6;
  v5[3] = 0;
  v27 = 1;
  v8 = this[7];
  v9 = this[2];
  v10 = v9 + 1 < 0;
  v11 = v9 + 1;
  v12 = (double)v11;
  if ( v10 )
    v12 = v12 + 4294967300.0;
  v28 = v12;
  v13 = v28;
  v29 = (float)v8;
  if ( v13 / v29 <= *(float *)this )
  {
    v15 = (int *)v25;
  }
  else
  {
    HIDWORD(v25) = *this;
    v30 = (float)(unsigned int)v11;
    v31 = v30 / *((float *)&v25 + 1);
    v32 = ceil(v31);
    v25 = (__int64)v32;
    v14 = v25;
    if ( (unsigned int)v25 <= 8 )
      v14 = 8;
    if ( v8 < v14 )
    {
      if ( v8 >= 0x200 || (v8 *= 8, v8 < v14) )
        v8 = v14;
    }
    sub_1001A7C0(this, v8);
    v15 = *sub_10016580(this, v21, v7 + 2, v26);
  }
  v16 = (int *)v15[1];
  ++this[2];
  *v7 = v15;
  v7[1] = v16;
  *v16 = (int)v7;
  v15[1] = (int)v7;
  v17 = v26 & this[6];
  v18 = this[3];
  v19 = *(int **)(v18 + 8 * v17);
  v20 = v23;
  if ( v19 == *v24 )
  {
    *(_DWORD *)(v18 + 8 * v17) = v23;
LABEL_20:
    *(_DWORD *)(v18 + 8 * v17 + 4) = v20;
    goto LABEL_21;
  }
  if ( v19 == v15 )
  {
    *(_DWORD *)(v18 + 8 * v17) = v23;
  }
  else if ( *(int **)(v18 + 8 * v17 + 4) == v16 )
  {
    goto LABEL_20;
  }
LABEL_21:
  result = a2;
  *(_DWORD *)a2 = v20;
  *(_BYTE *)(a2 + 4) = 1;
  return result;
}

//----- (1001A7C0) --------------------------------------------------------
_DWORD *__thiscall sub_1001A7C0(_DWORD *this, unsigned int a2)
{
  unsigned int v4; // ecx
  int v5; // esi
  unsigned int v6; // ecx
  int v7; // edi
  _DWORD *result; // eax
  _DWORD *i; // ecx
  unsigned int v10; // edi
  int v11; // edx
  _DWORD *v12; // ebx
  _DWORD *v13; // edx
  _DWORD *v14; // edx
  int v15; // edi
  _DWORD *v16; // edx
  _DWORD *v17; // ebx
  _DWORD *v18; // edi
  _DWORD *v19; // edx
  _DWORD *v20; // ebx
  _DWORD *v21; // edi
  _DWORD *v22; // ebx
  _DWORD *v23; // esi
  _DWORD *v24; // edi
  _DWORD *v25; // edx
  _DWORD *v26; // [esp+8h] [ebp-Ch]
  _DWORD *v27; // [esp+Ch] [ebp-8h]
  _DWORD *v28; // [esp+Ch] [ebp-8h]
  _DWORD *v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+1Ch] [ebp+8h]

  _BitScanReverse(&v4, 0x1FFFFFFFu);
  v26 = this;
  if ( a2 > 1 << v4 )
    sub_1001C00E((int)"invalid hash bucket count");
  v5 = this[1];
  v30 = v5;
  _BitScanReverse(&v6, (a2 - 1) | 1);
  v7 = 1 << (v6 + 1);
  sub_1001A930(this + 3, 2 * v7, v5);
  this[7] = v7;
  this[6] = v7 - 1;
  result = *(_DWORD **)this[1];
  for ( i = result; i != (_DWORD *)v5; result = i )
  {
    i = (_DWORD *)*i;
    v10 = (16777619
         * (*((unsigned __int8 *)result + 11) ^ (16777619
                                               * (*((unsigned __int8 *)result + 10) ^ (16777619
                                                                                     * (*((unsigned __int8 *)result + 9) ^ (16777619 * (*((unsigned __int8 *)result + 8) ^ 0x811C9DC5)))))))) & this[6];
    v11 = this[3];
    v12 = *(_DWORD **)(v11 + 8 * v10);
    v13 = (_DWORD *)(v11 + 8 * v10);
    v29 = v13;
    if ( v12 == (_DWORD *)v5 )
    {
      *v13 = result;
      v13[1] = result;
    }
    else
    {
      v14 = (_DWORD *)v13[1];
      v15 = result[2];
      if ( v15 == v14[2] )
      {
        v16 = (_DWORD *)*v14;
        v27 = v16;
        if ( v16 != result )
        {
          v17 = (_DWORD *)result[1];
          *v17 = i;
          v18 = (_DWORD *)i[1];
          *v18 = v16;
          v19 = (_DWORD *)v16[1];
          *v19 = result;
          v27[1] = v18;
          v5 = v30;
          i[1] = v17;
          result[1] = v19;
        }
        v29[1] = result;
      }
      else if ( v12 == v14 )
      {
LABEL_12:
        v28 = (_DWORD *)result[1];
        *v28 = i;
        v20 = (_DWORD *)i[1];
        *v20 = v14;
        v21 = (_DWORD *)v14[1];
        *v21 = result;
        v14[1] = v20;
        i[1] = v28;
        result[1] = v21;
        *v29 = result;
      }
      else
      {
        while ( 1 )
        {
          v14 = (_DWORD *)v14[1];
          if ( v15 == v14[2] )
            break;
          if ( v12 == v14 )
            goto LABEL_12;
        }
        v22 = (_DWORD *)result[1];
        v23 = (_DWORD *)*v14;
        *v22 = i;
        v24 = (_DWORD *)i[1];
        *v24 = v23;
        v25 = (_DWORD *)v23[1];
        *v25 = result;
        v23[1] = v24;
        v5 = v30;
        i[1] = v22;
        result[1] = v25;
      }
    }
    this = v26;
  }
  return result;
}

//----- (1001A930) --------------------------------------------------------
void __thiscall sub_1001A930(_DWORD *this, unsigned int a2, int a3)
{
  _DWORD *v4; // esi
  _DWORD *v5; // edx
  size_t v6; // edi
  void *v7; // eax
  _DWORD *v8; // esi
  _DWORD *v9; // eax
  int v10; // ecx
  _DWORD *v11; // ecx

  v4 = (_DWORD *)this[1];
  v5 = (_DWORD *)*this;
  if ( ((int)v4 - *this) >> 2 < a2 )
  {
    if ( a2 <= 0x3FFFFFFF )
    {
      v6 = 4 * a2;
      if ( 4 * a2 < 0x1000 )
      {
        if ( v6 )
          v8 = operator new(v6);
        else
          v8 = 0;
        goto LABEL_10;
      }
      if ( v6 + 35 > v6 )
      {
        v7 = operator new(v6 + 35);
        if ( !v7 )
          goto LABEL_21;
        v8 = (_DWORD *)(((unsigned int)v7 + 35) & 0xFFFFFFE0);
        *(v8 - 1) = v7;
LABEL_10:
        v9 = (_DWORD *)*this;
        v10 = (this[2] - *this) >> 2;
        if ( !v10 )
          goto LABEL_15;
        if ( (unsigned int)(4 * v10) < 0x1000 )
        {
LABEL_14:
          sub_1001D481(v9);
LABEL_15:
          v11 = &v8[v6 / 4];
          *this = v8;
          this[1] = &v8[v6 / 4];
          for ( this[2] = &v8[v6 / 4]; v8 != v11; ++v8 )
            *v8 = a3;
          return;
        }
        if ( (unsigned int)v9 - *(v9 - 1) - 4 <= 0x1F )
        {
          v9 = (_DWORD *)*(v9 - 1);
          goto LABEL_14;
        }
LABEL_21:
        _invalid_parameter_noinfo_noreturn();
      }
    }
    sub_10001240();
  }
  for ( ; v5 != v4; ++v5 )
    *v5 = a3;
}
// 10001240: using guessed type void __noreturn sub_10001240(void);

//----- (1001AA1F) --------------------------------------------------------
_DWORD *__thiscall sub_1001AA1F(_DWORD *this, char a2)
{
  return sub_1001A2D0(this - 1, a2);
}

//----- (1001AA30) --------------------------------------------------------
_DWORD *__thiscall sub_1001AA30(_DWORD *Block, char a2)
{
  *Block = &Direct3DSurface8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (1001AA60) --------------------------------------------------------
int __stdcall sub_1001AA60(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C27C;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_6:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_6;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001AAF0) --------------------------------------------------------
int __cdecl sub_1001AAF0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 44))(*(_DWORD *)(a1 + 12));
}

//----- (1001AB10) --------------------------------------------------------
int __stdcall sub_1001AB10(int a1, unsigned int *a2)
{
  int result; // eax
  unsigned int v3; // ecx
  int v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // eax
  unsigned int v8; // edx
  int v9[4]; // [esp+8h] [ebp-20h] BYREF
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]

  if ( !a2 )
    return -2005530516;
  result = (*(int (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 12) + 48))(*(_DWORD *)(a1 + 12), v9);
  if ( result >= 0 )
  {
    v3 = v9[0];
    v4 = v11;
    v5 = v12;
    a2[1] = v9[1];
    v6 = v9[2];
    *a2 = v3;
    a2[2] = v6;
    a2[3] = v9[3];
    a2[4] = sub_1001BA00(v4, v5, 1, v3);
    v7 = v10;
    a2[5] = v10;
    a2[6] = v4;
    a2[7] = v8;
    a2[5] &= -(v7 != 1);
    return 0;
  }
  return result;
}
// 1001AB84: variable 'v8' is possibly undefined

//----- (1001ABA0) --------------------------------------------------------
int __cdecl sub_1001ABA0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 56))(*(_DWORD *)(a1 + 12));
}

//----- (1001ABB2) --------------------------------------------------------
_DWORD *__thiscall sub_1001ABB2(_DWORD *this, char a2)
{
  return sub_1001AA30(this - 1, a2);
}

//----- (1001ABC0) --------------------------------------------------------
_DWORD *__thiscall sub_1001ABC0(_DWORD *Block, char a2)
{
  *Block = &Direct3DSwapChain8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C2D0: using guessed type void *Direct3DSwapChain8::`vftable';

//----- (1001ABF0) --------------------------------------------------------
int __stdcall sub_1001ABF0(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C2E4;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_6:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_6;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001AC80) --------------------------------------------------------
int __stdcall sub_1001AC80(int a1, int a2, int a3, int a4, int a5)
{
  return (*(int (__stdcall **)(_DWORD, int, int, int, _DWORD, _DWORD))(**(_DWORD **)(a1 + 12) + 12))(
           *(_DWORD *)(a1 + 12),
           a2,
           a3,
           a4,
           0,
           0);
}

//----- (1001ACA0) --------------------------------------------------------
int __userpurge sub_1001ACA0@<eax>(int a1@<esi>, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int result; // eax
  int v6; // esi
  int v7; // ecx
  int v8; // eax
  int v9; // ebx
  int *v10; // esi
  _DWORD *v11; // edi
  int *v12; // edi
  int v13; // ecx
  _DWORD *v14; // ecx
  int *v16; // [esp+0h] [ebp-18h] BYREF
  int v17; // [esp+8h] [ebp-10h] BYREF
  int v18; // [esp+14h] [ebp-4h]

  if ( !a5 )
    return -2005530516;
  v6 = a2;
  *a5 = 0;
  v7 = *(_DWORD *)(v6 + 12);
  v17 = 0;
  result = (*(int (__stdcall **)(int, int, _DWORD *, int *, int))(*(_DWORD *)v7 + 20))(v7, a3, a4, &v17, a1);
  if ( result >= 0 )
  {
    v8 = *(_DWORD *)(v6 + 8);
    v9 = v17;
    a2 = v17;
    v10 = *(int **)(v8 + 4);
    if ( v17 )
    {
      v12 = sub_10016580(
              v10 + 1,
              &v16,
              &a2,
              16777619
            * (HIBYTE(v17) ^ (16777619
                            * (BYTE2(v17) ^ (16777619 * (BYTE1(v17) ^ (16777619 * ((unsigned __int8)v17 ^ 0x811C9DC5))))))))[1];
      if ( !v12 )
        v12 = (int *)v10[2];
      if ( v12 == (int *)v10[2] )
      {
        v11 = operator new(0x10u);
        a4 = v11;
        v18 = 0;
        v13 = *v10;
        v11[1] = &AddressLookupTableObject::`vftable';
        LOBYTE(v18) = 1;
        v11[2] = v13;
        *v11 = &Direct3DSurface8::`vftable';
        v11[1] = &Direct3DSurface8::`vftable';
        v11[3] = v9;
        v14 = (_DWORD *)(*(_DWORD *)(v13 + 4) + 4);
        a2 = v9;
        *(_DWORD *)sub_1001A560(v14, (unsigned __int8 *)&a2) = v11 + 1;
      }
      else
      {
        v11 = v12[3] != 0 ? (_DWORD *)(v12[3] - 4) : 0;
      }
    }
    else
    {
      v11 = 0;
    }
    *a5 = v11;
    return 0;
  }
  return result;
}
// 1001ACA0: could not find valid save-restore pair for esi
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (1001ADE0) --------------------------------------------------------
_DWORD *__thiscall sub_1001ADE0(_DWORD *this, char a2)
{
  return sub_1001ABC0(this - 1, a2);
}

//----- (1001ADF0) --------------------------------------------------------
_DWORD *__thiscall sub_1001ADF0(_DWORD *Block, char a2)
{
  *Block = &Direct3DTexture8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C330: using guessed type void *Direct3DTexture8::`vftable';

//----- (1001AE20) --------------------------------------------------------
int __stdcall sub_1001AE20(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi
  unsigned int v9; // esi
  unsigned int v10; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C37C;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_18:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  v5 = a2;
  v4 = &unk_1004C228;
  v9 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v9 < 4;
    v9 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  v5 = a2;
  v4 = &unk_1004C3DC;
  v10 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001AF20) --------------------------------------------------------
int __stdcall sub_1001AF20(int a1)
{
  return 3;
}

//----- (1001AF30) --------------------------------------------------------
int __cdecl sub_1001AF30(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 52))(*(_DWORD *)(a1 + 12));
}

//----- (1001AF50) --------------------------------------------------------
int __stdcall sub_1001AF50(int a1, int a2, unsigned int *a3)
{
  int result; // eax
  unsigned int v4; // ecx
  int v5; // esi
  int v6; // edx
  int v7; // eax
  int v8; // eax
  unsigned int v9; // edx
  int v10[4]; // [esp+Ch] [ebp-20h] BYREF
  int v11; // [esp+1Ch] [ebp-10h]
  int v12; // [esp+24h] [ebp-8h]
  int v13; // [esp+28h] [ebp-4h]

  if ( !a3 )
    return -2005530516;
  result = (*(int (__stdcall **)(_DWORD, int, int *))(**(_DWORD **)(a1 + 12) + 68))(*(_DWORD *)(a1 + 12), a2, v10);
  if ( result >= 0 )
  {
    v4 = v10[0];
    v5 = v12;
    v6 = v13;
    a3[1] = v10[1];
    v7 = v10[2];
    *a3 = v4;
    a3[2] = v7;
    a3[3] = v10[3];
    a3[4] = sub_1001BA00(v5, v6, 1, v4);
    v8 = v11;
    a3[5] = v11;
    a3[6] = v5;
    a3[7] = v9;
    a3[5] &= -(v8 != 1);
    return 0;
  }
  return result;
}
// 1001AFC7: variable 'v9' is possibly undefined

//----- (1001AFE0) --------------------------------------------------------
int __userpurge sub_1001AFE0@<eax>(int a1@<esi>, int a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax
  int v5; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  int *v9; // esi
  _DWORD *v10; // edi
  int *v11; // edi
  int v12; // ecx
  _DWORD *v13; // ecx
  int *v15; // [esp+0h] [ebp-18h] BYREF
  int v16; // [esp+8h] [ebp-10h] BYREF
  int v17; // [esp+14h] [ebp-4h]

  if ( !a4 )
    return -2005530516;
  v5 = a2;
  *a4 = 0;
  v6 = *(_DWORD *)(v5 + 12);
  v16 = 0;
  result = (*(int (__stdcall **)(int, _DWORD *, int *, int))(*(_DWORD *)v6 + 72))(v6, a3, &v16, a1);
  if ( result >= 0 )
  {
    v7 = *(_DWORD *)(v5 + 8);
    v8 = v16;
    a2 = v16;
    v9 = *(int **)(v7 + 4);
    if ( v16 )
    {
      v11 = sub_10016580(
              v9 + 1,
              &v15,
              &a2,
              16777619
            * (HIBYTE(v16) ^ (16777619
                            * (BYTE2(v16) ^ (16777619 * (BYTE1(v16) ^ (16777619 * ((unsigned __int8)v16 ^ 0x811C9DC5))))))))[1];
      if ( !v11 )
        v11 = (int *)v9[2];
      if ( v11 == (int *)v9[2] )
      {
        v10 = operator new(0x10u);
        a3 = v10;
        v17 = 0;
        v12 = *v9;
        v10[1] = &AddressLookupTableObject::`vftable';
        LOBYTE(v17) = 1;
        v10[2] = v12;
        *v10 = &Direct3DSurface8::`vftable';
        v10[1] = &Direct3DSurface8::`vftable';
        v10[3] = v8;
        v13 = (_DWORD *)(*(_DWORD *)(v12 + 4) + 4);
        a2 = v8;
        *(_DWORD *)sub_1001A560(v13, (unsigned __int8 *)&a2) = v10 + 1;
      }
      else
      {
        v10 = v11[3] != 0 ? (_DWORD *)(v11[3] - 4) : 0;
      }
    }
    else
    {
      v10 = 0;
    }
    *a4 = v10;
    return 0;
  }
  return result;
}
// 1001AFE0: could not find valid save-restore pair for esi
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (1001B120) --------------------------------------------------------
int __cdecl sub_1001B120(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 76))(*(_DWORD *)(a1 + 12));
}

//----- (1001B140) --------------------------------------------------------
int __cdecl sub_1001B140(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 80))(*(_DWORD *)(a1 + 12));
}

//----- (1001B160) --------------------------------------------------------
int __cdecl sub_1001B160(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 84))(*(_DWORD *)(a1 + 12));
}

//----- (1001B180) --------------------------------------------------------
_DWORD *__thiscall sub_1001B180(_DWORD *Block, char a2)
{
  *Block = &Direct3DCubeTexture8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C3F0: using guessed type void *Direct3DCubeTexture8::`vftable';

//----- (1001B1B0) --------------------------------------------------------
int __stdcall sub_1001B1B0(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi
  unsigned int v9; // esi
  unsigned int v10; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C31C;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_18:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  v5 = a2;
  v4 = &unk_1004C228;
  v9 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v9 < 4;
    v9 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  v5 = a2;
  v4 = &unk_1004C3DC;
  v10 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001B2B0) --------------------------------------------------------
int __stdcall sub_1001B2B0(int a1)
{
  return 5;
}

//----- (1001B2C0) --------------------------------------------------------
int __userpurge sub_1001B2C0@<eax>(int a1@<esi>, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int result; // eax
  int v6; // esi
  int v7; // ecx
  int v8; // eax
  int v9; // ebx
  int *v10; // esi
  _DWORD *v11; // edi
  int *v12; // edi
  int v13; // ecx
  _DWORD *v14; // ecx
  int *v16; // [esp+0h] [ebp-18h] BYREF
  int v17; // [esp+8h] [ebp-10h] BYREF
  int v18; // [esp+14h] [ebp-4h]

  if ( !a5 )
    return -2005530516;
  v6 = a2;
  *a5 = 0;
  v7 = *(_DWORD *)(v6 + 12);
  v17 = 0;
  result = (*(int (__stdcall **)(int, int, _DWORD *, int *, int))(*(_DWORD *)v7 + 72))(v7, a3, a4, &v17, a1);
  if ( result >= 0 )
  {
    v8 = *(_DWORD *)(v6 + 8);
    v9 = v17;
    a2 = v17;
    v10 = *(int **)(v8 + 4);
    if ( v17 )
    {
      v12 = sub_10016580(
              v10 + 1,
              &v16,
              &a2,
              16777619
            * (HIBYTE(v17) ^ (16777619
                            * (BYTE2(v17) ^ (16777619 * (BYTE1(v17) ^ (16777619 * ((unsigned __int8)v17 ^ 0x811C9DC5))))))))[1];
      if ( !v12 )
        v12 = (int *)v10[2];
      if ( v12 == (int *)v10[2] )
      {
        v11 = operator new(0x10u);
        a4 = v11;
        v18 = 0;
        v13 = *v10;
        v11[1] = &AddressLookupTableObject::`vftable';
        LOBYTE(v18) = 1;
        v11[2] = v13;
        *v11 = &Direct3DSurface8::`vftable';
        v11[1] = &Direct3DSurface8::`vftable';
        v11[3] = v9;
        v14 = (_DWORD *)(*(_DWORD *)(v13 + 4) + 4);
        a2 = v9;
        *(_DWORD *)sub_1001A560(v14, (unsigned __int8 *)&a2) = v11 + 1;
      }
      else
      {
        v11 = v12[3] != 0 ? (_DWORD *)(v12[3] - 4) : 0;
      }
    }
    else
    {
      v11 = 0;
    }
    *a5 = v11;
    return 0;
  }
  return result;
}
// 1001B2C0: could not find valid save-restore pair for esi
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C290: using guessed type void *Direct3DSurface8::`vftable';
// 1004C298: using guessed type void *Direct3DSurface8::`vftable';

//----- (1001B400) --------------------------------------------------------
_DWORD *__thiscall sub_1001B400(_DWORD *Block, char a2)
{
  *Block = &Direct3DVolumeTexture8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C390: using guessed type void *Direct3DVolumeTexture8::`vftable';

//----- (1001B430) --------------------------------------------------------
int __stdcall sub_1001B430(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi
  unsigned int v9; // esi
  unsigned int v10; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C2F4;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_18:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  v5 = a2;
  v4 = &unk_1004C228;
  v9 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v9 < 4;
    v9 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  v5 = a2;
  v4 = &unk_1004C3DC;
  v10 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v10 < 4;
    v10 -= 4;
    if ( v7 )
      goto LABEL_18;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001B530) --------------------------------------------------------
int __stdcall sub_1001B530(int a1)
{
  return 4;
}

//----- (1001B540) --------------------------------------------------------
int __stdcall sub_1001B540(int a1, int a2, unsigned int *a3)
{
  int result; // eax
  unsigned int v4; // ecx
  int v5; // edx
  int v6; // esi
  int v7; // edi
  int v8; // eax
  int v9; // eax
  unsigned int v10; // edx
  int v11[7]; // [esp+4h] [ebp-1Ch] BYREF

  if ( !a3 )
    return -2005530516;
  result = (*(int (__stdcall **)(_DWORD, int, int *))(**(_DWORD **)(a1 + 12) + 68))(*(_DWORD *)(a1 + 12), a2, v11);
  if ( result >= 0 )
  {
    v4 = v11[0];
    v5 = v11[5];
    v6 = v11[4];
    v7 = v11[6];
    a3[1] = v11[1];
    v8 = v11[2];
    *a3 = v4;
    a3[2] = v8;
    a3[3] = v11[3];
    v9 = sub_1001BA00(v6, v5, v7, v4);
    a3[7] = v7;
    a3[4] = v9;
    result = 0;
    a3[5] = v6;
    a3[6] = v10;
  }
  return result;
}
// 1001B5AA: variable 'v10' is possibly undefined

//----- (1001B5C0) --------------------------------------------------------
int __userpurge sub_1001B5C0@<eax>(int a1@<esi>, int a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax
  int v5; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  int *v9; // esi
  _DWORD *v10; // edi
  int *v11; // edi
  int v12; // ecx
  _DWORD *v13; // ecx
  int *v15; // [esp+0h] [ebp-18h] BYREF
  int v16; // [esp+8h] [ebp-10h] BYREF
  int v17; // [esp+14h] [ebp-4h]

  if ( !a4 )
    return -2005530516;
  v5 = a2;
  *a4 = 0;
  v6 = *(_DWORD *)(v5 + 12);
  v16 = 0;
  result = (*(int (__stdcall **)(int, _DWORD *, int *, int))(*(_DWORD *)v6 + 72))(v6, a3, &v16, a1);
  if ( result >= 0 )
  {
    v7 = *(_DWORD *)(v5 + 8);
    v8 = v16;
    a2 = v16;
    v9 = *(int **)(v7 + 4);
    if ( v16 )
    {
      v11 = sub_10016580(
              v9 + 33,
              &v15,
              &a2,
              16777619
            * (HIBYTE(v16) ^ (16777619
                            * (BYTE2(v16) ^ (16777619 * (BYTE1(v16) ^ (16777619 * ((unsigned __int8)v16 ^ 0x811C9DC5))))))))[1];
      if ( !v11 )
        v11 = (int *)v9[34];
      if ( v11 == (int *)v9[34] )
      {
        v10 = operator new(0x10u);
        a3 = v10;
        v17 = 0;
        v12 = *v9;
        v10[1] = &AddressLookupTableObject::`vftable';
        LOBYTE(v17) = 1;
        v10[2] = v12;
        *v10 = &Direct3DVolume8::`vftable';
        v10[1] = &Direct3DVolume8::`vftable';
        v10[3] = v8;
        v13 = (_DWORD *)(*(_DWORD *)(v12 + 4) + 132);
        a2 = v8;
        *(_DWORD *)sub_1001A560(v13, (unsigned __int8 *)&a2) = v10 + 1;
      }
      else
      {
        v10 = v11[3] != 0 ? (_DWORD *)(v11[3] - 4) : 0;
      }
    }
    else
    {
      v10 = 0;
    }
    *a4 = v10;
    return 0;
  }
  return result;
}
// 1001B5C0: could not find valid save-restore pair for esi
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C494: using guessed type void *Direct3DVolume8::`vftable';
// 1004C49C: using guessed type void *Direct3DVolume8::`vftable';

//----- (1001B709) --------------------------------------------------------
_DWORD *__thiscall sub_1001B709(_DWORD *this, char a2)
{
  return sub_1001B180(this - 1, a2);
}

//----- (1001B711) --------------------------------------------------------
_DWORD *__thiscall sub_1001B711(_DWORD *this, char a2)
{
  return sub_1001B400(this - 1, a2);
}

//----- (1001B719) --------------------------------------------------------
_DWORD *__thiscall sub_1001B719(_DWORD *this, char a2)
{
  return sub_1001ADF0(this - 1, a2);
}

//----- (1001B730) --------------------------------------------------------
_DWORD *__thiscall sub_1001B730(_DWORD *Block, char a2)
{
  *Block = &Direct3DVertexBuffer8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C440: using guessed type void *Direct3DVertexBuffer8::`vftable';

//----- (1001B760) --------------------------------------------------------
int __stdcall sub_1001B760(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi
  unsigned int v9; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C480;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_14:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_14;
  }
  v5 = a2;
  v4 = &unk_1004C228;
  v9 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v9 < 4;
    v9 -= 4;
    if ( v7 )
      goto LABEL_14;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001B830) --------------------------------------------------------
int __stdcall sub_1001B830(int a1)
{
  return 6;
}

//----- (1001B840) --------------------------------------------------------
int __stdcall sub_1001B840(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  char v7[8]; // [esp+8h] [ebp-18h] BYREF
  int v8; // [esp+10h] [ebp-10h]

  v5 = a5;
  if ( (a5 & 0x2000) != 0 )
  {
    (*(void (__stdcall **)(_DWORD, char *))(**(_DWORD **)(a1 + 12) + 52))(*(_DWORD *)(a1 + 12), v7);
    if ( (v8 & 0x200) == 0 || (v8 & 8) == 0 )
      v5 = a5 ^ 0x2000;
  }
  return (*(int (__stdcall **)(_DWORD, int, int, int, int))(**(_DWORD **)(a1 + 12) + 44))(
           *(_DWORD *)(a1 + 12),
           a2,
           a3,
           a4,
           v5);
}
// 1001B840: using guessed type char var_18[8];

//----- (1001B892) --------------------------------------------------------
_DWORD *__thiscall sub_1001B892(_DWORD *this, char a2)
{
  return sub_1001B730(this - 1, a2);
}

//----- (1001B8A0) --------------------------------------------------------
_DWORD *__thiscall sub_1001B8A0(_DWORD *Block, char a2)
{
  *Block = &Direct3DVolume8::`vftable';
  Block[1] = &AddressLookupTableObject::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1004C23C: using guessed type void *AddressLookupTableObject::`vftable';
// 1004C49C: using guessed type void *Direct3DVolume8::`vftable';

//----- (1001B8D0) --------------------------------------------------------
int __stdcall sub_1001B8D0(int (__stdcall ****a1)(_DWORD, _DWORD, _DWORD), _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  bool v7; // cf
  unsigned int v8; // esi

  if ( !a3 )
    return -2147467261;
  v4 = &unk_1004C4C8;
  v5 = a2;
  v6 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v6 < 4;
    v6 -= 4;
    if ( v7 )
    {
LABEL_6:
      ((void (__fastcall *)(_DWORD *, _DWORD *, int (__stdcall ****)(_DWORD, _DWORD, _DWORD)))(*a1)[1])(v5, v4, a1);
      *a3 = a1;
      return 0;
    }
  }
  v5 = a2;
  v4 = &unk_1004A958;
  v8 = 12;
  while ( *v5 == *v4 )
  {
    ++v5;
    ++v4;
    v7 = v8 < 4;
    v8 -= 4;
    if ( v7 )
      goto LABEL_6;
  }
  return (**a1[3])(a1[3], a2, a3);
}

//----- (1001B960) --------------------------------------------------------
int __stdcall sub_1001B960(int a1, unsigned int *a2)
{
  int result; // eax
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // esi
  int v6; // edi
  int v7; // eax
  int v8; // eax
  unsigned int v9; // edx
  int v10[7]; // [esp+4h] [ebp-1Ch] BYREF

  if ( !a2 )
    return -2005530516;
  result = (*(int (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 12) + 32))(*(_DWORD *)(a1 + 12), v10);
  if ( result >= 0 )
  {
    v3 = v10[0];
    v4 = v10[5];
    v5 = v10[4];
    v6 = v10[6];
    a2[1] = v10[1];
    v7 = v10[2];
    *a2 = v3;
    a2[2] = v7;
    a2[3] = v10[3];
    v8 = sub_1001BA00(v5, v4, v6, v3);
    a2[7] = v6;
    a2[4] = v8;
    result = 0;
    a2[5] = v5;
    a2[6] = v9;
  }
  return result;
}
// 1001B9C7: variable 'v9' is possibly undefined

//----- (1001B9E0) --------------------------------------------------------
int __cdecl sub_1001B9E0(int a1)
{
  return (*(int (__cdecl **)(_DWORD))(**(_DWORD **)(a1 + 12) + 40))(*(_DWORD *)(a1 + 12));
}

//----- (1001B9F2) --------------------------------------------------------
_DWORD *__thiscall sub_1001B9F2(_DWORD *this, char a2)
{
  return sub_1001B8A0(this - 1, a2);
}

//----- (1001BA00) --------------------------------------------------------
int __fastcall sub_1001BA00(int a1, int a2, int a3, unsigned int a4)
{
  int result; // eax

  if ( a4 > 0x31545844 )
  {
    if ( a4 > 0x34545844 )
    {
      if ( a4 == 894720068 )
        return 16 * ((unsigned int)(a2 + 3) >> 2) * ((unsigned int)(a1 + 3) >> 2);
      if ( a4 != 1498831189 )
        return 0;
    }
    else
    {
      if ( a4 == 877942852 || a4 == 844388420 )
        return 16 * ((unsigned int)(a2 + 3) >> 2) * ((unsigned int)(a1 + 3) >> 2);
      if ( a4 != 844715353 )
      {
        if ( a4 == 861165636 )
          return 16 * ((unsigned int)(a2 + 3) >> 2) * ((unsigned int)(a1 + 3) >> 2);
        return 0;
      }
    }
    return 2 * a3 * a2 * a1;
  }
  if ( a4 == 827611204 )
    return 8 * ((unsigned int)(a2 + 3) >> 2) * ((unsigned int)(a1 + 3) >> 2);
  switch ( a4 )
  {
    case 0x14u:
      result = 3 * a3 * a2 * a1;
      break;
    case 0x15u:
    case 0x16u:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x22u:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
    case 0x41u:
    case 0x43u:
    case 0x47u:
    case 0x4Bu:
    case 0x4Du:
    case 0x4Fu:
      result = 4 * a3 * a2 * a1;
      break;
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Du:
    case 0x1Eu:
    case 0x28u:
    case 0x33u:
    case 0x3Cu:
    case 0x3Du:
    case 0x46u:
    case 0x49u:
    case 0x50u:
      return 2 * a3 * a2 * a1;
    case 0x1Bu:
    case 0x1Cu:
    case 0x29u:
    case 0x32u:
    case 0x34u:
      result = a3 * a2 * a1;
      break;
    default:
      return 0;
  }
  return result;
}

//----- (1001BB20) --------------------------------------------------------
int __fastcall sub_1001BB20(_DWORD *a1, _DWORD *a2)
{
  int v3; // ecx
  int result; // eax
  int v5; // [esp-4h] [ebp-8h]

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = 0;
  a2[6] = a1[5];
  a2[7] = a1[6];
  a2[8] = a1[7];
  a2[9] = a1[8];
  a2[10] = a1[9];
  a2[11] = a1[10];
  a2[12] = a1[11];
  v5 = a1[12];
  a2[13] = v5;
  sub_100010C0((int)&unk_1004C4D8, v5);
  Sleep(0x3E8u);
  v3 = a2[6];
  if ( v3 != 1 )
    a2[4] = 0;
  if ( a2[4] )
    a2[11] &= ~1u;
  result = a2[13];
  if ( result == 0x7FFFFFFF )
  {
    a2[13] = 0x80000000;
  }
  else if ( !result )
  {
    a2[13] = 1;
  }
  if ( v3 == 4 )
  {
    a2[13] = 1;
    a2[6] = 3;
  }
  return result;
}

//----- (1001BBF0) --------------------------------------------------------
void __thiscall sub_1001BBF0(int this)
{
  _DWORD *v2; // eax
  _DWORD **v3; // ecx
  _DWORD *v4; // eax
  _DWORD *v5; // esi

  v2 = *(_DWORD **)(this + 12);
  if ( v2 )
  {
    if ( ((*(_DWORD *)(this + 20) - (_DWORD)v2) & 0xFFFFFFFC) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_1001D481(v2);
    *(_DWORD *)(this + 12) = 0;
    *(_DWORD *)(this + 16) = 0;
    *(_DWORD *)(this + 20) = 0;
  }
  v3 = *(_DWORD ***)(this + 4);
  *v3[1] = 0;
  v4 = *v3;
  if ( *v3 )
  {
    do
    {
      v5 = (_DWORD *)*v4;
      sub_1001D481(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  sub_1001D481(*(void **)(this + 4));
}

//----- (1001BC80) --------------------------------------------------------
void __thiscall sub_1001BC80(_DWORD *this)
{
  _DWORD *v2; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  v2 = operator new(0x10u);
  *v2 = v2;
  v2[1] = v2;
  this[1] = v2;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  this[6] = 7;
  this[7] = 8;
  *this = 1065353216;
  sub_1001A930(this + 3, 0x10u, this[1]);
}

//----- (1001BDBC) --------------------------------------------------------
_DWORD *__thiscall sub_1001BDBC(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad allocation";
  *this = &std::bad_alloc::`vftable';
  return result;
}
// 1003E230: using guessed type void *std::bad_alloc::`vftable';

//----- (1001BDD4) --------------------------------------------------------
_DWORD *__thiscall sub_1001BDD4(_DWORD *this, int a2)
{
  sub_10001190(this, a2);
  *this = &std::length_error::`vftable';
  return this;
}
// 1003E258: using guessed type void *std::length_error::`vftable';

//----- (1001BDEF) --------------------------------------------------------
_DWORD *__thiscall sub_1001BDEF(_DWORD *this, int a2)
{
  sub_10001150(this, a2);
  *this = &std::length_error::`vftable';
  return this;
}
// 1003E258: using guessed type void *std::length_error::`vftable';

//----- (1001BE0E) --------------------------------------------------------
_DWORD *__thiscall sub_1001BE0E(_DWORD *this, int a2)
{
  sub_10001190(this, a2);
  *this = &std::logic_error::`vftable';
  return this;
}
// 1003E24C: using guessed type void *std::logic_error::`vftable';

//----- (1001BE29) --------------------------------------------------------
_DWORD *__thiscall sub_1001BE29(_DWORD *this, int a2)
{
  sub_10001190(this, a2);
  *this = &std::out_of_range::`vftable';
  return this;
}
// 1003E264: using guessed type void *std::out_of_range::`vftable';

//----- (1001BE44) --------------------------------------------------------
_DWORD *__thiscall sub_1001BE44(_DWORD *this, int a2)
{
  sub_10001150(this, a2);
  *this = &std::out_of_range::`vftable';
  return this;
}
// 1003E264: using guessed type void *std::out_of_range::`vftable';

//----- (1001BEB5) --------------------------------------------------------
_DWORD *__thiscall sub_1001BEB5(_DWORD *this, int a2)
{
  sub_10001150(this, a2);
  *this = &std::runtime_error::`vftable';
  return this;
}
// 1003E270: using guessed type void *std::runtime_error::`vftable';

//----- (1001BFF1) --------------------------------------------------------
void __noreturn sub_1001BFF1()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_1001BDBC(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 1001BFF1: using guessed type void __noreturn sub_1001BFF1();
// 1001BFF1: using guessed type _DWORD pExceptionObject[3];

//----- (1001C00E) --------------------------------------------------------
void __cdecl __noreturn sub_1001C00E(int a1)
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_1001BDEF(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}
// 1001C00E: using guessed type _DWORD pExceptionObject[3];

//----- (1001C02E) --------------------------------------------------------
void __cdecl __noreturn sub_1001C02E(int a1)
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_1001BE44(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
}
// 1001C02E: using guessed type _DWORD pExceptionObject[3];

//----- (1001C06E) --------------------------------------------------------
void __cdecl __noreturn sub_1001C06E(int a1)
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_1001BEB5(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
}
// 1001C06E: using guessed type _DWORD pExceptionObject[3];

//----- (1001C2BD) --------------------------------------------------------
int sub_1001C2BD()
{
  return dword_1005243C;
}
// 1005243C: using guessed type int dword_1005243C;

//----- (1001C2C3) --------------------------------------------------------
struct std::locale::_Locimp *__cdecl sub_1001C2C3(char a1)
{
  struct std::locale::_Locimp *v1; // edi
  char v3[12]; // [esp+10h] [ebp-10h] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v3, 0);
  v1 = (struct std::locale::_Locimp *)dword_1005243C;
  v4 = 0;
  if ( !dword_1005243C )
  {
    v1 = std::locale::_Locimp::_New_Locimp(0);
    std::locale::_Setgloballocale(v1);
    *((_DWORD *)v1 + 4) = 63;
    std::_Yarn<char>::operator=(&unk_1003F338);
    (*(void (__thiscall **)(struct std::locale::_Locimp *))(*(_DWORD *)v1 + 4))(v1);
    dword_10052430 = (int)v1;
    dword_10052414 = (int)v1;
  }
  if ( a1 )
    (*(void (__thiscall **)(struct std::locale::_Locimp *))(*(_DWORD *)v1 + 4))(v1);
  std::_Lockit::~_Lockit((std::_Lockit *)v3);
  return v1;
}
// 10052414: using guessed type int dword_10052414;
// 10052430: using guessed type int dword_10052430;
// 1005243C: using guessed type int dword_1005243C;

//----- (1001C5C3) --------------------------------------------------------
FILE *__cdecl sub_1001C5C3(char *FileName, int a2, int ShFlag)
{
  int v3; // eax
  unsigned int v4; // eax
  int v5; // ecx
  FILE *v6; // eax
  FILE *v7; // esi

  v3 = a2;
  if ( (a2 & 0x40) != 0 )
    v3 = a2 | 1;
  if ( (v3 & 8) != 0 )
    v3 |= 2u;
  v4 = v3 & 0xFFFFFFBB;
  v5 = 0;
  if ( dword_10051008[0] != v4 )
  {
    while ( ++v5 != 20 )
    {
      if ( dword_10051008[v5] == v4 )
        goto LABEL_8;
    }
    return 0;
  }
LABEL_8:
  v6 = _fsopen(FileName, (&off_1003F348)[v5], ShFlag);
  v7 = v6;
  if ( !v6 )
    return 0;
  if ( (a2 & 4) != 0 && fseek(v6, 0, 2) )
  {
    fclose(v7);
    return 0;
  }
  return v7;
}
// 10051008: using guessed type int dword_10051008[20];

//----- (1001C63D) --------------------------------------------------------
FILE *__cdecl sub_1001C63D(char *FileName, int a2, int ShFlag)
{
  return sub_1001C5C3(FileName, a2, ShFlag);
}

//----- (1001CB1F) --------------------------------------------------------
void __cdecl sub_1001CB1F(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (1001D235) --------------------------------------------------------
char sub_1001D235()
{
  __acrt_thread_detach();
  __vcrt_thread_detach();
  return 1;
}

//----- (1001D299) --------------------------------------------------------
__vcrt_bool sub_1001D299()
{
  __acrt_uninitialize_critical(0);
  return __vcrt_uninitialize_critical();
}

//----- (1001D481) --------------------------------------------------------
void __cdecl sub_1001D481(void *Block)
{
  j__free(Block);
}

//----- (1001D48F) --------------------------------------------------------
_DWORD *__thiscall sub_1001D48F(_DWORD *Block, char a2)
{
  *Block = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_1001D481(Block);
  return Block;
}
// 1003F788: using guessed type void *type_info::`vftable';

//----- (1001DD8F) --------------------------------------------------------
void sub_1001DD8F()
{
  dword_100525B0 = 0;
}
// 100525B0: using guessed type int dword_100525B0;

//----- (1001DD97) --------------------------------------------------------
int sub_1001DD97()
{
  return 1;
}

//----- (1001DE92) --------------------------------------------------------
void sub_1001DE92()
{
  InitializeSListHead(&ListHead);
}

//----- (1001DE9E) --------------------------------------------------------
int sub_1001DE9E()
{
  return __std_type_info_destroy_list(&ListHead);
}

//----- (1001DEAA) --------------------------------------------------------
void *sub_1001DEAA()
{
  return &unk_100525C0;
}

//----- (1001DECD) --------------------------------------------------------
void *sub_1001DECD()
{
  return &unk_10053230;
}

//----- (1001DED3) --------------------------------------------------------
void sub_1001DED3()
{
  ;
}
// 1001DED3: could not find valid save-restore pair for edi

//----- (1001DEFF) --------------------------------------------------------
void sub_1001DEFF()
{
  ;
}
// 1001DEFF: could not find valid save-restore pair for edi

//----- (1001E9CB) --------------------------------------------------------
int sub_1001E9CB()
{
  return dword_10052910;
}
// 10052910: using guessed type int dword_10052910;

//----- (10021652) --------------------------------------------------------
_DWORD *__thiscall sub_10021652(_DWORD *this, int a2)
{
  sub_10001190(this, a2);
  *this = &std::bad_exception::`vftable';
  return this;
}
// 1003FBE8: using guessed type void *std::bad_exception::`vftable';

//----- (1002166D) --------------------------------------------------------
_DWORD *__thiscall sub_1002166D(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad exception";
  *this = &std::bad_exception::`vftable';
  return result;
}
// 1003FBE8: using guessed type void *std::bad_exception::`vftable';

//----- (10021D30) --------------------------------------------------------
void __stdcall sub_10021D30(int a1)
{
  JUMPOUT(0x10021D4B);
}
// 10021D37: control flows out of bounds to 10021D4B

//----- (10021D60) --------------------------------------------------------
int __usercall sub_10021D60@<eax>(int (*a1)(void)@<eax>)
{
  return a1();
}

//----- (100229A4) --------------------------------------------------------
char __thiscall sub_100229A4(int this, int a2)
{
  int v3; // eax
  int v4; // eax
  int v6; // ecx
  int v7; // edi
  __int64 v8; // rax
  __int64 v9; // rax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp-8h] [ebp-1Ch]
  int v15; // [esp-4h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+10h] [ebp-4h]

  v3 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 40));
  v16 = v3;
  if ( v3 == 1 )
  {
    v6 = *(_DWORD *)(this + 28);
    *(_DWORD *)(this + 16) += 4;
    v13 = *(_DWORD *)(this + 16);
    if ( (v6 & 0x10) != 0 )
      v12 = *(char *)(v13 - 4);
    else
      v12 = *(unsigned __int8 *)(v13 - 4);
    v9 = v12;
  }
  else
  {
    if ( v3 != 2 )
    {
      if ( v3 == 4 )
      {
        v6 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 16) += 4;
        v10 = *(_DWORD *)(this + 16);
        if ( (v6 & 0x10) == 0 )
        {
          v7 = *(_DWORD *)(v10 - 4);
          v17 = 0;
          goto LABEL_8;
        }
        v8 = *(int *)(v10 - 4);
        v7 = v8;
      }
      else
      {
        if ( v3 != 8 )
        {
          v4 = *(_DWORD *)(this + 8) + 24;
          *(_BYTE *)(v4 + 4) = 1;
          *(_DWORD *)v4 = 22;
          _invalid_parameter_internal(0, 0, 0, 0, 0, *(__crt_cached_ptd_host **)(this + 8));
          return 0;
        }
        v6 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 16) += 8;
        LODWORD(v8) = *(_DWORD *)(this + 16);
        v7 = *(_DWORD *)(v8 - 8);
        HIDWORD(v8) = *(_DWORD *)(v8 - 4);
      }
      v17 = HIDWORD(v8);
LABEL_8:
      HIDWORD(v9) = v17;
      goto LABEL_21;
    }
    v6 = *(_DWORD *)(this + 28);
    *(_DWORD *)(this + 16) += 4;
    v11 = *(_DWORD *)(this + 16);
    if ( (v6 & 0x10) != 0 )
      v12 = *(__int16 *)(v11 - 4);
    else
      v12 = *(unsigned __int16 *)(v11 - 4);
    v9 = v12;
  }
  v7 = v12;
LABEL_21:
  if ( (v6 & 0x10) != 0 && v9 < 0 )
  {
    v7 = -v7;
    HIDWORD(v9) = (unsigned __int64)-__SPAIR64__(HIDWORD(v9), v7) >> 32;
    v6 |= 0x40u;
    *(_DWORD *)(this + 28) = v6;
  }
  v18 = HIDWORD(v9);
  if ( *(int *)(this + 36) >= 0 )
  {
    v15 = *(_DWORD *)(this + 8);
    v14 = *(_DWORD *)(this + 36);
    *(_DWORD *)(this + 28) = v6 & 0xFFFFFFF7;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(v14, v15);
    HIDWORD(v9) = v18;
  }
  else
  {
    *(_DWORD *)(this + 36) = 1;
  }
  if ( !(HIDWORD(v9) | v7) )
    *(_DWORD *)(this + 28) &= ~0x20u;
  *(_BYTE *)(this + 56) = 0;
  if ( v16 == 8 )
    unknown_libname_9(v7, HIDWORD(v9), a2);
  else
    unknown_libname_6(v7, a2);
  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_BYTE **)(this + 48) != 48) )
  {
    *(_BYTE *)--*(_DWORD *)(this + 48) = 48;
    ++*(_DWORD *)(this + 52);
  }
  return 1;
}
// 10022679: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD, _DWORD);
// 10022E1B: using guessed type _DWORD __stdcall unknown_libname_6(_DWORD, _DWORD);
// 10022F87: using guessed type _DWORD __stdcall unknown_libname_9(_DWORD, _DWORD, _DWORD);
// 10024766: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (10022B21) --------------------------------------------------------
char __thiscall sub_10022B21(int this, char a2)
{
  int v3; // eax
  int v4; // eax
  int v6; // ecx
  int v7; // edi
  __int64 v8; // rax
  __int64 v9; // rax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp-8h] [ebp-1Ch]
  int v15; // [esp-4h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+10h] [ebp-4h]

  v3 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 40));
  v16 = v3;
  if ( v3 == 1 )
  {
    v6 = *(_DWORD *)(this + 28);
    *(_DWORD *)(this + 16) += 4;
    v13 = *(_DWORD *)(this + 16);
    if ( (v6 & 0x10) != 0 )
      v12 = *(char *)(v13 - 4);
    else
      v12 = *(unsigned __int8 *)(v13 - 4);
    v9 = v12;
  }
  else
  {
    if ( v3 != 2 )
    {
      if ( v3 == 4 )
      {
        v6 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 16) += 4;
        v10 = *(_DWORD *)(this + 16);
        if ( (v6 & 0x10) == 0 )
        {
          v7 = *(_DWORD *)(v10 - 4);
          v17 = 0;
          goto LABEL_8;
        }
        v8 = *(int *)(v10 - 4);
        v7 = v8;
      }
      else
      {
        if ( v3 != 8 )
        {
          v4 = *(_DWORD *)(this + 8) + 24;
          *(_BYTE *)(v4 + 4) = 1;
          *(_DWORD *)v4 = 22;
          _invalid_parameter_internal(0, 0, 0, 0, 0, *(__crt_cached_ptd_host **)(this + 8));
          return 0;
        }
        v6 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 16) += 8;
        LODWORD(v8) = *(_DWORD *)(this + 16);
        v7 = *(_DWORD *)(v8 - 8);
        HIDWORD(v8) = *(_DWORD *)(v8 - 4);
      }
      v17 = HIDWORD(v8);
LABEL_8:
      HIDWORD(v9) = v17;
      goto LABEL_21;
    }
    v6 = *(_DWORD *)(this + 28);
    *(_DWORD *)(this + 16) += 4;
    v11 = *(_DWORD *)(this + 16);
    if ( (v6 & 0x10) != 0 )
      v12 = *(__int16 *)(v11 - 4);
    else
      v12 = *(unsigned __int16 *)(v11 - 4);
    v9 = v12;
  }
  v7 = v12;
LABEL_21:
  if ( (v6 & 0x10) != 0 && v9 < 0 )
  {
    v7 = -v7;
    HIDWORD(v9) = (unsigned __int64)-__SPAIR64__(HIDWORD(v9), v7) >> 32;
    v6 |= 0x40u;
    *(_DWORD *)(this + 28) = v6;
  }
  v18 = HIDWORD(v9);
  if ( *(int *)(this + 36) >= 0 )
  {
    v15 = *(_DWORD *)(this + 8);
    v14 = *(_DWORD *)(this + 36);
    *(_DWORD *)(this + 28) = v6 & 0xFFFFFFF7;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(v14, v15);
    HIDWORD(v9) = v18;
  }
  else
  {
    *(_DWORD *)(this + 36) = 1;
  }
  if ( !(HIDWORD(v9) | v7) )
    *(_DWORD *)(this + 28) &= ~0x20u;
  *(_BYTE *)(this + 56) = 0;
  if ( v16 == 8 )
    unknown_libname_10(v7, HIDWORD(v9), a2);
  else
    unknown_libname_7(v7, a2);
  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_BYTE **)(this + 48) != 48) )
  {
    *(_BYTE *)--*(_DWORD *)(this + 48) = 48;
    ++*(_DWORD *)(this + 52);
  }
  return 1;
}
// 10022679: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD, _DWORD);
// 10022E85: using guessed type _DWORD __stdcall unknown_libname_7(_DWORD, char);
// 10022FFF: using guessed type _DWORD __stdcall unknown_libname_10(_DWORD, _DWORD, char);
// 10024766: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (10022C9E) --------------------------------------------------------
char __thiscall sub_10022C9E(int this, char a2)
{
  int v3; // eax
  int v4; // eax
  int v6; // ecx
  int v7; // edi
  __int64 v8; // rax
  __int64 v9; // rax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp-8h] [ebp-1Ch]
  int v15; // [esp-4h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+10h] [ebp-4h]

  v3 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 40));
  v16 = v3;
  if ( v3 == 1 )
  {
    v6 = *(_DWORD *)(this + 28);
    *(_DWORD *)(this + 16) += 4;
    v13 = *(_DWORD *)(this + 16);
    if ( (v6 & 0x10) != 0 )
      v12 = *(char *)(v13 - 4);
    else
      v12 = *(unsigned __int8 *)(v13 - 4);
    v9 = v12;
  }
  else
  {
    if ( v3 != 2 )
    {
      if ( v3 == 4 )
      {
        v6 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 16) += 4;
        v10 = *(_DWORD *)(this + 16);
        if ( (v6 & 0x10) == 0 )
        {
          v7 = *(_DWORD *)(v10 - 4);
          v17 = 0;
          goto LABEL_8;
        }
        v8 = *(int *)(v10 - 4);
        v7 = v8;
      }
      else
      {
        if ( v3 != 8 )
        {
          v4 = *(_DWORD *)(this + 8) + 24;
          *(_BYTE *)(v4 + 4) = 1;
          *(_DWORD *)v4 = 22;
          _invalid_parameter_internal(0, 0, 0, 0, 0, *(__crt_cached_ptd_host **)(this + 8));
          return 0;
        }
        v6 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 16) += 8;
        LODWORD(v8) = *(_DWORD *)(this + 16);
        v7 = *(_DWORD *)(v8 - 8);
        HIDWORD(v8) = *(_DWORD *)(v8 - 4);
      }
      v17 = HIDWORD(v8);
LABEL_8:
      HIDWORD(v9) = v17;
      goto LABEL_21;
    }
    v6 = *(_DWORD *)(this + 28);
    *(_DWORD *)(this + 16) += 4;
    v11 = *(_DWORD *)(this + 16);
    if ( (v6 & 0x10) != 0 )
      v12 = *(__int16 *)(v11 - 4);
    else
      v12 = *(unsigned __int16 *)(v11 - 4);
    v9 = v12;
  }
  v7 = v12;
LABEL_21:
  if ( (v6 & 0x10) != 0 && v9 < 0 )
  {
    v7 = -v7;
    HIDWORD(v9) = (unsigned __int64)-__SPAIR64__(HIDWORD(v9), v7) >> 32;
    v6 |= 0x40u;
    *(_DWORD *)(this + 28) = v6;
  }
  v18 = HIDWORD(v9);
  if ( *(int *)(this + 36) >= 0 )
  {
    v15 = *(_DWORD *)(this + 8);
    v14 = *(_DWORD *)(this + 36);
    *(_DWORD *)(this + 28) = v6 & 0xFFFFFFF7;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(v14, v15);
    HIDWORD(v9) = v18;
  }
  else
  {
    *(_DWORD *)(this + 36) = 1;
  }
  if ( !(HIDWORD(v9) | v7) )
    *(_DWORD *)(this + 28) &= ~0x20u;
  *(_BYTE *)(this + 56) = 0;
  if ( v16 == 8 )
    unknown_libname_11(v7, HIDWORD(v9), a2);
  else
    unknown_libname_8(v7, a2);
  if ( (*(_DWORD *)(this + 28) & 0x80) != 0 && (!*(_DWORD *)(this + 52) || **(_BYTE **)(this + 48) != 48) )
  {
    *(_BYTE *)--*(_DWORD *)(this + 48) = 48;
    ++*(_DWORD *)(this + 52);
  }
  return 1;
}
// 10022679: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD, _DWORD);
// 10022EFF: using guessed type _DWORD __stdcall unknown_libname_8(_DWORD, char);
// 1002309B: using guessed type _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD, char);
// 10024766: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (10023DD4) --------------------------------------------------------
char __thiscall sub_10023DD4(int this)
{
  char v1; // al
  int v3; // eax
  _BYTE *v4; // eax
  int v5; // eax
  char *v6; // edx
  char v7; // al
  _BYTE *v8; // eax
  int v9; // [esp-4h] [ebp-4h]

  v1 = *(_BYTE *)(this + 45);
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *(_BYTE *)(this + 24) = 7;
      return sub_10024090(this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *(_BYTE *)(this + 24) = 8;
LABEL_7:
      v3 = *(_DWORD *)(this + 8) + 24;
      *(_BYTE *)(v3 + 4) = 1;
      *(_DWORD *)v3 = 22;
      _invalid_parameter_internal(0, 0, 0, 0, 0, *(__crt_cached_ptd_host **)(this + 8));
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(this + 40) )
    goto LABEL_7;
  if ( v1 > 106 )
  {
    if ( v1 != 108 )
    {
      switch ( v1 )
      {
        case 't':
          *(_DWORD *)(this + 40) = 7;
          break;
        case 'w':
          *(_DWORD *)(this + 40) = 12;
          break;
        case 'z':
          *(_DWORD *)(this + 40) = 6;
          break;
      }
      return 1;
    }
    v8 = *(_BYTE **)(this + 12);
    if ( *v8 == 108 )
    {
      *(_DWORD *)(this + 12) = v8 + 1;
      v9 = 4;
    }
    else
    {
      v9 = 3;
    }
    goto LABEL_44;
  }
  switch ( v1 )
  {
    case 'j':
      *(_DWORD *)(this + 40) = 5;
      return 1;
    case 'I':
      v6 = *(char **)(this + 12);
      v7 = *v6;
      if ( *v6 == 51 )
      {
        if ( v6[1] == 50 )
        {
          *(_DWORD *)(this + 40) = 10;
          *(_DWORD *)(this + 12) = v6 + 2;
        }
      }
      else if ( v7 == 54 )
      {
        if ( v6[1] == 52 )
        {
          *(_DWORD *)(this + 40) = 11;
          *(_DWORD *)(this + 12) = v6 + 2;
        }
      }
      else if ( v7 == 100 || v7 == 105 || v7 == 111 || v7 == 117 || v7 == 120 || v7 == 88 )
      {
        *(_DWORD *)(this + 40) = 9;
      }
      return 1;
    case 'L':
      *(_DWORD *)(this + 40) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(this + 40) = 13;
      return 1;
    case 'h':
      v4 = *(_BYTE **)(this + 12);
      if ( *v4 == 104 )
      {
        *(_DWORD *)(this + 12) = v4 + 1;
        v5 = 1;
LABEL_45:
        *(_DWORD *)(this + 40) = v5;
        return 1;
      }
      v9 = 2;
LABEL_44:
      v5 = v9;
      goto LABEL_45;
  }
  return 1;
}

//----- (10023F32) --------------------------------------------------------
char __thiscall sub_10023F32(int this)
{
  char v1; // al
  int v3; // eax
  _BYTE *v4; // eax
  int v5; // eax
  char *v6; // edx
  char v7; // al
  _BYTE *v8; // eax
  int v9; // [esp-4h] [ebp-4h]

  v1 = *(_BYTE *)(this + 45);
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *(_BYTE *)(this + 24) = 7;
      return sub_100243D8(this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *(_BYTE *)(this + 24) = 8;
LABEL_7:
      v3 = *(_DWORD *)(this + 8) + 24;
      *(_BYTE *)(v3 + 4) = 1;
      *(_DWORD *)v3 = 22;
      _invalid_parameter_internal(0, 0, 0, 0, 0, *(__crt_cached_ptd_host **)(this + 8));
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(this + 40) )
    goto LABEL_7;
  if ( v1 > 106 )
  {
    if ( v1 != 108 )
    {
      switch ( v1 )
      {
        case 't':
          *(_DWORD *)(this + 40) = 7;
          break;
        case 'w':
          *(_DWORD *)(this + 40) = 12;
          break;
        case 'z':
          *(_DWORD *)(this + 40) = 6;
          break;
      }
      return 1;
    }
    v8 = *(_BYTE **)(this + 12);
    if ( *v8 == 108 )
    {
      *(_DWORD *)(this + 12) = v8 + 1;
      v9 = 4;
    }
    else
    {
      v9 = 3;
    }
    goto LABEL_44;
  }
  switch ( v1 )
  {
    case 'j':
      *(_DWORD *)(this + 40) = 5;
      return 1;
    case 'I':
      v6 = *(char **)(this + 12);
      v7 = *v6;
      if ( *v6 == 51 )
      {
        if ( v6[1] == 50 )
        {
          *(_DWORD *)(this + 40) = 10;
          *(_DWORD *)(this + 12) = v6 + 2;
        }
      }
      else if ( v7 == 54 )
      {
        if ( v6[1] == 52 )
        {
          *(_DWORD *)(this + 40) = 11;
          *(_DWORD *)(this + 12) = v6 + 2;
        }
      }
      else if ( v7 == 100 || v7 == 105 || v7 == 111 || v7 == 117 || v7 == 120 || v7 == 88 )
      {
        *(_DWORD *)(this + 40) = 9;
      }
      return 1;
    case 'L':
      *(_DWORD *)(this + 40) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(this + 40) = 13;
      return 1;
    case 'h':
      v4 = *(_BYTE **)(this + 12);
      if ( *v4 == 104 )
      {
        *(_DWORD *)(this + 12) = v4 + 1;
        v5 = 1;
LABEL_45:
        *(_DWORD *)(this + 40) = v5;
        return 1;
      }
      v9 = 2;
LABEL_44:
      v5 = v9;
      goto LABEL_45;
  }
  return 1;
}

//----- (10024090) --------------------------------------------------------
char __thiscall sub_10024090(int this)
{
  int v2; // ebx
  int v3; // eax
  char v4; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // edi
  char v12; // cl
  char v13; // ah
  char v14; // al
  char v15; // al
  int v16; // ecx
  int v17; // ecx
  int *v18; // edi
  int v19; // eax
  int v20; // ecx
  bool v21; // cc
  unsigned __int16 *v22; // ecx
  int v23; // eax
  int v24; // eax
  int v25; // ecx
  int v26; // [esp-8h] [ebp-30h]
  int v27; // [esp+Ch] [ebp-1Ch]
  int v28; // [esp+10h] [ebp-18h]
  int v29; // [esp+10h] [ebp-18h]
  unsigned __int16 *v30; // [esp+10h] [ebp-18h]
  int v31; // [esp+10h] [ebp-18h]
  int v32; // [esp+14h] [ebp-14h]
  int v33; // [esp+14h] [ebp-14h]
  int v34; // [esp+14h] [ebp-14h]
  int v35; // [esp+18h] [ebp-10h] BYREF
  __int16 v36; // [esp+1Ch] [ebp-Ch] BYREF
  char v37; // [esp+1Eh] [ebp-Ah]

  v2 = 0;
  v3 = *(char *)(this + 45);
  if ( v3 <= 100 )
  {
    if ( v3 != 100 )
    {
      if ( v3 > 88 )
      {
        v6 = v3 - 90;
        if ( !v6 )
        {
          v4 = unknown_libname_18(this);
          goto LABEL_11;
        }
        v7 = v6 - 7;
        if ( !v7 )
          goto LABEL_29;
        if ( v7 != 2 )
          return 0;
      }
      else
      {
        if ( v3 == 88 )
        {
          v4 = sub_10022C9E(this, 1);
          goto LABEL_11;
        }
        if ( v3 == 65 )
          goto LABEL_29;
        if ( v3 != 67 )
        {
          if ( v3 <= 68 )
            return 0;
          if ( v3 > 71 )
          {
            if ( v3 == 83 )
            {
LABEL_10:
              v4 = unknown_libname_22(this);
              goto LABEL_11;
            }
            return 0;
          }
          goto LABEL_29;
        }
      }
      v4 = unknown_libname_20(0);
      goto LABEL_11;
    }
LABEL_27:
    *(_DWORD *)(this + 28) |= 0x10u;
LABEL_28:
    v4 = sub_10022B21(this, 0);
    goto LABEL_11;
  }
  if ( v3 > 112 )
  {
    v8 = v3 - 115;
    if ( !v8 )
      goto LABEL_10;
    v9 = v8 - 2;
    if ( !v9 )
      goto LABEL_28;
    if ( v9 != 3 )
      return 0;
    v4 = sub_10022C9E(this, 0);
  }
  else if ( v3 == 112 )
  {
    v4 = sub_10024AD4((_DWORD *)this);
  }
  else
  {
    if ( v3 <= 103 )
    {
LABEL_29:
      v4 = unknown_libname_19(this);
      goto LABEL_11;
    }
    switch ( v3 )
    {
      case 'i':
        goto LABEL_27;
      case 'n':
        v4 = unknown_libname_21(this);
        break;
      case 'o':
        v4 = sub_10024AB7((_DWORD *)this);
        break;
      default:
        return 0;
    }
  }
LABEL_11:
  if ( !v4 )
    return 0;
  if ( !*(_BYTE *)(this + 44) )
  {
    v10 = *(_DWORD *)(this + 28);
    v36 = 0;
    v37 = 0;
    v11 = 0;
    v35 = 0;
    if ( (v10 & 0x10) != 0 )
    {
      if ( (v10 & 0x40) != 0 )
      {
        LOBYTE(v36) = 45;
      }
      else
      {
        if ( (v10 & 1) == 0 )
        {
          if ( (v10 & 2) != 0 )
          {
            LOBYTE(v36) = 32;
            v11 = 1;
            v35 = 1;
          }
          goto LABEL_44;
        }
        LOBYTE(v36) = 43;
      }
      v11 = 1;
      v35 = 1;
    }
LABEL_44:
    v12 = *(_BYTE *)(this + 45);
    if ( v12 != 120 && v12 != 88 || (v13 = 1, (v10 & 0x20) == 0) )
      v13 = 0;
    if ( v12 == 97 || (v14 = 0, v12 == 65) )
      v14 = 1;
    if ( v13 || v14 )
    {
      *((_BYTE *)&v36 + v11) = 48;
      if ( v12 == 88 || v12 == 65 )
        v15 = 88;
      else
        v15 = 120;
      *((_BYTE *)&v36 + v11 + 1) = v15;
      v11 += 2;
      v35 = v11;
    }
    v27 = *(_DWORD *)(this + 32) - *(_DWORD *)(this + 52) - v11;
    if ( (v10 & 0xC) == 0 )
    {
      v16 = *(_DWORD *)(this + 8);
      v28 = v16;
      v32 = 0;
      if ( *(_DWORD *)(this + 32) - *(_DWORD *)(this + 52) - v11 > 0 )
      {
        while ( (unsigned __int8)__crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(
                                   32,
                                   v16) )
        {
          v17 = *(_DWORD *)(this + 20);
          *(_DWORD *)(this + 20) = v17 + 1;
          if ( v17 != -2 )
          {
            v16 = v28;
            if ( ++v32 < v27 )
              continue;
          }
          goto LABEL_65;
        }
        *(_DWORD *)(this + 20) = -1;
      }
    }
LABEL_65:
    v18 = (int *)(this + 20);
    __crt_stdio_output::stream_output_adapter<char>::write_string(&v36, v35, this + 20, *(_DWORD *)(this + 8));
    if ( (*(_DWORD *)(this + 28) & 8) != 0 && (*(_DWORD *)(this + 28) & 4) == 0 )
    {
      v19 = *(_DWORD *)(this + 8);
      v29 = v19;
      v33 = 0;
      if ( v27 > 0 )
      {
        while ( (unsigned __int8)__crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(
                                   48,
                                   v19) )
        {
          v20 = (*v18)++;
          if ( v20 != -2 )
          {
            v21 = ++v33 < v27;
            v19 = v29;
            if ( v21 )
              continue;
          }
          goto LABEL_73;
        }
        *v18 = -1;
      }
    }
LABEL_73:
    if ( *(_BYTE *)(this + 56) && *(int *)(this + 52) > 0 )
    {
      v22 = *(unsigned __int16 **)(this + 48);
      v34 = 0;
      while ( 1 )
      {
        v26 = *(_DWORD *)(this + 8);
        v23 = *v22;
        v35 = 0;
        v30 = v22 + 1;
        if ( _wctomb_internal(&v35, &v36, 6, v23, v26) || !v35 )
          break;
        __crt_stdio_output::stream_output_adapter<char>::write_string(&v36, v35, this + 20, *(_DWORD *)(this + 8));
        v22 = v30;
        if ( ++v34 == *(_DWORD *)(this + 52) )
          goto LABEL_82;
      }
      *v18 = -1;
    }
    else
    {
      __crt_stdio_output::stream_output_adapter<char>::write_string(
        *(_DWORD *)(this + 48),
        *(_DWORD *)(this + 52),
        this + 20,
        *(_DWORD *)(this + 8));
    }
LABEL_82:
    if ( *v18 >= 0 && (*(_DWORD *)(this + 28) & 4) != 0 )
    {
      v24 = *(_DWORD *)(this + 8);
      v31 = v24;
      if ( v27 > 0 )
      {
        while ( (unsigned __int8)__crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(
                                   32,
                                   v24) )
        {
          v25 = (*v18)++;
          if ( v25 != -2 )
          {
            v24 = v31;
            if ( ++v2 < v27 )
              continue;
          }
          return 1;
        }
        *v18 = -1;
      }
    }
  }
  return 1;
}
// 100247BA: using guessed type int __thiscall unknown_libname_18(_DWORD);
// 10024814: using guessed type int __thiscall unknown_libname_19(_DWORD);
// 1002499E: using guessed type _DWORD __stdcall unknown_libname_20(_DWORD);
// 10024A33: using guessed type int __thiscall unknown_libname_21(_DWORD);
// 10024AEA: using guessed type int __thiscall unknown_libname_22(_DWORD);
// 10024D48: using guessed type _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_character_without_count_update(char, _DWORD);
// 10024D82: using guessed type _DWORD __stdcall __crt_stdio_output::stream_output_adapter<char>::write_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 1002C140: using guessed type int __cdecl _wctomb_internal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100243D8) --------------------------------------------------------
char __thiscall sub_100243D8(int this)
{
  int v1; // esi
  int v2; // ebx
  int v3; // eax
  char v4; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  char v12; // dl
  char v13; // ah
  char v14; // al
  char v15; // al
  int v16; // edx
  int v17; // edi
  int i; // ecx
  int v19; // ebx
  int *v20; // edi
  int v21; // edx
  int v22; // ebx
  unsigned __int16 *v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // edx
  int v27; // [esp-8h] [ebp-30h]
  int v28; // [esp+8h] [ebp-20h]
  unsigned __int16 *v30; // [esp+Ch] [ebp-1Ch]
  int v31; // [esp+10h] [ebp-18h]
  int *v32; // [esp+10h] [ebp-18h]
  int v33; // [esp+14h] [ebp-14h] BYREF
  int Src; // [esp+18h] [ebp-10h] BYREF
  char v35[8]; // [esp+1Ch] [ebp-Ch] BYREF

  v1 = this;
  v2 = 0;
  v3 = *(char *)(this + 45);
  if ( v3 > 100 )
  {
    if ( v3 > 112 )
    {
      v8 = v3 - 115;
      if ( !v8 )
        goto LABEL_10;
      v9 = v8 - 2;
      if ( v9 )
      {
        if ( v9 != 3 )
          return 0;
        v4 = sub_10022C9E(this, 0);
        goto LABEL_11;
      }
LABEL_29:
      v4 = sub_10022B21(this, 0);
      goto LABEL_11;
    }
    if ( v3 == 112 )
    {
      v4 = sub_10024AD4((_DWORD *)this);
      goto LABEL_11;
    }
    if ( v3 <= 103 )
      goto LABEL_30;
    if ( v3 != 105 )
    {
      if ( v3 == 110 )
      {
        v4 = unknown_libname_21(this);
      }
      else
      {
        if ( v3 != 111 )
          return 0;
        v4 = sub_10024AB7((_DWORD *)this);
      }
      goto LABEL_11;
    }
LABEL_28:
    *(_DWORD *)(this + 28) |= 0x10u;
    goto LABEL_29;
  }
  if ( v3 == 100 )
    goto LABEL_28;
  if ( v3 > 88 )
  {
    v6 = v3 - 90;
    if ( !v6 )
    {
      v4 = unknown_libname_18(this);
      goto LABEL_11;
    }
    v7 = v6 - 7;
    if ( !v7 )
      goto LABEL_30;
    if ( v7 != 2 )
      return 0;
    goto LABEL_18;
  }
  if ( v3 != 88 )
  {
    if ( v3 != 65 )
    {
      if ( v3 != 67 )
      {
        if ( v3 <= 68 )
          return 0;
        if ( v3 > 71 )
        {
          if ( v3 == 83 )
          {
LABEL_10:
            v4 = unknown_libname_22(this);
            goto LABEL_11;
          }
          return 0;
        }
        goto LABEL_30;
      }
LABEL_18:
      v4 = unknown_libname_20(0);
      goto LABEL_11;
    }
LABEL_30:
    v4 = unknown_libname_19(this);
    goto LABEL_11;
  }
  v4 = sub_10022C9E(this, 1);
LABEL_11:
  if ( !v4 )
    return 0;
  if ( !*(_BYTE *)(v1 + 44) )
  {
    v10 = *(_DWORD *)(v1 + 28) >> 4;
    LOWORD(Src) = 0;
    v11 = 0;
    BYTE2(Src) = 0;
    v31 = 0;
    if ( (v10 & 1) != 0 )
    {
      if ( (*(_DWORD *)(v1 + 28) & 0x40) != 0 )
      {
        LOBYTE(Src) = 45;
      }
      else
      {
        if ( (*(_BYTE *)(v1 + 28) & 1) == 0 )
        {
          if ( (*(_DWORD *)(v1 + 28) & 2) != 0 )
          {
            LOBYTE(Src) = 32;
            v11 = 1;
            v31 = 1;
          }
          goto LABEL_45;
        }
        LOBYTE(Src) = 43;
      }
      v11 = 1;
      v31 = 1;
    }
LABEL_45:
    v12 = *(_BYTE *)(v1 + 45);
    if ( v12 != 120 && v12 != 88 || (v13 = 1, (*(_DWORD *)(v1 + 28) & 0x20) == 0) )
      v13 = 0;
    if ( v12 == 97 || (v14 = 0, v12 == 65) )
      v14 = 1;
    if ( v13 || v14 )
    {
      v35[v11 - 4] = 48;
      if ( v12 == 88 || v12 == 65 )
        v15 = 88;
      else
        v15 = 120;
      v35[v11 - 3] = v15;
      v11 += 2;
      v31 = v11;
    }
    v16 = *(_DWORD *)(v1 + 32) - *(_DWORD *)(v1 + 52) - v11;
    v28 = v16;
    if ( (*(_BYTE *)(v1 + 28) & 0xC) == 0 && v16 > 0 )
    {
      v17 = *(_DWORD *)(v1 + 20);
      for ( i = 0; i < v16; ++i )
      {
        v19 = *(_DWORD *)(v1 + 1096);
        if ( *(_DWORD *)(v19 + 8) == *(_DWORD *)(v19 + 4) )
        {
          if ( *(_BYTE *)(v19 + 12) )
            ++v17;
          else
            v17 = -1;
          *(_DWORD *)(v1 + 20) = v17;
        }
        else
        {
          *(_DWORD *)(v1 + 20) = v17 + 1;
          ++*(_DWORD *)(v19 + 8);
          *(_BYTE *)(**(_DWORD **)(v1 + 1096))++ = 32;
          v17 = *(_DWORD *)(v1 + 20);
        }
        if ( v17 == -1 )
          break;
      }
      v11 = v31;
      v2 = 0;
    }
    v20 = (int *)(v1 + 20);
    v32 = (int *)(v1 + 1096);
    unknown_libname_25(&Src, v11, v1 + 20, *(_DWORD *)(v1 + 8));
    if ( (*(_DWORD *)(v1 + 28) & 8) != 0 && (*(_DWORD *)(v1 + 28) & 4) == 0 )
    {
      Src = 0;
      if ( v28 > 0 )
      {
        v21 = *v20;
        do
        {
          v33 = *v32;
          v22 = v33;
          if ( *(_DWORD *)(v33 + 8) == *(_DWORD *)(v33 + 4) )
          {
            if ( *(_BYTE *)(v33 + 12) )
              ++v21;
            else
              v21 = -1;
            *v20 = v21;
          }
          else
          {
            *v20 = v21 + 1;
            ++*(_DWORD *)(v22 + 8);
            *(_BYTE *)(*(_DWORD *)*v32)++ = 48;
            v21 = *v20;
          }
          if ( v21 == -1 )
            break;
          ++Src;
        }
        while ( Src < v28 );
        v1 = this;
        v2 = 0;
      }
    }
    if ( *(_BYTE *)(v1 + 56) && *(int *)(v1 + 52) > 0 )
    {
      v23 = *(unsigned __int16 **)(v1 + 48);
      Src = 0;
      while ( 1 )
      {
        v27 = *(_DWORD *)(v1 + 8);
        v24 = *v23;
        v33 = 0;
        v30 = v23 + 1;
        if ( _wctomb_internal(&v33, v35, 6, v24, v27) || !v33 )
          break;
        unknown_libname_25(v35, v33, (int)v20, *(_DWORD *)(v1 + 8));
        v23 = v30;
        if ( ++Src == *(_DWORD *)(v1 + 52) )
          goto LABEL_93;
      }
      *v20 = -1;
    }
    else
    {
      unknown_libname_25(*(void **)(v1 + 48), *(_DWORD *)(v1 + 52), (int)v20, *(_DWORD *)(v1 + 8));
    }
LABEL_93:
    v25 = *v20;
    if ( *v20 >= 0 && (*(_DWORD *)(v1 + 28) & 4) != 0 && v28 > 0 )
    {
      do
      {
        v26 = *v32;
        if ( *(_DWORD *)(*v32 + 8) == *(_DWORD *)(*v32 + 4) )
        {
          if ( *(_BYTE *)(v26 + 12) )
            ++v25;
          else
            v25 = -1;
          *v20 = v25;
        }
        else
        {
          *v20 = v25 + 1;
          ++*(_DWORD *)(v26 + 8);
          *(_BYTE *)(*(_DWORD *)*v32)++ = 32;
          v25 = *v20;
        }
        if ( v25 == -1 )
          break;
        ++v2;
      }
      while ( v2 < v28 );
    }
  }
  return 1;
}
// 100247BA: using guessed type int __thiscall unknown_libname_18(_DWORD);
// 10024814: using guessed type int __thiscall unknown_libname_19(_DWORD);
// 1002499E: using guessed type _DWORD __stdcall unknown_libname_20(_DWORD);
// 10024A33: using guessed type int __thiscall unknown_libname_21(_DWORD);
// 10024AEA: using guessed type int __thiscall unknown_libname_22(_DWORD);
// 1002C140: using guessed type int __cdecl _wctomb_internal(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10024AB7) --------------------------------------------------------
char __thiscall sub_10024AB7(_DWORD *this)
{
  if ( (this[7] & 0x20) != 0 )
    this[7] |= 0x80u;
  return sub_100229A4((int)this, 0);
}

//----- (10024AD4) --------------------------------------------------------
char __thiscall sub_10024AD4(_DWORD *this)
{
  this[9] = 8;
  this[10] = 10;
  return sub_10022C9E((int)this, 1);
}

//----- (10024EB6) --------------------------------------------------------
int __cdecl sub_10024EB6(int a1, int a2, int a3, int a4, struct __crt_locale_pointers *a5, int a6)
{
  int v6; // esi
  char v8[24]; // [esp+4h] [ebp-5Ch] BYREF
  int v9; // [esp+1Ch] [ebp-44h]
  char v10; // [esp+20h] [ebp-40h]
  int v11[5]; // [esp+2Ch] [ebp-34h] BYREF
  int v12[2]; // [esp+40h] [ebp-20h] BYREF
  int v13; // [esp+48h] [ebp-18h] BYREF
  int v14; // [esp+4Ch] [ebp-14h] BYREF
  int v15; // [esp+50h] [ebp-10h] BYREF
  int v16; // [esp+54h] [ebp-Ch] BYREF
  int v17; // [esp+58h] [ebp-8h] BYREF

  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v8, a5);
  v15 = a6;
  v16 = a4;
  v17 = a3;
  v12[0] = a1;
  v12[1] = a2;
  if ( a3 && a4 )
  {
    v14 = a3;
    v11[0] = (int)&v17;
    v13 = a3;
    v11[1] = (int)v8;
    v11[2] = (int)v12;
    v11[3] = (int)&v16;
    v11[4] = (int)&v15;
    v6 = __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(
           &v13,
           v11,
           &v14);
  }
  else
  {
    v10 = 1;
    v9 = 22;
    _invalid_parameter_internal(0, 0, 0, 0, 0, (__crt_cached_ptd_host *)v8);
    v6 = -1;
  }
  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v8);
  return v6;
}
// 1002227F: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_4ac01c32aa5b53846f05d0620572872e_,_lambda_5856287d7ecd2be6c9197bb4007c3f6e_ &,_lambda_e7a9868ed898c75c0f0637692d94351a_>(_DWORD, _DWORD, _DWORD);

//----- (1002513E) --------------------------------------------------------
int __cdecl sub_1002513E(int a1)
{
  int result; // eax

  result = a1;
  dword_10052998 = a1;
  return result;
}
// 10052998: using guessed type int dword_10052998;

//----- (10025BDA) --------------------------------------------------------
int __cdecl sub_10025BDA(int a1)
{
  int result; // eax

  result = a1;
  dword_100529B4 = a1;
  return result;
}
// 100529B4: using guessed type int dword_100529B4;

//----- (10025C0E) --------------------------------------------------------
int sub_10025C0E()
{
  return dword_100529B0;
}
// 100529B0: using guessed type int dword_100529B0;

//----- (10026169) --------------------------------------------------------
int sub_10026169()
{
  return common_flush_all(1);
}

//----- (10027E6A) --------------------------------------------------------
int __cdecl sub_10027E6A(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // esi
  int v6; // [esp-10h] [ebp-40h] BYREF
  int v7; // [esp-Ch] [ebp-3Ch]
  int v8; // [esp-8h] [ebp-38h]
  int v9; // [esp-4h] [ebp-34h]
  char v10[44]; // [esp+4h] [ebp-2Ch] BYREF

  __crt_cached_ptd_host::__crt_cached_ptd_host((__crt_cached_ptd_host *)v10, 0);
  v9 = 0;
  v8 = a3;
  v7 = v3;
  v6 = v3;
  unknown_libname_5(&v6, a1, a2);
  v4 = __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>,1>(
         (__crt_cached_ptd_host *)v10,
         v6,
         v7,
         v8,
         v9);
  __crt_cached_ptd_host::~__crt_cached_ptd_host((__crt_cached_ptd_host *)v10);
  return v4;
}
// 10027E82: variable 'v3' is possibly undefined
// 1002275C: using guessed type _DWORD __cdecl unknown_libname_5(_DWORD, _DWORD, _DWORD);

//----- (10027F67) --------------------------------------------------------
int __stdcall sub_10027F67(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = _lambda_2116bde18c9e5f34230805ea4a4660ed_::operator()(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 10027EF1: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 10027F39: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 10027FC2: using guessed type int __thiscall _lambda_2116bde18c9e5f34230805ea4a4660ed_::operator()(_DWORD);

//----- (1002926D) --------------------------------------------------------
int __cdecl sub_1002926D(LPCCH lpMultiByteStr, struct __crt_win32_buffer_empty_debug_info *a2, UINT CodePage)
{
  int v3; // ecx
  int var1; // [esp+1h] [ebp-1h] BYREF

  LOBYTE(var1) = HIBYTE(v3);
  return __acrt_convert_wcs_mbs_cp<char,wchar_t,_lambda_62f6974d9771e494a5ea317cc32e971c_,__crt_win32_buffer_internal_dynamic_resizing>(
           lpMultiByteStr,
           a2,
           (int)&var1,
           CodePage);
}
// 10029272: variable 'v3' is possibly undefined

//----- (100292EF) --------------------------------------------------------
int __thiscall sub_100292EF(void **this, int a2)
{
  int result; // eax

  unknown_libname_29();
  result = __crt_win32_buffer_internal_dynamic_resizing::allocate(
             this + 2,
             2 * a2,
             (const struct __crt_win32_buffer_empty_debug_info *)this);
  if ( result )
  {
    this[3] = 0;
    *((_BYTE *)this + 20) = 0;
  }
  else
  {
    *((_BYTE *)this + 20) = 1;
    result = 0;
    this[3] = (void *)a2;
  }
  return result;
}
// 100292AE: using guessed type int unknown_libname_29(void);

//----- (10029633) --------------------------------------------------------
int __cdecl sub_10029633(int a1)
{
  int result; // eax

  result = a1;
  dword_10052B14 = a1;
  return result;
}
// 10052B14: using guessed type int dword_10052B14;

//----- (10029CA7) --------------------------------------------------------
void *__cdecl sub_10029CA7(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_10052C2C )
    return (void *)unknown_libname_31(*a1);
  return result;
}

//----- (10029CC2) --------------------------------------------------------
void *__cdecl sub_10029CC2(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_10052C28 )
    return (void *)unknown_libname_31(*a1);
  return result;
}

//----- (10029D33) --------------------------------------------------------
int __stdcall sub_10029D33(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = unknown_libname_34(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 10027EF1: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 10027F39: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 10029F0A: using guessed type int __thiscall unknown_libname_34(_DWORD);

//----- (10029D8E) --------------------------------------------------------
int __stdcall sub_10029D8E(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = unknown_libname_33(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 10027EF1: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 10027F39: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);
// 10029E08: using guessed type int __thiscall unknown_libname_33(_DWORD);

//----- (10029FE4) --------------------------------------------------------
int __cdecl sub_10029FE4(_onexit_t Function)
{
  return _register_onexit_function(&stru_10052C30, Function);
}

//----- (1002A0E7) --------------------------------------------------------
char sub_1002A0E7()
{
  dword_10052F4C = (struct __crt_locale_data *)&off_10051210;
  return 1;
}
// 10051210: using guessed type wchar_t *off_10051210;

//----- (1002A10E) --------------------------------------------------------
#error "1002A10E: call analysis failed (funcsize=3)"

//----- (1002A144) --------------------------------------------------------
__vcrt_bool sub_1002A144()
{
  return __vcrt_uninitialize(0);
}

//----- (1002A1A4) --------------------------------------------------------
bool sub_1002A1A4()
{
  return unknown_libname_36() != 0;
}
// 1002C9F9: using guessed type int unknown_libname_36(void);

//----- (1002AAE2) --------------------------------------------------------
BOOL __stdcall LocaleEnumProc(LPWSTR a1)
{
  return _lambda_29d3c280b90b41c2ae070ffca879996a_::operator()(a1);
}
// 1002AB6B: using guessed type _DWORD __stdcall _lambda_29d3c280b90b41c2ae070ffca879996a_::operator()(_DWORD);

//----- (1002ABE8) --------------------------------------------------------
int sub_1002ABE8()
{
  return try_get_function(4, "GetDateFormatEx", &unk_100422DC, "GetDateFormatEx");
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AC1C) --------------------------------------------------------
int sub_1002AC1C()
{
  return try_get_function(10, "GetTimeFormatEx", &unk_1004230C, "GetTimeFormatEx");
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AC36) --------------------------------------------------------
int sub_1002AC36()
{
  return try_get_function(11, "GetUserDefaultLocaleName", &unk_10042324, "GetUserDefaultLocaleName");
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AC50) --------------------------------------------------------
int sub_1002AC50()
{
  return try_get_function(15, "IsValidLocaleName", &unk_10042350, "IsValidLocaleName");
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AC6A) --------------------------------------------------------
int sub_1002AC6A()
{
  return try_get_function(17, "LCIDToLocaleName", &unk_10042384, "LCIDToLocaleName");
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AC84) --------------------------------------------------------
int sub_1002AC84()
{
  return try_get_function(16, "LCMapStringEx", &unk_1004236C, "LCMapStringEx");
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AC9E) --------------------------------------------------------
int sub_1002AC9E()
{
  return try_get_function(18, "LocaleNameToLCID", &unk_100423A0, "LocaleNameToLCID");
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002AF37) --------------------------------------------------------
LPVOID __stdcall sub_1002AF37(DWORD a1)
{
  int (__thiscall *function)(_DWORD, DWORD); // eax

  function = (int (__thiscall *)(_DWORD, DWORD))try_get_function(32, "FlsGetValue", &unk_100423F8, &unk_10042400);
  if ( function )
    return (LPVOID)function(function, a1);
  else
    return TlsGetValue(a1);
}
// 1002AD83: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002B0F5) --------------------------------------------------------
int __stdcall sub_1002B0F5(
        wchar_t *a1,
        DWORD dwMapFlags,
        LPCWSTR lpSrcStr,
        int cchSrc,
        LPWSTR lpDestStr,
        int cchDest,
        int a7,
        int a8,
        int a9)
{
  int (__thiscall *v9)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int); // eax
  LCID v11; // eax

  v9 = (int (__thiscall *)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int))sub_1002AC84();
  if ( v9 )
    return v9(v9, a1, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, a7, a8, a9);
  v11 = __acrt_LocaleNameToLCID(a1, 0);
  return LCMapStringW(v11, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (1002B53A) --------------------------------------------------------
struct __crt_locale_data *__cdecl sub_1002B53A(int a1, struct __crt_locale_data **a2)
{
  struct __crt_locale_data *result; // eax

  result = *a2;
  if ( *a2 != dword_10052F4C )
  {
    result = (struct __crt_locale_data *)dword_100513DC;
    if ( (dword_100513DC & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_locale_data *)__acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 1003554B: using guessed type int __acrt_update_thread_locale_data(void);
// 100513DC: using guessed type int dword_100513DC;

//----- (1002B567) --------------------------------------------------------
int __cdecl sub_1002B567(int a1, int *a2, int a3)
{
  int result; // eax

  result = a3;
  if ( (struct __crt_locale_data *)*a2 != *(&dword_10052F4C + a3) )
  {
    result = dword_100513DC;
    if ( (dword_100513DC & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = __acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 1003554B: using guessed type int __acrt_update_thread_locale_data(void);
// 100513DC: using guessed type int dword_100513DC;

//----- (1002B598) --------------------------------------------------------
struct __crt_multibyte_data *__cdecl sub_1002B598(int a1, struct __crt_multibyte_data **a2)
{
  struct __crt_multibyte_data *result; // eax

  result = *a2;
  if ( *a2 != dword_1005303C )
  {
    result = (struct __crt_multibyte_data *)dword_100513DC;
    if ( (dword_100513DC & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_multibyte_data *)__acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 10034827: using guessed type int __acrt_update_thread_multibyte_data(void);
// 100513DC: using guessed type int dword_100513DC;

//----- (1002B5C5) --------------------------------------------------------
int __cdecl sub_1002B5C5(int a1, int *a2, int a3)
{
  int result; // eax

  result = a3;
  if ( (struct __crt_multibyte_data *)*a2 != *(&dword_1005303C + a3) )
  {
    result = dword_100513DC;
    if ( (dword_100513DC & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = __acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 10034827: using guessed type int __acrt_update_thread_multibyte_data(void);
// 100513DC: using guessed type int dword_100513DC;

//----- (1002CF4E) --------------------------------------------------------
__int32 sub_1002CF4E()
{
  return _InterlockedExchange(&dword_10052F48, 1);
}
// 10052F48: using guessed type int dword_10052F48;

//----- (10030035) --------------------------------------------------------
int __cdecl sub_10030035(int a1, __crt_cached_ptd_host *a2)
{
  __crt_cached_ptd_host *v2; // eax
  __crt_cached_ptd_host *v4; // eax
  __crt_cached_ptd_host *v5; // [esp-4h] [ebp-1Ch]
  int v6[2]; // [esp+4h] [ebp-14h] BYREF
  int v7; // [esp+Ch] [ebp-Ch] BYREF
  int v8; // [esp+10h] [ebp-8h] BYREF

  if ( a1 == -2 )
  {
    v2 = a2;
    *((_DWORD *)a2 + 8) = 0;
    *((_BYTE *)v2 + 36) = 1;
    *((_BYTE *)v2 + 28) = 1;
    *((_DWORD *)v2 + 6) = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_10052F30
      && (*(_BYTE *)(&lpCriticalSection[a1 >> 6][1].LockSemaphore + 14 * (a1 & 0x3F)) & 1) != 0 )
    {
      v8 = a1;
      v6[0] = (int)&a1;
      v6[1] = (int)a2;
      v7 = a1;
      return __crt_seh_guarded_call<int>::operator()<_lambda_d422a76eb4c3bf3ad751449ab71a6ea4_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_9476263c8ee91a25d21c55370bdb50de_>(
               &v7,
               v6,
               &v8);
    }
    v4 = a2;
    v5 = a2;
    *((_BYTE *)a2 + 36) = 1;
    *((_DWORD *)v4 + 8) = 0;
    *((_BYTE *)v4 + 28) = 1;
    *((_DWORD *)v4 + 6) = 9;
    _invalid_parameter_internal(0, 0, 0, 0, 0, v5);
  }
  return -1;
}
// 1002FFA4: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_d422a76eb4c3bf3ad751449ab71a6ea4_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_9476263c8ee91a25d21c55370bdb50de_>(_DWORD, _DWORD, _DWORD);
// 10052D30: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];
// 10052F30: using guessed type int dword_10052F30;
// 10030035: using guessed type int var_8;

//----- (1003058F) --------------------------------------------------------
int __cdecl sub_1003058F(int a1, FILE *a2, int a3)
{
  return common_flush_and_write_nolock<char>(a1, a2, a3);
}

//----- (100306CE) --------------------------------------------------------
int sub_100306CE()
{
  return dword_10052F50;
}
// 10052F50: using guessed type int dword_10052F50;

//----- (100308A4) --------------------------------------------------------
int __cdecl sub_100308A4(int a1, int a2, int a3)
{
  return sub_1003082C(a1, a2, a3);
}
// 1003082C: using guessed type _DWORD __cdecl sub_1003082C(_DWORD, _DWORD, _DWORD);

//----- (10033BEC) --------------------------------------------------------
int __cdecl sub_10033BEC(LPCWCH lpWideCharStr, struct __crt_win32_buffer_empty_debug_info *a2, int a3, UINT CodePage)
{
  struct __crt_win32_buffer_empty_debug_info *v4; // esi
  int result; // eax
  size_t v6; // eax
  DWORD v7; // eax
  int v8; // eax
  DWORD LastError; // eax

  if ( !lpWideCharStr )
  {
    v4 = a2;
    unknown_libname_29(a2);
    *((_DWORD *)a2 + 2) = 0;
    *((_DWORD *)a2 + 3) = 0;
LABEL_3:
    *((_DWORD *)v4 + 4) = 0;
    return 0;
  }
  if ( *lpWideCharStr )
  {
    v6 = __acrt_WideCharToMultiByte(CodePage, 0, lpWideCharStr, -1, 0, 0, 0, 0);
    if ( v6 )
    {
      if ( v6 <= *((_DWORD *)a2 + 3) || (result = sub_1003418E((void **)a2, v6)) == 0 )
      {
        v8 = unknown_libname_28(CodePage, lpWideCharStr, *((LPSTR *)a2 + 2), *((_DWORD *)a2 + 3));
        if ( v8 )
        {
          *((_DWORD *)a2 + 4) = v8 - 1;
          return 0;
        }
        else
        {
          LastError = GetLastError();
          __acrt_errno_map_os_error(LastError);
          return *_errno();
        }
      }
    }
    else
    {
      v7 = GetLastError();
      __acrt_errno_map_os_error(v7);
      return *_errno();
    }
  }
  else
  {
    v4 = a2;
    if ( *((_DWORD *)a2 + 3) || (result = sub_1003418E((void **)a2, 1u)) == 0 )
    {
      **((_BYTE **)a2 + 2) = 0;
      goto LABEL_3;
    }
  }
  return result;
}
// 100288C9: using guessed type _DWORD __cdecl __acrt_errno_map_os_error(_DWORD);
// 100292AE: using guessed type int __thiscall unknown_libname_29(_DWORD);

//----- (1003418E) --------------------------------------------------------
int __thiscall sub_1003418E(void **this, size_t Size)
{
  int result; // eax

  unknown_libname_29();
  result = __crt_win32_buffer_internal_dynamic_resizing::allocate(
             this + 2,
             Size,
             (const struct __crt_win32_buffer_empty_debug_info *)this);
  if ( result )
  {
    this[3] = 0;
    *((_BYTE *)this + 20) = 0;
  }
  else
  {
    *((_BYTE *)this + 20) = 1;
    result = 0;
    this[3] = (void *)Size;
  }
  return result;
}
// 100292AE: using guessed type int unknown_libname_29(void);

//----- (10034C18) --------------------------------------------------------
char sub_10034C18()
{
  hHeap = 0;
  return 1;
}

//----- (10034CD3) --------------------------------------------------------
int __cdecl sub_10034CD3(int a1)
{
  int result; // eax

  result = a1;
  dword_10053064 = a1;
  return result;
}
// 10053064: using guessed type int dword_10053064;

//----- (10034D28) --------------------------------------------------------
int sub_10034D28()
{
  return dword_10053068;
}
// 10053068: using guessed type int dword_10053068;

//----- (1003A320) --------------------------------------------------------
int __cdecl sub_1003A320(wchar_t Source, struct __crt_locale_pointers *a2)
{
  int result; // eax
  wchar_t *v3; // eax
  int v4; // [esp+0h] [ebp-14h] BYREF
  _DWORD *v5; // [esp+4h] [ebp-10h]
  char v6; // [esp+Ch] [ebp-8h]
  WCHAR DestStr; // [esp+10h] [ebp-4h] BYREF

  result = 0xFFFF;
  if ( Source != 0xFFFF )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v4, a2);
    if ( v5[2] == 65001 )
    {
      if ( Source < 0x80u )
      {
        if ( (_wctype[(unsigned __int8)Source + 1] & 1) != 0 )
          LOWORD(result) = *(unsigned __int8 *)(v5[37] + (unsigned __int8)Source);
        else
          LOWORD(result) = (unsigned __int8)Source;
        goto LABEL_11;
      }
      v3 = (wchar_t *)v5[42];
    }
    else
    {
      if ( Source < 0x100u )
      {
        if ( (_wctype[(unsigned __int8)Source + 1] & 1) != 0 )
          LOWORD(result) = *(unsigned __int8 *)(v5[37] + (unsigned __int8)Source);
        else
          LOWORD(result) = (unsigned __int8)Source;
        goto LABEL_11;
      }
      v3 = (wchar_t *)v5[42];
      if ( !v3 )
      {
        LOWORD(result) = Source;
        goto LABEL_11;
      }
    }
    if ( __acrt_LCMapStringW(v3, 0x100u, &Source, 1u, &DestStr, 1) )
    {
      result = DestStr;
LABEL_21:
      if ( v6 )
        *(_DWORD *)(v4 + 848) &= ~2u;
      return result;
    }
    LOWORD(result) = Source;
LABEL_11:
    result = (unsigned __int16)result;
    goto LABEL_21;
  }
  return result;
}

//----- (1003B1E3) --------------------------------------------------------
BOOL sub_1003B1E3()
{
  char *v0; // ecx

  v0 = (char *)hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    __dcrt_lowio_initialize_console_output();
    v0 = (char *)hConsoleOutput;
  }
  return v0 + 1 != 0;
}

//----- (1003BB04) --------------------------------------------------------
int sub_1003BB04()
{
  if ( !dword_10053084 )
    dword_10053084 = 0x4000;
  return 0;
}
// 10053084: using guessed type int dword_10053084;

//----- (1003BF00) --------------------------------------------------------
int __usercall sub_1003BF00@<eax>(double _ST7@<st0>)
{
  int result; // eax
  unsigned __int16 v2; // cx
  double v6; // [esp+0h] [ebp-14h]
  __int16 v7; // [esp+8h] [ebp-Ch]

  if ( dword_100525A8 >= 2 )
    return (int)_ST7;
  v6 = _ST7;
  result = HIDWORD(v6);
  v2 = v7 & 0x7FFF;
  if ( (v7 & 0x7FFFu) < 0x3FFF )
  {
    __asm { frndint }
    return 0;
  }
  else
  {
    if ( v6 >= 0.0 )
      return 0x80000000;
    if ( v2 < 0x401Eu )
    {
      __asm { frndint }
      return (-((v7 & 0x8000) != 0) ^ (HIDWORD(v6) >> (62 - v7))) + ((v7 & 0x8000) != 0);
    }
    if ( v2 <= 0x401Eu && (v7 & 0x8000) != 0 && HIDWORD(v6) == 0x80000000 )
      __asm { frndint }
    else
      return 0x80000000;
  }
  return result;
}
// 1003BF00: could not find valid save-restore pair for ebp
// 1003BF28: variable 'v7' is possibly undefined
// 100525A8: using guessed type int dword_100525A8;

//----- (1003D970) --------------------------------------------------------
void __cdecl sub_1003D970()
{
  void *v0; // esi

  if ( dword_10053138 )
  {
    sub_10001D30((int)dword_10053138, dword_1005313C);
    v0 = dword_10053138;
    if ( (unsigned int)(24 * ((dword_10053140 - (int)dword_10053138) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)dword_10053138 - *((_DWORD *)dword_10053138 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v0 = (void *)*((_DWORD *)dword_10053138 - 1);
    }
    sub_1001D481(v0);
    dword_10053138 = 0;
    dword_1005313C = 0;
    dword_10053140 = 0;
  }
}
// 1005313C: using guessed type int dword_1005313C;
// 10053140: using guessed type int dword_10053140;

//----- (1003DA00) --------------------------------------------------------
void __cdecl sub_1003DA00()
{
  *(int *)((char *)&dword_10053148 + *(_DWORD *)(dword_10053148 + 4)) = (int)&std::ofstream::`vftable';
  *(int *)((char *)&dword_10053144 + *(_DWORD *)(dword_10053148 + 4)) = *(_DWORD *)(dword_10053148 + 4) - 104;
  sub_10003C40((int)&dword_1005314C);
  *(int *)((char *)&dword_10053148 + *(_DWORD *)(dword_10053148 + 4)) = (int)&std::ostream::`vftable';
  *(int *)((char *)&dword_10053144 + *(_DWORD *)(dword_10053148 + 4)) = *(_DWORD *)(dword_10053148 + 4) - 8;
  dword_100531B0 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)&dword_100531B0);
}
// 1004A8C0: using guessed type void *std::ios_base::`vftable';
// 1004A908: using guessed type void *std::ofstream::`vftable';
// 1004A918: using guessed type void *std::ostream::`vftable';
// 10053144: using guessed type int dword_10053144;
// 10053148: using guessed type int dword_10053148;
// 1005314C: using guessed type int dword_1005314C;

//----- (1003DA99) --------------------------------------------------------
void __cdecl sub_1003DA99()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_10051000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_10052350;
    do
      _Mtxdst(v0++);
    while ( v0 != (struct _RTL_CRITICAL_SECTION *)&dword_10052410 );
  }
}
// 10051000: using guessed type int dword_10051000;
// 10052410: using guessed type int dword_10052410;

//----- (1003DAA3) --------------------------------------------------------
void __cdecl sub_1003DAA3()
{
  std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t((std::_Fac_tidy_reg_t *)&unk_10052438);
}

//----- (1003DAAD) --------------------------------------------------------
void __cdecl sub_1003DAAD()
{
  sub_10002A30(&dword_1005242C);
}
// 1005242C: using guessed type _DWORD dword_1005242C;

//----- (1003DAB7) --------------------------------------------------------
void __cdecl sub_1003DAB7()
{
  _Init_atexit::~_Init_atexit((_Init_atexit *)&unk_100524AD);
}

//----- (1003DAC1) --------------------------------------------------------
void __cdecl sub_1003DAC1()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(&dword_10051000, 0xFFFFFFFF) < 0 )
  {
    v0 = &stru_10052350;
    do
      _Mtxdst(v0++);
    while ( v0 != (struct _RTL_CRITICAL_SECTION *)&dword_10052410 );
  }
}
// 10051000: using guessed type int dword_10051000;
// 10052410: using guessed type int dword_10052410;

// nfuncs=1374 queued=574 decompiled=574 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 574 function(s)"
